
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model VehicleType
 * 
 */
export type VehicleType = $Result.DefaultSelection<Prisma.$VehicleTypePayload>
/**
 * Model VehicleYear
 * 
 */
export type VehicleYear = $Result.DefaultSelection<Prisma.$VehicleYearPayload>
/**
 * Model YearBrand
 * 
 */
export type YearBrand = $Result.DefaultSelection<Prisma.$YearBrandPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model YearModel
 * 
 */
export type YearModel = $Result.DefaultSelection<Prisma.$YearModelPayload>
/**
 * Model Model
 * 
 */
export type Model = $Result.DefaultSelection<Prisma.$ModelPayload>
/**
 * Model YearModelVersion
 * 
 */
export type YearModelVersion = $Result.DefaultSelection<Prisma.$YearModelVersionPayload>
/**
 * Model Version
 * 
 */
export type Version = $Result.DefaultSelection<Prisma.$VersionPayload>
/**
 * Model YearModelVersionBodyType
 * 
 */
export type YearModelVersionBodyType = $Result.DefaultSelection<Prisma.$YearModelVersionBodyTypePayload>
/**
 * Model BodyType
 * 
 */
export type BodyType = $Result.DefaultSelection<Prisma.$BodyTypePayload>
/**
 * Model YearModelVersionBodyTypeFuel
 * 
 */
export type YearModelVersionBodyTypeFuel = $Result.DefaultSelection<Prisma.$YearModelVersionBodyTypeFuelPayload>
/**
 * Model FuelType
 * 
 */
export type FuelType = $Result.DefaultSelection<Prisma.$FuelTypePayload>
/**
 * Model YearModelVersionBodyTypeFuelTransmission
 * 
 */
export type YearModelVersionBodyTypeFuelTransmission = $Result.DefaultSelection<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
/**
 * Model TransmissionType
 * 
 */
export type TransmissionType = $Result.DefaultSelection<Prisma.$TransmissionTypePayload>
/**
 * Model Color
 * 
 */
export type Color = $Result.DefaultSelection<Prisma.$ColorPayload>
/**
 * Model VehicleImage
 * 
 */
export type VehicleImage = $Result.DefaultSelection<Prisma.$VehicleImagePayload>
/**
 * Model VehicleOffer
 * 
 */
export type VehicleOffer = $Result.DefaultSelection<Prisma.$VehicleOfferPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more VehicleTypes
 * const vehicleTypes = await prisma.vehicleType.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more VehicleTypes
   * const vehicleTypes = await prisma.vehicleType.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.vehicleType`: Exposes CRUD operations for the **VehicleType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleTypes
    * const vehicleTypes = await prisma.vehicleType.findMany()
    * ```
    */
  get vehicleType(): Prisma.VehicleTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleYear`: Exposes CRUD operations for the **VehicleYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleYears
    * const vehicleYears = await prisma.vehicleYear.findMany()
    * ```
    */
  get vehicleYear(): Prisma.VehicleYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearBrand`: Exposes CRUD operations for the **YearBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearBrands
    * const yearBrands = await prisma.yearBrand.findMany()
    * ```
    */
  get yearBrand(): Prisma.YearBrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearModel`: Exposes CRUD operations for the **YearModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearModels
    * const yearModels = await prisma.yearModel.findMany()
    * ```
    */
  get yearModel(): Prisma.YearModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearModelVersion`: Exposes CRUD operations for the **YearModelVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearModelVersions
    * const yearModelVersions = await prisma.yearModelVersion.findMany()
    * ```
    */
  get yearModelVersion(): Prisma.YearModelVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.version`: Exposes CRUD operations for the **Version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versions
    * const versions = await prisma.version.findMany()
    * ```
    */
  get version(): Prisma.VersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearModelVersionBodyType`: Exposes CRUD operations for the **YearModelVersionBodyType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearModelVersionBodyTypes
    * const yearModelVersionBodyTypes = await prisma.yearModelVersionBodyType.findMany()
    * ```
    */
  get yearModelVersionBodyType(): Prisma.YearModelVersionBodyTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bodyType`: Exposes CRUD operations for the **BodyType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BodyTypes
    * const bodyTypes = await prisma.bodyType.findMany()
    * ```
    */
  get bodyType(): Prisma.BodyTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearModelVersionBodyTypeFuel`: Exposes CRUD operations for the **YearModelVersionBodyTypeFuel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearModelVersionBodyTypeFuels
    * const yearModelVersionBodyTypeFuels = await prisma.yearModelVersionBodyTypeFuel.findMany()
    * ```
    */
  get yearModelVersionBodyTypeFuel(): Prisma.YearModelVersionBodyTypeFuelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fuelType`: Exposes CRUD operations for the **FuelType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FuelTypes
    * const fuelTypes = await prisma.fuelType.findMany()
    * ```
    */
  get fuelType(): Prisma.FuelTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.yearModelVersionBodyTypeFuelTransmission`: Exposes CRUD operations for the **YearModelVersionBodyTypeFuelTransmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more YearModelVersionBodyTypeFuelTransmissions
    * const yearModelVersionBodyTypeFuelTransmissions = await prisma.yearModelVersionBodyTypeFuelTransmission.findMany()
    * ```
    */
  get yearModelVersionBodyTypeFuelTransmission(): Prisma.YearModelVersionBodyTypeFuelTransmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transmissionType`: Exposes CRUD operations for the **TransmissionType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransmissionTypes
    * const transmissionTypes = await prisma.transmissionType.findMany()
    * ```
    */
  get transmissionType(): Prisma.TransmissionTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.color`: Exposes CRUD operations for the **Color** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Colors
    * const colors = await prisma.color.findMany()
    * ```
    */
  get color(): Prisma.ColorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleImage`: Exposes CRUD operations for the **VehicleImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleImages
    * const vehicleImages = await prisma.vehicleImage.findMany()
    * ```
    */
  get vehicleImage(): Prisma.VehicleImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleOffer`: Exposes CRUD operations for the **VehicleOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleOffers
    * const vehicleOffers = await prisma.vehicleOffer.findMany()
    * ```
    */
  get vehicleOffer(): Prisma.VehicleOfferDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    VehicleType: 'VehicleType',
    VehicleYear: 'VehicleYear',
    YearBrand: 'YearBrand',
    Brand: 'Brand',
    YearModel: 'YearModel',
    Model: 'Model',
    YearModelVersion: 'YearModelVersion',
    Version: 'Version',
    YearModelVersionBodyType: 'YearModelVersionBodyType',
    BodyType: 'BodyType',
    YearModelVersionBodyTypeFuel: 'YearModelVersionBodyTypeFuel',
    FuelType: 'FuelType',
    YearModelVersionBodyTypeFuelTransmission: 'YearModelVersionBodyTypeFuelTransmission',
    TransmissionType: 'TransmissionType',
    Color: 'Color',
    VehicleImage: 'VehicleImage',
    VehicleOffer: 'VehicleOffer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "vehicleType" | "vehicleYear" | "yearBrand" | "brand" | "yearModel" | "model" | "yearModelVersion" | "version" | "yearModelVersionBodyType" | "bodyType" | "yearModelVersionBodyTypeFuel" | "fuelType" | "yearModelVersionBodyTypeFuelTransmission" | "transmissionType" | "color" | "vehicleImage" | "vehicleOffer"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      VehicleType: {
        payload: Prisma.$VehicleTypePayload<ExtArgs>
        fields: Prisma.VehicleTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          findFirst: {
            args: Prisma.VehicleTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          findMany: {
            args: Prisma.VehicleTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>[]
          }
          create: {
            args: Prisma.VehicleTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          createMany: {
            args: Prisma.VehicleTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>[]
          }
          delete: {
            args: Prisma.VehicleTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          update: {
            args: Prisma.VehicleTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          deleteMany: {
            args: Prisma.VehicleTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>[]
          }
          upsert: {
            args: Prisma.VehicleTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleTypePayload>
          }
          aggregate: {
            args: Prisma.VehicleTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleType>
          }
          groupBy: {
            args: Prisma.VehicleTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleTypeCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleTypeCountAggregateOutputType> | number
          }
        }
      }
      VehicleYear: {
        payload: Prisma.$VehicleYearPayload<ExtArgs>
        fields: Prisma.VehicleYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>
          }
          findFirst: {
            args: Prisma.VehicleYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>
          }
          findMany: {
            args: Prisma.VehicleYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>[]
          }
          create: {
            args: Prisma.VehicleYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>
          }
          createMany: {
            args: Prisma.VehicleYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>[]
          }
          delete: {
            args: Prisma.VehicleYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>
          }
          update: {
            args: Prisma.VehicleYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>
          }
          deleteMany: {
            args: Prisma.VehicleYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>[]
          }
          upsert: {
            args: Prisma.VehicleYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleYearPayload>
          }
          aggregate: {
            args: Prisma.VehicleYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleYear>
          }
          groupBy: {
            args: Prisma.VehicleYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleYearCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleYearCountAggregateOutputType> | number
          }
        }
      }
      YearBrand: {
        payload: Prisma.$YearBrandPayload<ExtArgs>
        fields: Prisma.YearBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>
          }
          findFirst: {
            args: Prisma.YearBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>
          }
          findMany: {
            args: Prisma.YearBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>[]
          }
          create: {
            args: Prisma.YearBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>
          }
          createMany: {
            args: Prisma.YearBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>[]
          }
          delete: {
            args: Prisma.YearBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>
          }
          update: {
            args: Prisma.YearBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>
          }
          deleteMany: {
            args: Prisma.YearBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearBrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>[]
          }
          upsert: {
            args: Prisma.YearBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearBrandPayload>
          }
          aggregate: {
            args: Prisma.YearBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearBrand>
          }
          groupBy: {
            args: Prisma.YearBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearBrandCountArgs<ExtArgs>
            result: $Utils.Optional<YearBrandCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      YearModel: {
        payload: Prisma.$YearModelPayload<ExtArgs>
        fields: Prisma.YearModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>
          }
          findFirst: {
            args: Prisma.YearModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>
          }
          findMany: {
            args: Prisma.YearModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>[]
          }
          create: {
            args: Prisma.YearModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>
          }
          createMany: {
            args: Prisma.YearModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>[]
          }
          delete: {
            args: Prisma.YearModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>
          }
          update: {
            args: Prisma.YearModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>
          }
          deleteMany: {
            args: Prisma.YearModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>[]
          }
          upsert: {
            args: Prisma.YearModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelPayload>
          }
          aggregate: {
            args: Prisma.YearModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearModel>
          }
          groupBy: {
            args: Prisma.YearModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearModelCountArgs<ExtArgs>
            result: $Utils.Optional<YearModelCountAggregateOutputType> | number
          }
        }
      }
      Model: {
        payload: Prisma.$ModelPayload<ExtArgs>
        fields: Prisma.ModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findFirst: {
            args: Prisma.ModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          findMany: {
            args: Prisma.ModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          create: {
            args: Prisma.ModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          createMany: {
            args: Prisma.ModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          delete: {
            args: Prisma.ModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          update: {
            args: Prisma.ModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          deleteMany: {
            args: Prisma.ModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>[]
          }
          upsert: {
            args: Prisma.ModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPayload>
          }
          aggregate: {
            args: Prisma.ModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel>
          }
          groupBy: {
            args: Prisma.ModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelCountArgs<ExtArgs>
            result: $Utils.Optional<ModelCountAggregateOutputType> | number
          }
        }
      }
      YearModelVersion: {
        payload: Prisma.$YearModelVersionPayload<ExtArgs>
        fields: Prisma.YearModelVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearModelVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearModelVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>
          }
          findFirst: {
            args: Prisma.YearModelVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearModelVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>
          }
          findMany: {
            args: Prisma.YearModelVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>[]
          }
          create: {
            args: Prisma.YearModelVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>
          }
          createMany: {
            args: Prisma.YearModelVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearModelVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>[]
          }
          delete: {
            args: Prisma.YearModelVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>
          }
          update: {
            args: Prisma.YearModelVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>
          }
          deleteMany: {
            args: Prisma.YearModelVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearModelVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearModelVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>[]
          }
          upsert: {
            args: Prisma.YearModelVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionPayload>
          }
          aggregate: {
            args: Prisma.YearModelVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearModelVersion>
          }
          groupBy: {
            args: Prisma.YearModelVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearModelVersionCountArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionCountAggregateOutputType> | number
          }
        }
      }
      Version: {
        payload: Prisma.$VersionPayload<ExtArgs>
        fields: Prisma.VersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findFirst: {
            args: Prisma.VersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findMany: {
            args: Prisma.VersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          create: {
            args: Prisma.VersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          createMany: {
            args: Prisma.VersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          delete: {
            args: Prisma.VersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          update: {
            args: Prisma.VersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          deleteMany: {
            args: Prisma.VersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          upsert: {
            args: Prisma.VersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          aggregate: {
            args: Prisma.VersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersion>
          }
          groupBy: {
            args: Prisma.VersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VersionCountArgs<ExtArgs>
            result: $Utils.Optional<VersionCountAggregateOutputType> | number
          }
        }
      }
      YearModelVersionBodyType: {
        payload: Prisma.$YearModelVersionBodyTypePayload<ExtArgs>
        fields: Prisma.YearModelVersionBodyTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearModelVersionBodyTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearModelVersionBodyTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>
          }
          findFirst: {
            args: Prisma.YearModelVersionBodyTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearModelVersionBodyTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>
          }
          findMany: {
            args: Prisma.YearModelVersionBodyTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>[]
          }
          create: {
            args: Prisma.YearModelVersionBodyTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>
          }
          createMany: {
            args: Prisma.YearModelVersionBodyTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearModelVersionBodyTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>[]
          }
          delete: {
            args: Prisma.YearModelVersionBodyTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>
          }
          update: {
            args: Prisma.YearModelVersionBodyTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>
          }
          deleteMany: {
            args: Prisma.YearModelVersionBodyTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearModelVersionBodyTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearModelVersionBodyTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>[]
          }
          upsert: {
            args: Prisma.YearModelVersionBodyTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypePayload>
          }
          aggregate: {
            args: Prisma.YearModelVersionBodyTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearModelVersionBodyType>
          }
          groupBy: {
            args: Prisma.YearModelVersionBodyTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionBodyTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearModelVersionBodyTypeCountArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionBodyTypeCountAggregateOutputType> | number
          }
        }
      }
      BodyType: {
        payload: Prisma.$BodyTypePayload<ExtArgs>
        fields: Prisma.BodyTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BodyTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BodyTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>
          }
          findFirst: {
            args: Prisma.BodyTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BodyTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>
          }
          findMany: {
            args: Prisma.BodyTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>[]
          }
          create: {
            args: Prisma.BodyTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>
          }
          createMany: {
            args: Prisma.BodyTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BodyTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>[]
          }
          delete: {
            args: Prisma.BodyTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>
          }
          update: {
            args: Prisma.BodyTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>
          }
          deleteMany: {
            args: Prisma.BodyTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BodyTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BodyTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>[]
          }
          upsert: {
            args: Prisma.BodyTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BodyTypePayload>
          }
          aggregate: {
            args: Prisma.BodyTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBodyType>
          }
          groupBy: {
            args: Prisma.BodyTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BodyTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BodyTypeCountArgs<ExtArgs>
            result: $Utils.Optional<BodyTypeCountAggregateOutputType> | number
          }
        }
      }
      YearModelVersionBodyTypeFuel: {
        payload: Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>
        fields: Prisma.YearModelVersionBodyTypeFuelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearModelVersionBodyTypeFuelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearModelVersionBodyTypeFuelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>
          }
          findFirst: {
            args: Prisma.YearModelVersionBodyTypeFuelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearModelVersionBodyTypeFuelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>
          }
          findMany: {
            args: Prisma.YearModelVersionBodyTypeFuelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>[]
          }
          create: {
            args: Prisma.YearModelVersionBodyTypeFuelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>
          }
          createMany: {
            args: Prisma.YearModelVersionBodyTypeFuelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearModelVersionBodyTypeFuelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>[]
          }
          delete: {
            args: Prisma.YearModelVersionBodyTypeFuelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>
          }
          update: {
            args: Prisma.YearModelVersionBodyTypeFuelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>
          }
          deleteMany: {
            args: Prisma.YearModelVersionBodyTypeFuelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearModelVersionBodyTypeFuelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearModelVersionBodyTypeFuelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>[]
          }
          upsert: {
            args: Prisma.YearModelVersionBodyTypeFuelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelPayload>
          }
          aggregate: {
            args: Prisma.YearModelVersionBodyTypeFuelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearModelVersionBodyTypeFuel>
          }
          groupBy: {
            args: Prisma.YearModelVersionBodyTypeFuelGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionBodyTypeFuelGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearModelVersionBodyTypeFuelCountArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionBodyTypeFuelCountAggregateOutputType> | number
          }
        }
      }
      FuelType: {
        payload: Prisma.$FuelTypePayload<ExtArgs>
        fields: Prisma.FuelTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FuelTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FuelTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>
          }
          findFirst: {
            args: Prisma.FuelTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FuelTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>
          }
          findMany: {
            args: Prisma.FuelTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>[]
          }
          create: {
            args: Prisma.FuelTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>
          }
          createMany: {
            args: Prisma.FuelTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FuelTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>[]
          }
          delete: {
            args: Prisma.FuelTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>
          }
          update: {
            args: Prisma.FuelTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>
          }
          deleteMany: {
            args: Prisma.FuelTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FuelTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FuelTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>[]
          }
          upsert: {
            args: Prisma.FuelTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FuelTypePayload>
          }
          aggregate: {
            args: Prisma.FuelTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFuelType>
          }
          groupBy: {
            args: Prisma.FuelTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FuelTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FuelTypeCountArgs<ExtArgs>
            result: $Utils.Optional<FuelTypeCountAggregateOutputType> | number
          }
        }
      }
      YearModelVersionBodyTypeFuelTransmission: {
        payload: Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>
        fields: Prisma.YearModelVersionBodyTypeFuelTransmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
          }
          findFirst: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
          }
          findMany: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>[]
          }
          create: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
          }
          createMany: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>[]
          }
          delete: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
          }
          update: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
          }
          deleteMany: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>[]
          }
          upsert: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload>
          }
          aggregate: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateYearModelVersionBodyTypeFuelTransmission>
          }
          groupBy: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionBodyTypeFuelTransmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.YearModelVersionBodyTypeFuelTransmissionCountArgs<ExtArgs>
            result: $Utils.Optional<YearModelVersionBodyTypeFuelTransmissionCountAggregateOutputType> | number
          }
        }
      }
      TransmissionType: {
        payload: Prisma.$TransmissionTypePayload<ExtArgs>
        fields: Prisma.TransmissionTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransmissionTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransmissionTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>
          }
          findFirst: {
            args: Prisma.TransmissionTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransmissionTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>
          }
          findMany: {
            args: Prisma.TransmissionTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>[]
          }
          create: {
            args: Prisma.TransmissionTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>
          }
          createMany: {
            args: Prisma.TransmissionTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransmissionTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>[]
          }
          delete: {
            args: Prisma.TransmissionTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>
          }
          update: {
            args: Prisma.TransmissionTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>
          }
          deleteMany: {
            args: Prisma.TransmissionTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransmissionTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransmissionTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>[]
          }
          upsert: {
            args: Prisma.TransmissionTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransmissionTypePayload>
          }
          aggregate: {
            args: Prisma.TransmissionTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransmissionType>
          }
          groupBy: {
            args: Prisma.TransmissionTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransmissionTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransmissionTypeCountArgs<ExtArgs>
            result: $Utils.Optional<TransmissionTypeCountAggregateOutputType> | number
          }
        }
      }
      Color: {
        payload: Prisma.$ColorPayload<ExtArgs>
        fields: Prisma.ColorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ColorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ColorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          findFirst: {
            args: Prisma.ColorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ColorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          findMany: {
            args: Prisma.ColorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          create: {
            args: Prisma.ColorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          createMany: {
            args: Prisma.ColorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ColorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          delete: {
            args: Prisma.ColorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          update: {
            args: Prisma.ColorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          deleteMany: {
            args: Prisma.ColorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ColorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ColorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>[]
          }
          upsert: {
            args: Prisma.ColorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ColorPayload>
          }
          aggregate: {
            args: Prisma.ColorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateColor>
          }
          groupBy: {
            args: Prisma.ColorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ColorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ColorCountArgs<ExtArgs>
            result: $Utils.Optional<ColorCountAggregateOutputType> | number
          }
        }
      }
      VehicleImage: {
        payload: Prisma.$VehicleImagePayload<ExtArgs>
        fields: Prisma.VehicleImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          findFirst: {
            args: Prisma.VehicleImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          findMany: {
            args: Prisma.VehicleImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>[]
          }
          create: {
            args: Prisma.VehicleImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          createMany: {
            args: Prisma.VehicleImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>[]
          }
          delete: {
            args: Prisma.VehicleImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          update: {
            args: Prisma.VehicleImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          deleteMany: {
            args: Prisma.VehicleImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>[]
          }
          upsert: {
            args: Prisma.VehicleImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleImagePayload>
          }
          aggregate: {
            args: Prisma.VehicleImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleImage>
          }
          groupBy: {
            args: Prisma.VehicleImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleImageCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleImageCountAggregateOutputType> | number
          }
        }
      }
      VehicleOffer: {
        payload: Prisma.$VehicleOfferPayload<ExtArgs>
        fields: Prisma.VehicleOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>
          }
          findFirst: {
            args: Prisma.VehicleOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>
          }
          findMany: {
            args: Prisma.VehicleOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>[]
          }
          create: {
            args: Prisma.VehicleOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>
          }
          createMany: {
            args: Prisma.VehicleOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>[]
          }
          delete: {
            args: Prisma.VehicleOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>
          }
          update: {
            args: Prisma.VehicleOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>
          }
          deleteMany: {
            args: Prisma.VehicleOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>[]
          }
          upsert: {
            args: Prisma.VehicleOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleOfferPayload>
          }
          aggregate: {
            args: Prisma.VehicleOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleOffer>
          }
          groupBy: {
            args: Prisma.VehicleOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleOfferCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleOfferCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    vehicleType?: VehicleTypeOmit
    vehicleYear?: VehicleYearOmit
    yearBrand?: YearBrandOmit
    brand?: BrandOmit
    yearModel?: YearModelOmit
    model?: ModelOmit
    yearModelVersion?: YearModelVersionOmit
    version?: VersionOmit
    yearModelVersionBodyType?: YearModelVersionBodyTypeOmit
    bodyType?: BodyTypeOmit
    yearModelVersionBodyTypeFuel?: YearModelVersionBodyTypeFuelOmit
    fuelType?: FuelTypeOmit
    yearModelVersionBodyTypeFuelTransmission?: YearModelVersionBodyTypeFuelTransmissionOmit
    transmissionType?: TransmissionTypeOmit
    color?: ColorOmit
    vehicleImage?: VehicleImageOmit
    vehicleOffer?: VehicleOfferOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type VehicleTypeCountOutputType
   */

  export type VehicleTypeCountOutputType = {
    years: number
    vehicleOffers: number
  }

  export type VehicleTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    years?: boolean | VehicleTypeCountOutputTypeCountYearsArgs
    vehicleOffers?: boolean | VehicleTypeCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * VehicleTypeCountOutputType without action
   */
  export type VehicleTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleTypeCountOutputType
     */
    select?: VehicleTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleTypeCountOutputType without action
   */
  export type VehicleTypeCountOutputTypeCountYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleYearWhereInput
  }

  /**
   * VehicleTypeCountOutputType without action
   */
  export type VehicleTypeCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type VehicleYearCountOutputType
   */

  export type VehicleYearCountOutputType = {
    brands: number
    vehicleOffers: number
  }

  export type VehicleYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | VehicleYearCountOutputTypeCountBrandsArgs
    vehicleOffers?: boolean | VehicleYearCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * VehicleYearCountOutputType without action
   */
  export type VehicleYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYearCountOutputType
     */
    select?: VehicleYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleYearCountOutputType without action
   */
  export type VehicleYearCountOutputTypeCountBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearBrandWhereInput
  }

  /**
   * VehicleYearCountOutputType without action
   */
  export type VehicleYearCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type YearBrandCountOutputType
   */

  export type YearBrandCountOutputType = {
    models: number
  }

  export type YearBrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | YearBrandCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * YearBrandCountOutputType without action
   */
  export type YearBrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrandCountOutputType
     */
    select?: YearBrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearBrandCountOutputType without action
   */
  export type YearBrandCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    yearBrands: number
    vehicleOffers: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearBrands?: boolean | BrandCountOutputTypeCountYearBrandsArgs
    vehicleOffers?: boolean | BrandCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountYearBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearBrandWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type YearModelCountOutputType
   */

  export type YearModelCountOutputType = {
    versions: number
  }

  export type YearModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | YearModelCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * YearModelCountOutputType without action
   */
  export type YearModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelCountOutputType
     */
    select?: YearModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearModelCountOutputType without action
   */
  export type YearModelCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionWhereInput
  }


  /**
   * Count Type ModelCountOutputType
   */

  export type ModelCountOutputType = {
    yearModels: number
    vehicleOffers: number
  }

  export type ModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModels?: boolean | ModelCountOutputTypeCountYearModelsArgs
    vehicleOffers?: boolean | ModelCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountYearModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelWhereInput
  }

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type YearModelVersionCountOutputType
   */

  export type YearModelVersionCountOutputType = {
    bodyTypes: number
  }

  export type YearModelVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bodyTypes?: boolean | YearModelVersionCountOutputTypeCountBodyTypesArgs
  }

  // Custom InputTypes
  /**
   * YearModelVersionCountOutputType without action
   */
  export type YearModelVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionCountOutputType
     */
    select?: YearModelVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearModelVersionCountOutputType without action
   */
  export type YearModelVersionCountOutputTypeCountBodyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeWhereInput
  }


  /**
   * Count Type VersionCountOutputType
   */

  export type VersionCountOutputType = {
    yearModelVersions: number
    vehicleOffers: number
  }

  export type VersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersions?: boolean | VersionCountOutputTypeCountYearModelVersionsArgs
    vehicleOffers?: boolean | VersionCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionCountOutputType
     */
    select?: VersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountYearModelVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionWhereInput
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type YearModelVersionBodyTypeCountOutputType
   */

  export type YearModelVersionBodyTypeCountOutputType = {
    fuelTypes: number
  }

  export type YearModelVersionBodyTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fuelTypes?: boolean | YearModelVersionBodyTypeCountOutputTypeCountFuelTypesArgs
  }

  // Custom InputTypes
  /**
   * YearModelVersionBodyTypeCountOutputType without action
   */
  export type YearModelVersionBodyTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeCountOutputType
     */
    select?: YearModelVersionBodyTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyTypeCountOutputType without action
   */
  export type YearModelVersionBodyTypeCountOutputTypeCountFuelTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeFuelWhereInput
  }


  /**
   * Count Type BodyTypeCountOutputType
   */

  export type BodyTypeCountOutputType = {
    yearModelVersionBodyTypes: number
    vehicleOffers: number
  }

  export type BodyTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypes?: boolean | BodyTypeCountOutputTypeCountYearModelVersionBodyTypesArgs
    vehicleOffers?: boolean | BodyTypeCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * BodyTypeCountOutputType without action
   */
  export type BodyTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyTypeCountOutputType
     */
    select?: BodyTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BodyTypeCountOutputType without action
   */
  export type BodyTypeCountOutputTypeCountYearModelVersionBodyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeWhereInput
  }

  /**
   * BodyTypeCountOutputType without action
   */
  export type BodyTypeCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type YearModelVersionBodyTypeFuelCountOutputType
   */

  export type YearModelVersionBodyTypeFuelCountOutputType = {
    transmissionTypes: number
  }

  export type YearModelVersionBodyTypeFuelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transmissionTypes?: boolean | YearModelVersionBodyTypeFuelCountOutputTypeCountTransmissionTypesArgs
  }

  // Custom InputTypes
  /**
   * YearModelVersionBodyTypeFuelCountOutputType without action
   */
  export type YearModelVersionBodyTypeFuelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelCountOutputType
     */
    select?: YearModelVersionBodyTypeFuelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyTypeFuelCountOutputType without action
   */
  export type YearModelVersionBodyTypeFuelCountOutputTypeCountTransmissionTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
  }


  /**
   * Count Type FuelTypeCountOutputType
   */

  export type FuelTypeCountOutputType = {
    yearModelVersionBodyTypeFuels: number
    vehicleOffers: number
  }

  export type FuelTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuels?: boolean | FuelTypeCountOutputTypeCountYearModelVersionBodyTypeFuelsArgs
    vehicleOffers?: boolean | FuelTypeCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * FuelTypeCountOutputType without action
   */
  export type FuelTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelTypeCountOutputType
     */
    select?: FuelTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FuelTypeCountOutputType without action
   */
  export type FuelTypeCountOutputTypeCountYearModelVersionBodyTypeFuelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeFuelWhereInput
  }

  /**
   * FuelTypeCountOutputType without action
   */
  export type FuelTypeCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type TransmissionTypeCountOutputType
   */

  export type TransmissionTypeCountOutputType = {
    yearModelVersionBodyTypeFuelTransmissions: number
    vehicleOffers: number
  }

  export type TransmissionTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuelTransmissions?: boolean | TransmissionTypeCountOutputTypeCountYearModelVersionBodyTypeFuelTransmissionsArgs
    vehicleOffers?: boolean | TransmissionTypeCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * TransmissionTypeCountOutputType without action
   */
  export type TransmissionTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionTypeCountOutputType
     */
    select?: TransmissionTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransmissionTypeCountOutputType without action
   */
  export type TransmissionTypeCountOutputTypeCountYearModelVersionBodyTypeFuelTransmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
  }

  /**
   * TransmissionTypeCountOutputType without action
   */
  export type TransmissionTypeCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type ColorCountOutputType
   */

  export type ColorCountOutputType = {
    vehicleOffers: number
  }

  export type ColorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleOffers?: boolean | ColorCountOutputTypeCountVehicleOffersArgs
  }

  // Custom InputTypes
  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ColorCountOutputType
     */
    select?: ColorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ColorCountOutputType without action
   */
  export type ColorCountOutputTypeCountVehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
  }


  /**
   * Count Type VehicleOfferCountOutputType
   */

  export type VehicleOfferCountOutputType = {
    images: number
  }

  export type VehicleOfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VehicleOfferCountOutputTypeCountImagesArgs
  }

  // Custom InputTypes
  /**
   * VehicleOfferCountOutputType without action
   */
  export type VehicleOfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOfferCountOutputType
     */
    select?: VehicleOfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleOfferCountOutputType without action
   */
  export type VehicleOfferCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleImageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model VehicleType
   */

  export type AggregateVehicleType = {
    _count: VehicleTypeCountAggregateOutputType | null
    _avg: VehicleTypeAvgAggregateOutputType | null
    _sum: VehicleTypeSumAggregateOutputType | null
    _min: VehicleTypeMinAggregateOutputType | null
    _max: VehicleTypeMaxAggregateOutputType | null
  }

  export type VehicleTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type VehicleTypeSumAggregateOutputType = {
    id: number | null
  }

  export type VehicleTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleTypeAvgAggregateInputType = {
    id?: true
  }

  export type VehicleTypeSumAggregateInputType = {
    id?: true
  }

  export type VehicleTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleType to aggregate.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleTypes
    **/
    _count?: true | VehicleTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleTypeMaxAggregateInputType
  }

  export type GetVehicleTypeAggregateType<T extends VehicleTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleType[P]>
      : GetScalarType<T[P], AggregateVehicleType[P]>
  }




  export type VehicleTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleTypeWhereInput
    orderBy?: VehicleTypeOrderByWithAggregationInput | VehicleTypeOrderByWithAggregationInput[]
    by: VehicleTypeScalarFieldEnum[] | VehicleTypeScalarFieldEnum
    having?: VehicleTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleTypeCountAggregateInputType | true
    _avg?: VehicleTypeAvgAggregateInputType
    _sum?: VehicleTypeSumAggregateInputType
    _min?: VehicleTypeMinAggregateInputType
    _max?: VehicleTypeMaxAggregateInputType
  }

  export type VehicleTypeGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: VehicleTypeCountAggregateOutputType | null
    _avg: VehicleTypeAvgAggregateOutputType | null
    _sum: VehicleTypeSumAggregateOutputType | null
    _min: VehicleTypeMinAggregateOutputType | null
    _max: VehicleTypeMaxAggregateOutputType | null
  }

  type GetVehicleTypeGroupByPayload<T extends VehicleTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleTypeGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleTypeGroupByOutputType[P]>
        }
      >
    >


  export type VehicleTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    years?: boolean | VehicleType$yearsArgs<ExtArgs>
    vehicleOffers?: boolean | VehicleType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | VehicleTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleType"]>

  export type VehicleTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicleType"]>

  export type VehicleTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["vehicleType"]>

  export type VehicleTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicleType"]>
  export type VehicleTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    years?: boolean | VehicleType$yearsArgs<ExtArgs>
    vehicleOffers?: boolean | VehicleType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | VehicleTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VehicleTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehicleTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleType"
    objects: {
      years: Prisma.$VehicleYearPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicleType"]>
    composites: {}
  }

  type VehicleTypeGetPayload<S extends boolean | null | undefined | VehicleTypeDefaultArgs> = $Result.GetResult<Prisma.$VehicleTypePayload, S>

  type VehicleTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleTypeCountAggregateInputType | true
    }

  export interface VehicleTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleType'], meta: { name: 'VehicleType' } }
    /**
     * Find zero or one VehicleType that matches the filter.
     * @param {VehicleTypeFindUniqueArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleTypeFindUniqueArgs>(args: SelectSubset<T, VehicleTypeFindUniqueArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleTypeFindUniqueOrThrowArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeFindFirstArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleTypeFindFirstArgs>(args?: SelectSubset<T, VehicleTypeFindFirstArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeFindFirstOrThrowArgs} args - Arguments to find a VehicleType
     * @example
     * // Get one VehicleType
     * const vehicleType = await prisma.vehicleType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleTypes
     * const vehicleTypes = await prisma.vehicleType.findMany()
     * 
     * // Get first 10 VehicleTypes
     * const vehicleTypes = await prisma.vehicleType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleTypeWithIdOnly = await prisma.vehicleType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleTypeFindManyArgs>(args?: SelectSubset<T, VehicleTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleType.
     * @param {VehicleTypeCreateArgs} args - Arguments to create a VehicleType.
     * @example
     * // Create one VehicleType
     * const VehicleType = await prisma.vehicleType.create({
     *   data: {
     *     // ... data to create a VehicleType
     *   }
     * })
     * 
     */
    create<T extends VehicleTypeCreateArgs>(args: SelectSubset<T, VehicleTypeCreateArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleTypes.
     * @param {VehicleTypeCreateManyArgs} args - Arguments to create many VehicleTypes.
     * @example
     * // Create many VehicleTypes
     * const vehicleType = await prisma.vehicleType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleTypeCreateManyArgs>(args?: SelectSubset<T, VehicleTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleTypes and returns the data saved in the database.
     * @param {VehicleTypeCreateManyAndReturnArgs} args - Arguments to create many VehicleTypes.
     * @example
     * // Create many VehicleTypes
     * const vehicleType = await prisma.vehicleType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleTypes and only return the `id`
     * const vehicleTypeWithIdOnly = await prisma.vehicleType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleType.
     * @param {VehicleTypeDeleteArgs} args - Arguments to delete one VehicleType.
     * @example
     * // Delete one VehicleType
     * const VehicleType = await prisma.vehicleType.delete({
     *   where: {
     *     // ... filter to delete one VehicleType
     *   }
     * })
     * 
     */
    delete<T extends VehicleTypeDeleteArgs>(args: SelectSubset<T, VehicleTypeDeleteArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleType.
     * @param {VehicleTypeUpdateArgs} args - Arguments to update one VehicleType.
     * @example
     * // Update one VehicleType
     * const vehicleType = await prisma.vehicleType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleTypeUpdateArgs>(args: SelectSubset<T, VehicleTypeUpdateArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleTypes.
     * @param {VehicleTypeDeleteManyArgs} args - Arguments to filter VehicleTypes to delete.
     * @example
     * // Delete a few VehicleTypes
     * const { count } = await prisma.vehicleType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleTypeDeleteManyArgs>(args?: SelectSubset<T, VehicleTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleTypes
     * const vehicleType = await prisma.vehicleType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleTypeUpdateManyArgs>(args: SelectSubset<T, VehicleTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleTypes and returns the data updated in the database.
     * @param {VehicleTypeUpdateManyAndReturnArgs} args - Arguments to update many VehicleTypes.
     * @example
     * // Update many VehicleTypes
     * const vehicleType = await prisma.vehicleType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleTypes and only return the `id`
     * const vehicleTypeWithIdOnly = await prisma.vehicleType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleType.
     * @param {VehicleTypeUpsertArgs} args - Arguments to update or create a VehicleType.
     * @example
     * // Update or create a VehicleType
     * const vehicleType = await prisma.vehicleType.upsert({
     *   create: {
     *     // ... data to create a VehicleType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleType we want to update
     *   }
     * })
     */
    upsert<T extends VehicleTypeUpsertArgs>(args: SelectSubset<T, VehicleTypeUpsertArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeCountArgs} args - Arguments to filter VehicleTypes to count.
     * @example
     * // Count the number of VehicleTypes
     * const count = await prisma.vehicleType.count({
     *   where: {
     *     // ... the filter for the VehicleTypes we want to count
     *   }
     * })
    **/
    count<T extends VehicleTypeCountArgs>(
      args?: Subset<T, VehicleTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleTypeAggregateArgs>(args: Subset<T, VehicleTypeAggregateArgs>): Prisma.PrismaPromise<GetVehicleTypeAggregateType<T>>

    /**
     * Group by VehicleType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleTypeGroupByArgs['orderBy'] }
        : { orderBy?: VehicleTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleType model
   */
  readonly fields: VehicleTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    years<T extends VehicleType$yearsArgs<ExtArgs> = {}>(args?: Subset<T, VehicleType$yearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends VehicleType$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, VehicleType$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleType model
   */
  interface VehicleTypeFieldRefs {
    readonly id: FieldRef<"VehicleType", 'Int'>
    readonly name: FieldRef<"VehicleType", 'String'>
    readonly createdAt: FieldRef<"VehicleType", 'DateTime'>
    readonly updatedAt: FieldRef<"VehicleType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VehicleType findUnique
   */
  export type VehicleTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType findUniqueOrThrow
   */
  export type VehicleTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType findFirst
   */
  export type VehicleTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTypes.
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTypes.
     */
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * VehicleType findFirstOrThrow
   */
  export type VehicleTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleType to fetch.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleTypes.
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleTypes.
     */
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * VehicleType findMany
   */
  export type VehicleTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleTypes to fetch.
     */
    where?: VehicleTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleTypes to fetch.
     */
    orderBy?: VehicleTypeOrderByWithRelationInput | VehicleTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleTypes.
     */
    cursor?: VehicleTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleTypes.
     */
    skip?: number
    distinct?: VehicleTypeScalarFieldEnum | VehicleTypeScalarFieldEnum[]
  }

  /**
   * VehicleType create
   */
  export type VehicleTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleType.
     */
    data: XOR<VehicleTypeCreateInput, VehicleTypeUncheckedCreateInput>
  }

  /**
   * VehicleType createMany
   */
  export type VehicleTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleTypes.
     */
    data: VehicleTypeCreateManyInput | VehicleTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleType createManyAndReturn
   */
  export type VehicleTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleTypes.
     */
    data: VehicleTypeCreateManyInput | VehicleTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleType update
   */
  export type VehicleTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleType.
     */
    data: XOR<VehicleTypeUpdateInput, VehicleTypeUncheckedUpdateInput>
    /**
     * Choose, which VehicleType to update.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType updateMany
   */
  export type VehicleTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleTypes.
     */
    data: XOR<VehicleTypeUpdateManyMutationInput, VehicleTypeUncheckedUpdateManyInput>
    /**
     * Filter which VehicleTypes to update
     */
    where?: VehicleTypeWhereInput
    /**
     * Limit how many VehicleTypes to update.
     */
    limit?: number
  }

  /**
   * VehicleType updateManyAndReturn
   */
  export type VehicleTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * The data used to update VehicleTypes.
     */
    data: XOR<VehicleTypeUpdateManyMutationInput, VehicleTypeUncheckedUpdateManyInput>
    /**
     * Filter which VehicleTypes to update
     */
    where?: VehicleTypeWhereInput
    /**
     * Limit how many VehicleTypes to update.
     */
    limit?: number
  }

  /**
   * VehicleType upsert
   */
  export type VehicleTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleType to update in case it exists.
     */
    where: VehicleTypeWhereUniqueInput
    /**
     * In case the VehicleType found by the `where` argument doesn't exist, create a new VehicleType with this data.
     */
    create: XOR<VehicleTypeCreateInput, VehicleTypeUncheckedCreateInput>
    /**
     * In case the VehicleType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleTypeUpdateInput, VehicleTypeUncheckedUpdateInput>
  }

  /**
   * VehicleType delete
   */
  export type VehicleTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    /**
     * Filter which VehicleType to delete.
     */
    where: VehicleTypeWhereUniqueInput
  }

  /**
   * VehicleType deleteMany
   */
  export type VehicleTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleTypes to delete
     */
    where?: VehicleTypeWhereInput
    /**
     * Limit how many VehicleTypes to delete.
     */
    limit?: number
  }

  /**
   * VehicleType.years
   */
  export type VehicleType$yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    where?: VehicleYearWhereInput
    orderBy?: VehicleYearOrderByWithRelationInput | VehicleYearOrderByWithRelationInput[]
    cursor?: VehicleYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleYearScalarFieldEnum | VehicleYearScalarFieldEnum[]
  }

  /**
   * VehicleType.vehicleOffers
   */
  export type VehicleType$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * VehicleType without action
   */
  export type VehicleTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
  }


  /**
   * Model VehicleYear
   */

  export type AggregateVehicleYear = {
    _count: VehicleYearCountAggregateOutputType | null
    _avg: VehicleYearAvgAggregateOutputType | null
    _sum: VehicleYearSumAggregateOutputType | null
    _min: VehicleYearMinAggregateOutputType | null
    _max: VehicleYearMaxAggregateOutputType | null
  }

  export type VehicleYearAvgAggregateOutputType = {
    id: number | null
    year: number | null
    vehicleTypeId: number | null
  }

  export type VehicleYearSumAggregateOutputType = {
    id: number | null
    year: number | null
    vehicleTypeId: number | null
  }

  export type VehicleYearMinAggregateOutputType = {
    id: number | null
    year: number | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleTypeId: number | null
  }

  export type VehicleYearMaxAggregateOutputType = {
    id: number | null
    year: number | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleTypeId: number | null
  }

  export type VehicleYearCountAggregateOutputType = {
    id: number
    year: number
    createdAt: number
    updatedAt: number
    vehicleTypeId: number
    _all: number
  }


  export type VehicleYearAvgAggregateInputType = {
    id?: true
    year?: true
    vehicleTypeId?: true
  }

  export type VehicleYearSumAggregateInputType = {
    id?: true
    year?: true
    vehicleTypeId?: true
  }

  export type VehicleYearMinAggregateInputType = {
    id?: true
    year?: true
    createdAt?: true
    updatedAt?: true
    vehicleTypeId?: true
  }

  export type VehicleYearMaxAggregateInputType = {
    id?: true
    year?: true
    createdAt?: true
    updatedAt?: true
    vehicleTypeId?: true
  }

  export type VehicleYearCountAggregateInputType = {
    id?: true
    year?: true
    createdAt?: true
    updatedAt?: true
    vehicleTypeId?: true
    _all?: true
  }

  export type VehicleYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleYear to aggregate.
     */
    where?: VehicleYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleYears to fetch.
     */
    orderBy?: VehicleYearOrderByWithRelationInput | VehicleYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleYears
    **/
    _count?: true | VehicleYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleYearMaxAggregateInputType
  }

  export type GetVehicleYearAggregateType<T extends VehicleYearAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleYear[P]>
      : GetScalarType<T[P], AggregateVehicleYear[P]>
  }




  export type VehicleYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleYearWhereInput
    orderBy?: VehicleYearOrderByWithAggregationInput | VehicleYearOrderByWithAggregationInput[]
    by: VehicleYearScalarFieldEnum[] | VehicleYearScalarFieldEnum
    having?: VehicleYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleYearCountAggregateInputType | true
    _avg?: VehicleYearAvgAggregateInputType
    _sum?: VehicleYearSumAggregateInputType
    _min?: VehicleYearMinAggregateInputType
    _max?: VehicleYearMaxAggregateInputType
  }

  export type VehicleYearGroupByOutputType = {
    id: number
    year: number
    createdAt: Date
    updatedAt: Date
    vehicleTypeId: number
    _count: VehicleYearCountAggregateOutputType | null
    _avg: VehicleYearAvgAggregateOutputType | null
    _sum: VehicleYearSumAggregateOutputType | null
    _min: VehicleYearMinAggregateOutputType | null
    _max: VehicleYearMaxAggregateOutputType | null
  }

  type GetVehicleYearGroupByPayload<T extends VehicleYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleYearGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleYearGroupByOutputType[P]>
        }
      >
    >


  export type VehicleYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleTypeId?: boolean
    vehicleType?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    brands?: boolean | VehicleYear$brandsArgs<ExtArgs>
    vehicleOffers?: boolean | VehicleYear$vehicleOffersArgs<ExtArgs>
    _count?: boolean | VehicleYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleYear"]>

  export type VehicleYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleTypeId?: boolean
    vehicleType?: boolean | VehicleTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleYear"]>

  export type VehicleYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleTypeId?: boolean
    vehicleType?: boolean | VehicleTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleYear"]>

  export type VehicleYearSelectScalar = {
    id?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleTypeId?: boolean
  }

  export type VehicleYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "createdAt" | "updatedAt" | "vehicleTypeId", ExtArgs["result"]["vehicleYear"]>
  export type VehicleYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleType?: boolean | VehicleTypeDefaultArgs<ExtArgs>
    brands?: boolean | VehicleYear$brandsArgs<ExtArgs>
    vehicleOffers?: boolean | VehicleYear$vehicleOffersArgs<ExtArgs>
    _count?: boolean | VehicleYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleType?: boolean | VehicleTypeDefaultArgs<ExtArgs>
  }
  export type VehicleYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleType?: boolean | VehicleTypeDefaultArgs<ExtArgs>
  }

  export type $VehicleYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleYear"
    objects: {
      vehicleType: Prisma.$VehicleTypePayload<ExtArgs>
      brands: Prisma.$YearBrandPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      year: number
      createdAt: Date
      updatedAt: Date
      vehicleTypeId: number
    }, ExtArgs["result"]["vehicleYear"]>
    composites: {}
  }

  type VehicleYearGetPayload<S extends boolean | null | undefined | VehicleYearDefaultArgs> = $Result.GetResult<Prisma.$VehicleYearPayload, S>

  type VehicleYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleYearCountAggregateInputType | true
    }

  export interface VehicleYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleYear'], meta: { name: 'VehicleYear' } }
    /**
     * Find zero or one VehicleYear that matches the filter.
     * @param {VehicleYearFindUniqueArgs} args - Arguments to find a VehicleYear
     * @example
     * // Get one VehicleYear
     * const vehicleYear = await prisma.vehicleYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleYearFindUniqueArgs>(args: SelectSubset<T, VehicleYearFindUniqueArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleYearFindUniqueOrThrowArgs} args - Arguments to find a VehicleYear
     * @example
     * // Get one VehicleYear
     * const vehicleYear = await prisma.vehicleYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleYearFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearFindFirstArgs} args - Arguments to find a VehicleYear
     * @example
     * // Get one VehicleYear
     * const vehicleYear = await prisma.vehicleYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleYearFindFirstArgs>(args?: SelectSubset<T, VehicleYearFindFirstArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearFindFirstOrThrowArgs} args - Arguments to find a VehicleYear
     * @example
     * // Get one VehicleYear
     * const vehicleYear = await prisma.vehicleYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleYearFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleYears
     * const vehicleYears = await prisma.vehicleYear.findMany()
     * 
     * // Get first 10 VehicleYears
     * const vehicleYears = await prisma.vehicleYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleYearWithIdOnly = await prisma.vehicleYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleYearFindManyArgs>(args?: SelectSubset<T, VehicleYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleYear.
     * @param {VehicleYearCreateArgs} args - Arguments to create a VehicleYear.
     * @example
     * // Create one VehicleYear
     * const VehicleYear = await prisma.vehicleYear.create({
     *   data: {
     *     // ... data to create a VehicleYear
     *   }
     * })
     * 
     */
    create<T extends VehicleYearCreateArgs>(args: SelectSubset<T, VehicleYearCreateArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleYears.
     * @param {VehicleYearCreateManyArgs} args - Arguments to create many VehicleYears.
     * @example
     * // Create many VehicleYears
     * const vehicleYear = await prisma.vehicleYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleYearCreateManyArgs>(args?: SelectSubset<T, VehicleYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleYears and returns the data saved in the database.
     * @param {VehicleYearCreateManyAndReturnArgs} args - Arguments to create many VehicleYears.
     * @example
     * // Create many VehicleYears
     * const vehicleYear = await prisma.vehicleYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleYears and only return the `id`
     * const vehicleYearWithIdOnly = await prisma.vehicleYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleYearCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleYear.
     * @param {VehicleYearDeleteArgs} args - Arguments to delete one VehicleYear.
     * @example
     * // Delete one VehicleYear
     * const VehicleYear = await prisma.vehicleYear.delete({
     *   where: {
     *     // ... filter to delete one VehicleYear
     *   }
     * })
     * 
     */
    delete<T extends VehicleYearDeleteArgs>(args: SelectSubset<T, VehicleYearDeleteArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleYear.
     * @param {VehicleYearUpdateArgs} args - Arguments to update one VehicleYear.
     * @example
     * // Update one VehicleYear
     * const vehicleYear = await prisma.vehicleYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleYearUpdateArgs>(args: SelectSubset<T, VehicleYearUpdateArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleYears.
     * @param {VehicleYearDeleteManyArgs} args - Arguments to filter VehicleYears to delete.
     * @example
     * // Delete a few VehicleYears
     * const { count } = await prisma.vehicleYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleYearDeleteManyArgs>(args?: SelectSubset<T, VehicleYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleYears
     * const vehicleYear = await prisma.vehicleYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleYearUpdateManyArgs>(args: SelectSubset<T, VehicleYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleYears and returns the data updated in the database.
     * @param {VehicleYearUpdateManyAndReturnArgs} args - Arguments to update many VehicleYears.
     * @example
     * // Update many VehicleYears
     * const vehicleYear = await prisma.vehicleYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleYears and only return the `id`
     * const vehicleYearWithIdOnly = await prisma.vehicleYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleYearUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleYear.
     * @param {VehicleYearUpsertArgs} args - Arguments to update or create a VehicleYear.
     * @example
     * // Update or create a VehicleYear
     * const vehicleYear = await prisma.vehicleYear.upsert({
     *   create: {
     *     // ... data to create a VehicleYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleYear we want to update
     *   }
     * })
     */
    upsert<T extends VehicleYearUpsertArgs>(args: SelectSubset<T, VehicleYearUpsertArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearCountArgs} args - Arguments to filter VehicleYears to count.
     * @example
     * // Count the number of VehicleYears
     * const count = await prisma.vehicleYear.count({
     *   where: {
     *     // ... the filter for the VehicleYears we want to count
     *   }
     * })
    **/
    count<T extends VehicleYearCountArgs>(
      args?: Subset<T, VehicleYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleYearAggregateArgs>(args: Subset<T, VehicleYearAggregateArgs>): Prisma.PrismaPromise<GetVehicleYearAggregateType<T>>

    /**
     * Group by VehicleYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleYearGroupByArgs['orderBy'] }
        : { orderBy?: VehicleYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleYear model
   */
  readonly fields: VehicleYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleType<T extends VehicleTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleTypeDefaultArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    brands<T extends VehicleYear$brandsArgs<ExtArgs> = {}>(args?: Subset<T, VehicleYear$brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends VehicleYear$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, VehicleYear$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleYear model
   */
  interface VehicleYearFieldRefs {
    readonly id: FieldRef<"VehicleYear", 'Int'>
    readonly year: FieldRef<"VehicleYear", 'Int'>
    readonly createdAt: FieldRef<"VehicleYear", 'DateTime'>
    readonly updatedAt: FieldRef<"VehicleYear", 'DateTime'>
    readonly vehicleTypeId: FieldRef<"VehicleYear", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VehicleYear findUnique
   */
  export type VehicleYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * Filter, which VehicleYear to fetch.
     */
    where: VehicleYearWhereUniqueInput
  }

  /**
   * VehicleYear findUniqueOrThrow
   */
  export type VehicleYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * Filter, which VehicleYear to fetch.
     */
    where: VehicleYearWhereUniqueInput
  }

  /**
   * VehicleYear findFirst
   */
  export type VehicleYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * Filter, which VehicleYear to fetch.
     */
    where?: VehicleYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleYears to fetch.
     */
    orderBy?: VehicleYearOrderByWithRelationInput | VehicleYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleYears.
     */
    cursor?: VehicleYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleYears.
     */
    distinct?: VehicleYearScalarFieldEnum | VehicleYearScalarFieldEnum[]
  }

  /**
   * VehicleYear findFirstOrThrow
   */
  export type VehicleYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * Filter, which VehicleYear to fetch.
     */
    where?: VehicleYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleYears to fetch.
     */
    orderBy?: VehicleYearOrderByWithRelationInput | VehicleYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleYears.
     */
    cursor?: VehicleYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleYears.
     */
    distinct?: VehicleYearScalarFieldEnum | VehicleYearScalarFieldEnum[]
  }

  /**
   * VehicleYear findMany
   */
  export type VehicleYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * Filter, which VehicleYears to fetch.
     */
    where?: VehicleYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleYears to fetch.
     */
    orderBy?: VehicleYearOrderByWithRelationInput | VehicleYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleYears.
     */
    cursor?: VehicleYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleYears.
     */
    skip?: number
    distinct?: VehicleYearScalarFieldEnum | VehicleYearScalarFieldEnum[]
  }

  /**
   * VehicleYear create
   */
  export type VehicleYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleYear.
     */
    data: XOR<VehicleYearCreateInput, VehicleYearUncheckedCreateInput>
  }

  /**
   * VehicleYear createMany
   */
  export type VehicleYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleYears.
     */
    data: VehicleYearCreateManyInput | VehicleYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleYear createManyAndReturn
   */
  export type VehicleYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleYears.
     */
    data: VehicleYearCreateManyInput | VehicleYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleYear update
   */
  export type VehicleYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleYear.
     */
    data: XOR<VehicleYearUpdateInput, VehicleYearUncheckedUpdateInput>
    /**
     * Choose, which VehicleYear to update.
     */
    where: VehicleYearWhereUniqueInput
  }

  /**
   * VehicleYear updateMany
   */
  export type VehicleYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleYears.
     */
    data: XOR<VehicleYearUpdateManyMutationInput, VehicleYearUncheckedUpdateManyInput>
    /**
     * Filter which VehicleYears to update
     */
    where?: VehicleYearWhereInput
    /**
     * Limit how many VehicleYears to update.
     */
    limit?: number
  }

  /**
   * VehicleYear updateManyAndReturn
   */
  export type VehicleYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * The data used to update VehicleYears.
     */
    data: XOR<VehicleYearUpdateManyMutationInput, VehicleYearUncheckedUpdateManyInput>
    /**
     * Filter which VehicleYears to update
     */
    where?: VehicleYearWhereInput
    /**
     * Limit how many VehicleYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleYear upsert
   */
  export type VehicleYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleYear to update in case it exists.
     */
    where: VehicleYearWhereUniqueInput
    /**
     * In case the VehicleYear found by the `where` argument doesn't exist, create a new VehicleYear with this data.
     */
    create: XOR<VehicleYearCreateInput, VehicleYearUncheckedCreateInput>
    /**
     * In case the VehicleYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleYearUpdateInput, VehicleYearUncheckedUpdateInput>
  }

  /**
   * VehicleYear delete
   */
  export type VehicleYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    /**
     * Filter which VehicleYear to delete.
     */
    where: VehicleYearWhereUniqueInput
  }

  /**
   * VehicleYear deleteMany
   */
  export type VehicleYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleYears to delete
     */
    where?: VehicleYearWhereInput
    /**
     * Limit how many VehicleYears to delete.
     */
    limit?: number
  }

  /**
   * VehicleYear.brands
   */
  export type VehicleYear$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    where?: YearBrandWhereInput
    orderBy?: YearBrandOrderByWithRelationInput | YearBrandOrderByWithRelationInput[]
    cursor?: YearBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearBrandScalarFieldEnum | YearBrandScalarFieldEnum[]
  }

  /**
   * VehicleYear.vehicleOffers
   */
  export type VehicleYear$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * VehicleYear without action
   */
  export type VehicleYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
  }


  /**
   * Model YearBrand
   */

  export type AggregateYearBrand = {
    _count: YearBrandCountAggregateOutputType | null
    _avg: YearBrandAvgAggregateOutputType | null
    _sum: YearBrandSumAggregateOutputType | null
    _min: YearBrandMinAggregateOutputType | null
    _max: YearBrandMaxAggregateOutputType | null
  }

  export type YearBrandAvgAggregateOutputType = {
    id: number | null
    yearId: number | null
    brandId: number | null
  }

  export type YearBrandSumAggregateOutputType = {
    id: number | null
    yearId: number | null
    brandId: number | null
  }

  export type YearBrandMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearId: number | null
    brandId: number | null
  }

  export type YearBrandMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearId: number | null
    brandId: number | null
  }

  export type YearBrandCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    yearId: number
    brandId: number
    _all: number
  }


  export type YearBrandAvgAggregateInputType = {
    id?: true
    yearId?: true
    brandId?: true
  }

  export type YearBrandSumAggregateInputType = {
    id?: true
    yearId?: true
    brandId?: true
  }

  export type YearBrandMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearId?: true
    brandId?: true
  }

  export type YearBrandMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearId?: true
    brandId?: true
  }

  export type YearBrandCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearId?: true
    brandId?: true
    _all?: true
  }

  export type YearBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearBrand to aggregate.
     */
    where?: YearBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearBrands to fetch.
     */
    orderBy?: YearBrandOrderByWithRelationInput | YearBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearBrands
    **/
    _count?: true | YearBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearBrandMaxAggregateInputType
  }

  export type GetYearBrandAggregateType<T extends YearBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateYearBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearBrand[P]>
      : GetScalarType<T[P], AggregateYearBrand[P]>
  }




  export type YearBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearBrandWhereInput
    orderBy?: YearBrandOrderByWithAggregationInput | YearBrandOrderByWithAggregationInput[]
    by: YearBrandScalarFieldEnum[] | YearBrandScalarFieldEnum
    having?: YearBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearBrandCountAggregateInputType | true
    _avg?: YearBrandAvgAggregateInputType
    _sum?: YearBrandSumAggregateInputType
    _min?: YearBrandMinAggregateInputType
    _max?: YearBrandMaxAggregateInputType
  }

  export type YearBrandGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    yearId: number
    brandId: number
    _count: YearBrandCountAggregateOutputType | null
    _avg: YearBrandAvgAggregateOutputType | null
    _sum: YearBrandSumAggregateOutputType | null
    _min: YearBrandMinAggregateOutputType | null
    _max: YearBrandMaxAggregateOutputType | null
  }

  type GetYearBrandGroupByPayload<T extends YearBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearBrandGroupByOutputType[P]>
            : GetScalarType<T[P], YearBrandGroupByOutputType[P]>
        }
      >
    >


  export type YearBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearId?: boolean
    brandId?: boolean
    vehicleYear?: boolean | VehicleYearDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    models?: boolean | YearBrand$modelsArgs<ExtArgs>
    _count?: boolean | YearBrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearBrand"]>

  export type YearBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearId?: boolean
    brandId?: boolean
    vehicleYear?: boolean | VehicleYearDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearBrand"]>

  export type YearBrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearId?: boolean
    brandId?: boolean
    vehicleYear?: boolean | VehicleYearDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearBrand"]>

  export type YearBrandSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearId?: boolean
    brandId?: boolean
  }

  export type YearBrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "yearId" | "brandId", ExtArgs["result"]["yearBrand"]>
  export type YearBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleYear?: boolean | VehicleYearDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    models?: boolean | YearBrand$modelsArgs<ExtArgs>
    _count?: boolean | YearBrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearBrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleYear?: boolean | VehicleYearDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type YearBrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleYear?: boolean | VehicleYearDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $YearBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearBrand"
    objects: {
      vehicleYear: Prisma.$VehicleYearPayload<ExtArgs>
      brand: Prisma.$BrandPayload<ExtArgs>
      models: Prisma.$YearModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      yearId: number
      brandId: number
    }, ExtArgs["result"]["yearBrand"]>
    composites: {}
  }

  type YearBrandGetPayload<S extends boolean | null | undefined | YearBrandDefaultArgs> = $Result.GetResult<Prisma.$YearBrandPayload, S>

  type YearBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearBrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearBrandCountAggregateInputType | true
    }

  export interface YearBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearBrand'], meta: { name: 'YearBrand' } }
    /**
     * Find zero or one YearBrand that matches the filter.
     * @param {YearBrandFindUniqueArgs} args - Arguments to find a YearBrand
     * @example
     * // Get one YearBrand
     * const yearBrand = await prisma.yearBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearBrandFindUniqueArgs>(args: SelectSubset<T, YearBrandFindUniqueArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearBrand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearBrandFindUniqueOrThrowArgs} args - Arguments to find a YearBrand
     * @example
     * // Get one YearBrand
     * const yearBrand = await prisma.yearBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, YearBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandFindFirstArgs} args - Arguments to find a YearBrand
     * @example
     * // Get one YearBrand
     * const yearBrand = await prisma.yearBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearBrandFindFirstArgs>(args?: SelectSubset<T, YearBrandFindFirstArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandFindFirstOrThrowArgs} args - Arguments to find a YearBrand
     * @example
     * // Get one YearBrand
     * const yearBrand = await prisma.yearBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, YearBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearBrands
     * const yearBrands = await prisma.yearBrand.findMany()
     * 
     * // Get first 10 YearBrands
     * const yearBrands = await prisma.yearBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearBrandWithIdOnly = await prisma.yearBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearBrandFindManyArgs>(args?: SelectSubset<T, YearBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearBrand.
     * @param {YearBrandCreateArgs} args - Arguments to create a YearBrand.
     * @example
     * // Create one YearBrand
     * const YearBrand = await prisma.yearBrand.create({
     *   data: {
     *     // ... data to create a YearBrand
     *   }
     * })
     * 
     */
    create<T extends YearBrandCreateArgs>(args: SelectSubset<T, YearBrandCreateArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearBrands.
     * @param {YearBrandCreateManyArgs} args - Arguments to create many YearBrands.
     * @example
     * // Create many YearBrands
     * const yearBrand = await prisma.yearBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearBrandCreateManyArgs>(args?: SelectSubset<T, YearBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearBrands and returns the data saved in the database.
     * @param {YearBrandCreateManyAndReturnArgs} args - Arguments to create many YearBrands.
     * @example
     * // Create many YearBrands
     * const yearBrand = await prisma.yearBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearBrands and only return the `id`
     * const yearBrandWithIdOnly = await prisma.yearBrand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, YearBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearBrand.
     * @param {YearBrandDeleteArgs} args - Arguments to delete one YearBrand.
     * @example
     * // Delete one YearBrand
     * const YearBrand = await prisma.yearBrand.delete({
     *   where: {
     *     // ... filter to delete one YearBrand
     *   }
     * })
     * 
     */
    delete<T extends YearBrandDeleteArgs>(args: SelectSubset<T, YearBrandDeleteArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearBrand.
     * @param {YearBrandUpdateArgs} args - Arguments to update one YearBrand.
     * @example
     * // Update one YearBrand
     * const yearBrand = await prisma.yearBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearBrandUpdateArgs>(args: SelectSubset<T, YearBrandUpdateArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearBrands.
     * @param {YearBrandDeleteManyArgs} args - Arguments to filter YearBrands to delete.
     * @example
     * // Delete a few YearBrands
     * const { count } = await prisma.yearBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearBrandDeleteManyArgs>(args?: SelectSubset<T, YearBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearBrands
     * const yearBrand = await prisma.yearBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearBrandUpdateManyArgs>(args: SelectSubset<T, YearBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearBrands and returns the data updated in the database.
     * @param {YearBrandUpdateManyAndReturnArgs} args - Arguments to update many YearBrands.
     * @example
     * // Update many YearBrands
     * const yearBrand = await prisma.yearBrand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearBrands and only return the `id`
     * const yearBrandWithIdOnly = await prisma.yearBrand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearBrandUpdateManyAndReturnArgs>(args: SelectSubset<T, YearBrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearBrand.
     * @param {YearBrandUpsertArgs} args - Arguments to update or create a YearBrand.
     * @example
     * // Update or create a YearBrand
     * const yearBrand = await prisma.yearBrand.upsert({
     *   create: {
     *     // ... data to create a YearBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearBrand we want to update
     *   }
     * })
     */
    upsert<T extends YearBrandUpsertArgs>(args: SelectSubset<T, YearBrandUpsertArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandCountArgs} args - Arguments to filter YearBrands to count.
     * @example
     * // Count the number of YearBrands
     * const count = await prisma.yearBrand.count({
     *   where: {
     *     // ... the filter for the YearBrands we want to count
     *   }
     * })
    **/
    count<T extends YearBrandCountArgs>(
      args?: Subset<T, YearBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearBrandAggregateArgs>(args: Subset<T, YearBrandAggregateArgs>): Prisma.PrismaPromise<GetYearBrandAggregateType<T>>

    /**
     * Group by YearBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearBrandGroupByArgs['orderBy'] }
        : { orderBy?: YearBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearBrand model
   */
  readonly fields: YearBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleYear<T extends VehicleYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleYearDefaultArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    models<T extends YearBrand$modelsArgs<ExtArgs> = {}>(args?: Subset<T, YearBrand$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearBrand model
   */
  interface YearBrandFieldRefs {
    readonly id: FieldRef<"YearBrand", 'Int'>
    readonly createdAt: FieldRef<"YearBrand", 'DateTime'>
    readonly updatedAt: FieldRef<"YearBrand", 'DateTime'>
    readonly yearId: FieldRef<"YearBrand", 'Int'>
    readonly brandId: FieldRef<"YearBrand", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearBrand findUnique
   */
  export type YearBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * Filter, which YearBrand to fetch.
     */
    where: YearBrandWhereUniqueInput
  }

  /**
   * YearBrand findUniqueOrThrow
   */
  export type YearBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * Filter, which YearBrand to fetch.
     */
    where: YearBrandWhereUniqueInput
  }

  /**
   * YearBrand findFirst
   */
  export type YearBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * Filter, which YearBrand to fetch.
     */
    where?: YearBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearBrands to fetch.
     */
    orderBy?: YearBrandOrderByWithRelationInput | YearBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearBrands.
     */
    cursor?: YearBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearBrands.
     */
    distinct?: YearBrandScalarFieldEnum | YearBrandScalarFieldEnum[]
  }

  /**
   * YearBrand findFirstOrThrow
   */
  export type YearBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * Filter, which YearBrand to fetch.
     */
    where?: YearBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearBrands to fetch.
     */
    orderBy?: YearBrandOrderByWithRelationInput | YearBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearBrands.
     */
    cursor?: YearBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearBrands.
     */
    distinct?: YearBrandScalarFieldEnum | YearBrandScalarFieldEnum[]
  }

  /**
   * YearBrand findMany
   */
  export type YearBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * Filter, which YearBrands to fetch.
     */
    where?: YearBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearBrands to fetch.
     */
    orderBy?: YearBrandOrderByWithRelationInput | YearBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearBrands.
     */
    cursor?: YearBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearBrands.
     */
    skip?: number
    distinct?: YearBrandScalarFieldEnum | YearBrandScalarFieldEnum[]
  }

  /**
   * YearBrand create
   */
  export type YearBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a YearBrand.
     */
    data: XOR<YearBrandCreateInput, YearBrandUncheckedCreateInput>
  }

  /**
   * YearBrand createMany
   */
  export type YearBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearBrands.
     */
    data: YearBrandCreateManyInput | YearBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearBrand createManyAndReturn
   */
  export type YearBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * The data used to create many YearBrands.
     */
    data: YearBrandCreateManyInput | YearBrandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearBrand update
   */
  export type YearBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a YearBrand.
     */
    data: XOR<YearBrandUpdateInput, YearBrandUncheckedUpdateInput>
    /**
     * Choose, which YearBrand to update.
     */
    where: YearBrandWhereUniqueInput
  }

  /**
   * YearBrand updateMany
   */
  export type YearBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearBrands.
     */
    data: XOR<YearBrandUpdateManyMutationInput, YearBrandUncheckedUpdateManyInput>
    /**
     * Filter which YearBrands to update
     */
    where?: YearBrandWhereInput
    /**
     * Limit how many YearBrands to update.
     */
    limit?: number
  }

  /**
   * YearBrand updateManyAndReturn
   */
  export type YearBrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * The data used to update YearBrands.
     */
    data: XOR<YearBrandUpdateManyMutationInput, YearBrandUncheckedUpdateManyInput>
    /**
     * Filter which YearBrands to update
     */
    where?: YearBrandWhereInput
    /**
     * Limit how many YearBrands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearBrand upsert
   */
  export type YearBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the YearBrand to update in case it exists.
     */
    where: YearBrandWhereUniqueInput
    /**
     * In case the YearBrand found by the `where` argument doesn't exist, create a new YearBrand with this data.
     */
    create: XOR<YearBrandCreateInput, YearBrandUncheckedCreateInput>
    /**
     * In case the YearBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearBrandUpdateInput, YearBrandUncheckedUpdateInput>
  }

  /**
   * YearBrand delete
   */
  export type YearBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    /**
     * Filter which YearBrand to delete.
     */
    where: YearBrandWhereUniqueInput
  }

  /**
   * YearBrand deleteMany
   */
  export type YearBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearBrands to delete
     */
    where?: YearBrandWhereInput
    /**
     * Limit how many YearBrands to delete.
     */
    limit?: number
  }

  /**
   * YearBrand.models
   */
  export type YearBrand$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    where?: YearModelWhereInput
    orderBy?: YearModelOrderByWithRelationInput | YearModelOrderByWithRelationInput[]
    cursor?: YearModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelScalarFieldEnum | YearModelScalarFieldEnum[]
  }

  /**
   * YearBrand without action
   */
  export type YearBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandSumAggregateOutputType = {
    id: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    id?: true
  }

  export type BrandSumAggregateInputType = {
    id?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearBrands?: boolean | Brand$yearBrandsArgs<ExtArgs>
    vehicleOffers?: boolean | Brand$vehicleOffersArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearBrands?: boolean | Brand$yearBrandsArgs<ExtArgs>
    vehicleOffers?: boolean | Brand$vehicleOffersArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      yearBrands: Prisma.$YearBrandPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearBrands<T extends Brand$yearBrandsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$yearBrandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends Brand$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, Brand$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'Int'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.yearBrands
   */
  export type Brand$yearBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearBrand
     */
    select?: YearBrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearBrand
     */
    omit?: YearBrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearBrandInclude<ExtArgs> | null
    where?: YearBrandWhereInput
    orderBy?: YearBrandOrderByWithRelationInput | YearBrandOrderByWithRelationInput[]
    cursor?: YearBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearBrandScalarFieldEnum | YearBrandScalarFieldEnum[]
  }

  /**
   * Brand.vehicleOffers
   */
  export type Brand$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model YearModel
   */

  export type AggregateYearModel = {
    _count: YearModelCountAggregateOutputType | null
    _avg: YearModelAvgAggregateOutputType | null
    _sum: YearModelSumAggregateOutputType | null
    _min: YearModelMinAggregateOutputType | null
    _max: YearModelMaxAggregateOutputType | null
  }

  export type YearModelAvgAggregateOutputType = {
    id: number | null
    yearBrandId: number | null
    modelId: number | null
  }

  export type YearModelSumAggregateOutputType = {
    id: number | null
    yearBrandId: number | null
    modelId: number | null
  }

  export type YearModelMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearBrandId: number | null
    modelId: number | null
  }

  export type YearModelMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearBrandId: number | null
    modelId: number | null
  }

  export type YearModelCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    yearBrandId: number
    modelId: number
    _all: number
  }


  export type YearModelAvgAggregateInputType = {
    id?: true
    yearBrandId?: true
    modelId?: true
  }

  export type YearModelSumAggregateInputType = {
    id?: true
    yearBrandId?: true
    modelId?: true
  }

  export type YearModelMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearBrandId?: true
    modelId?: true
  }

  export type YearModelMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearBrandId?: true
    modelId?: true
  }

  export type YearModelCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearBrandId?: true
    modelId?: true
    _all?: true
  }

  export type YearModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModel to aggregate.
     */
    where?: YearModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModels to fetch.
     */
    orderBy?: YearModelOrderByWithRelationInput | YearModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearModels
    **/
    _count?: true | YearModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearModelMaxAggregateInputType
  }

  export type GetYearModelAggregateType<T extends YearModelAggregateArgs> = {
        [P in keyof T & keyof AggregateYearModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearModel[P]>
      : GetScalarType<T[P], AggregateYearModel[P]>
  }




  export type YearModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelWhereInput
    orderBy?: YearModelOrderByWithAggregationInput | YearModelOrderByWithAggregationInput[]
    by: YearModelScalarFieldEnum[] | YearModelScalarFieldEnum
    having?: YearModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearModelCountAggregateInputType | true
    _avg?: YearModelAvgAggregateInputType
    _sum?: YearModelSumAggregateInputType
    _min?: YearModelMinAggregateInputType
    _max?: YearModelMaxAggregateInputType
  }

  export type YearModelGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    yearBrandId: number
    modelId: number
    _count: YearModelCountAggregateOutputType | null
    _avg: YearModelAvgAggregateOutputType | null
    _sum: YearModelSumAggregateOutputType | null
    _min: YearModelMinAggregateOutputType | null
    _max: YearModelMaxAggregateOutputType | null
  }

  type GetYearModelGroupByPayload<T extends YearModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearModelGroupByOutputType[P]>
            : GetScalarType<T[P], YearModelGroupByOutputType[P]>
        }
      >
    >


  export type YearModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearBrandId?: boolean
    modelId?: boolean
    yearBrand?: boolean | YearBrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    versions?: boolean | YearModel$versionsArgs<ExtArgs>
    _count?: boolean | YearModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModel"]>

  export type YearModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearBrandId?: boolean
    modelId?: boolean
    yearBrand?: boolean | YearBrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModel"]>

  export type YearModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearBrandId?: boolean
    modelId?: boolean
    yearBrand?: boolean | YearBrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModel"]>

  export type YearModelSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearBrandId?: boolean
    modelId?: boolean
  }

  export type YearModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "yearBrandId" | "modelId", ExtArgs["result"]["yearModel"]>
  export type YearModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearBrand?: boolean | YearBrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
    versions?: boolean | YearModel$versionsArgs<ExtArgs>
    _count?: boolean | YearModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearBrand?: boolean | YearBrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }
  export type YearModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearBrand?: boolean | YearBrandDefaultArgs<ExtArgs>
    model?: boolean | ModelDefaultArgs<ExtArgs>
  }

  export type $YearModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearModel"
    objects: {
      yearBrand: Prisma.$YearBrandPayload<ExtArgs>
      model: Prisma.$ModelPayload<ExtArgs>
      versions: Prisma.$YearModelVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      yearBrandId: number
      modelId: number
    }, ExtArgs["result"]["yearModel"]>
    composites: {}
  }

  type YearModelGetPayload<S extends boolean | null | undefined | YearModelDefaultArgs> = $Result.GetResult<Prisma.$YearModelPayload, S>

  type YearModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearModelCountAggregateInputType | true
    }

  export interface YearModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearModel'], meta: { name: 'YearModel' } }
    /**
     * Find zero or one YearModel that matches the filter.
     * @param {YearModelFindUniqueArgs} args - Arguments to find a YearModel
     * @example
     * // Get one YearModel
     * const yearModel = await prisma.yearModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearModelFindUniqueArgs>(args: SelectSubset<T, YearModelFindUniqueArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearModelFindUniqueOrThrowArgs} args - Arguments to find a YearModel
     * @example
     * // Get one YearModel
     * const yearModel = await prisma.yearModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearModelFindUniqueOrThrowArgs>(args: SelectSubset<T, YearModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelFindFirstArgs} args - Arguments to find a YearModel
     * @example
     * // Get one YearModel
     * const yearModel = await prisma.yearModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearModelFindFirstArgs>(args?: SelectSubset<T, YearModelFindFirstArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelFindFirstOrThrowArgs} args - Arguments to find a YearModel
     * @example
     * // Get one YearModel
     * const yearModel = await prisma.yearModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearModelFindFirstOrThrowArgs>(args?: SelectSubset<T, YearModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearModels
     * const yearModels = await prisma.yearModel.findMany()
     * 
     * // Get first 10 YearModels
     * const yearModels = await prisma.yearModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearModelWithIdOnly = await prisma.yearModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearModelFindManyArgs>(args?: SelectSubset<T, YearModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearModel.
     * @param {YearModelCreateArgs} args - Arguments to create a YearModel.
     * @example
     * // Create one YearModel
     * const YearModel = await prisma.yearModel.create({
     *   data: {
     *     // ... data to create a YearModel
     *   }
     * })
     * 
     */
    create<T extends YearModelCreateArgs>(args: SelectSubset<T, YearModelCreateArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearModels.
     * @param {YearModelCreateManyArgs} args - Arguments to create many YearModels.
     * @example
     * // Create many YearModels
     * const yearModel = await prisma.yearModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearModelCreateManyArgs>(args?: SelectSubset<T, YearModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearModels and returns the data saved in the database.
     * @param {YearModelCreateManyAndReturnArgs} args - Arguments to create many YearModels.
     * @example
     * // Create many YearModels
     * const yearModel = await prisma.yearModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearModels and only return the `id`
     * const yearModelWithIdOnly = await prisma.yearModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearModelCreateManyAndReturnArgs>(args?: SelectSubset<T, YearModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearModel.
     * @param {YearModelDeleteArgs} args - Arguments to delete one YearModel.
     * @example
     * // Delete one YearModel
     * const YearModel = await prisma.yearModel.delete({
     *   where: {
     *     // ... filter to delete one YearModel
     *   }
     * })
     * 
     */
    delete<T extends YearModelDeleteArgs>(args: SelectSubset<T, YearModelDeleteArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearModel.
     * @param {YearModelUpdateArgs} args - Arguments to update one YearModel.
     * @example
     * // Update one YearModel
     * const yearModel = await prisma.yearModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearModelUpdateArgs>(args: SelectSubset<T, YearModelUpdateArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearModels.
     * @param {YearModelDeleteManyArgs} args - Arguments to filter YearModels to delete.
     * @example
     * // Delete a few YearModels
     * const { count } = await prisma.yearModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearModelDeleteManyArgs>(args?: SelectSubset<T, YearModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearModels
     * const yearModel = await prisma.yearModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearModelUpdateManyArgs>(args: SelectSubset<T, YearModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModels and returns the data updated in the database.
     * @param {YearModelUpdateManyAndReturnArgs} args - Arguments to update many YearModels.
     * @example
     * // Update many YearModels
     * const yearModel = await prisma.yearModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearModels and only return the `id`
     * const yearModelWithIdOnly = await prisma.yearModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearModelUpdateManyAndReturnArgs>(args: SelectSubset<T, YearModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearModel.
     * @param {YearModelUpsertArgs} args - Arguments to update or create a YearModel.
     * @example
     * // Update or create a YearModel
     * const yearModel = await prisma.yearModel.upsert({
     *   create: {
     *     // ... data to create a YearModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearModel we want to update
     *   }
     * })
     */
    upsert<T extends YearModelUpsertArgs>(args: SelectSubset<T, YearModelUpsertArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelCountArgs} args - Arguments to filter YearModels to count.
     * @example
     * // Count the number of YearModels
     * const count = await prisma.yearModel.count({
     *   where: {
     *     // ... the filter for the YearModels we want to count
     *   }
     * })
    **/
    count<T extends YearModelCountArgs>(
      args?: Subset<T, YearModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearModelAggregateArgs>(args: Subset<T, YearModelAggregateArgs>): Prisma.PrismaPromise<GetYearModelAggregateType<T>>

    /**
     * Group by YearModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearModelGroupByArgs['orderBy'] }
        : { orderBy?: YearModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearModel model
   */
  readonly fields: YearModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearBrand<T extends YearBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearBrandDefaultArgs<ExtArgs>>): Prisma__YearBrandClient<$Result.GetResult<Prisma.$YearBrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    model<T extends ModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModelDefaultArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    versions<T extends YearModel$versionsArgs<ExtArgs> = {}>(args?: Subset<T, YearModel$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearModel model
   */
  interface YearModelFieldRefs {
    readonly id: FieldRef<"YearModel", 'Int'>
    readonly createdAt: FieldRef<"YearModel", 'DateTime'>
    readonly updatedAt: FieldRef<"YearModel", 'DateTime'>
    readonly yearBrandId: FieldRef<"YearModel", 'Int'>
    readonly modelId: FieldRef<"YearModel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearModel findUnique
   */
  export type YearModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * Filter, which YearModel to fetch.
     */
    where: YearModelWhereUniqueInput
  }

  /**
   * YearModel findUniqueOrThrow
   */
  export type YearModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * Filter, which YearModel to fetch.
     */
    where: YearModelWhereUniqueInput
  }

  /**
   * YearModel findFirst
   */
  export type YearModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * Filter, which YearModel to fetch.
     */
    where?: YearModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModels to fetch.
     */
    orderBy?: YearModelOrderByWithRelationInput | YearModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModels.
     */
    cursor?: YearModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModels.
     */
    distinct?: YearModelScalarFieldEnum | YearModelScalarFieldEnum[]
  }

  /**
   * YearModel findFirstOrThrow
   */
  export type YearModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * Filter, which YearModel to fetch.
     */
    where?: YearModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModels to fetch.
     */
    orderBy?: YearModelOrderByWithRelationInput | YearModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModels.
     */
    cursor?: YearModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModels.
     */
    distinct?: YearModelScalarFieldEnum | YearModelScalarFieldEnum[]
  }

  /**
   * YearModel findMany
   */
  export type YearModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * Filter, which YearModels to fetch.
     */
    where?: YearModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModels to fetch.
     */
    orderBy?: YearModelOrderByWithRelationInput | YearModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearModels.
     */
    cursor?: YearModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModels.
     */
    skip?: number
    distinct?: YearModelScalarFieldEnum | YearModelScalarFieldEnum[]
  }

  /**
   * YearModel create
   */
  export type YearModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * The data needed to create a YearModel.
     */
    data: XOR<YearModelCreateInput, YearModelUncheckedCreateInput>
  }

  /**
   * YearModel createMany
   */
  export type YearModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearModels.
     */
    data: YearModelCreateManyInput | YearModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearModel createManyAndReturn
   */
  export type YearModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * The data used to create many YearModels.
     */
    data: YearModelCreateManyInput | YearModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModel update
   */
  export type YearModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * The data needed to update a YearModel.
     */
    data: XOR<YearModelUpdateInput, YearModelUncheckedUpdateInput>
    /**
     * Choose, which YearModel to update.
     */
    where: YearModelWhereUniqueInput
  }

  /**
   * YearModel updateMany
   */
  export type YearModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearModels.
     */
    data: XOR<YearModelUpdateManyMutationInput, YearModelUncheckedUpdateManyInput>
    /**
     * Filter which YearModels to update
     */
    where?: YearModelWhereInput
    /**
     * Limit how many YearModels to update.
     */
    limit?: number
  }

  /**
   * YearModel updateManyAndReturn
   */
  export type YearModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * The data used to update YearModels.
     */
    data: XOR<YearModelUpdateManyMutationInput, YearModelUncheckedUpdateManyInput>
    /**
     * Filter which YearModels to update
     */
    where?: YearModelWhereInput
    /**
     * Limit how many YearModels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModel upsert
   */
  export type YearModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * The filter to search for the YearModel to update in case it exists.
     */
    where: YearModelWhereUniqueInput
    /**
     * In case the YearModel found by the `where` argument doesn't exist, create a new YearModel with this data.
     */
    create: XOR<YearModelCreateInput, YearModelUncheckedCreateInput>
    /**
     * In case the YearModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearModelUpdateInput, YearModelUncheckedUpdateInput>
  }

  /**
   * YearModel delete
   */
  export type YearModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    /**
     * Filter which YearModel to delete.
     */
    where: YearModelWhereUniqueInput
  }

  /**
   * YearModel deleteMany
   */
  export type YearModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModels to delete
     */
    where?: YearModelWhereInput
    /**
     * Limit how many YearModels to delete.
     */
    limit?: number
  }

  /**
   * YearModel.versions
   */
  export type YearModel$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    where?: YearModelVersionWhereInput
    orderBy?: YearModelVersionOrderByWithRelationInput | YearModelVersionOrderByWithRelationInput[]
    cursor?: YearModelVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionScalarFieldEnum | YearModelVersionScalarFieldEnum[]
  }

  /**
   * YearModel without action
   */
  export type YearModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
  }


  /**
   * Model Model
   */

  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelAvgAggregateOutputType = {
    id: number | null
  }

  export type ModelSumAggregateOutputType = {
    id: number | null
  }

  export type ModelMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelAvgAggregateInputType = {
    id?: true
  }

  export type ModelSumAggregateInputType = {
    id?: true
  }

  export type ModelMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelWhereInput
    orderBy?: ModelOrderByWithAggregationInput | ModelOrderByWithAggregationInput[]
    by: ModelScalarFieldEnum[] | ModelScalarFieldEnum
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _avg?: ModelAvgAggregateInputType
    _sum?: ModelSumAggregateInputType
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }

  export type ModelGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ModelCountAggregateOutputType | null
    _avg: ModelAvgAggregateOutputType | null
    _sum: ModelSumAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModels?: boolean | Model$yearModelsArgs<ExtArgs>
    vehicleOffers?: boolean | Model$vehicleOffersArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model"]>

  export type ModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["model"]>

  export type ModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["model"]>

  export type ModelSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["model"]>
  export type ModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModels?: boolean | Model$yearModelsArgs<ExtArgs>
    vehicleOffers?: boolean | Model$vehicleOffersArgs<ExtArgs>
    _count?: boolean | ModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Model"
    objects: {
      yearModels: Prisma.$YearModelPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["model"]>
    composites: {}
  }

  type ModelGetPayload<S extends boolean | null | undefined | ModelDefaultArgs> = $Result.GetResult<Prisma.$ModelPayload, S>

  type ModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Model'], meta: { name: 'Model' } }
    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelFindUniqueArgs>(args: SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelFindFirstArgs>(args?: SelectSubset<T, ModelFindFirstArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelFindManyArgs>(args?: SelectSubset<T, ModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
     */
    create<T extends ModelCreateArgs>(args: SelectSubset<T, ModelCreateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Models.
     * @param {ModelCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelCreateManyArgs>(args?: SelectSubset<T, ModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Models and returns the data saved in the database.
     * @param {ModelCreateManyAndReturnArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const model = await prisma.model.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
     */
    delete<T extends ModelDeleteArgs>(args: SelectSubset<T, ModelDeleteArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelUpdateArgs>(args: SelectSubset<T, ModelUpdateArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelDeleteManyArgs>(args?: SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelUpdateManyArgs>(args: SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models and returns the data updated in the database.
     * @param {ModelUpdateManyAndReturnArgs} args - Arguments to update many Models.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Models and only return the `id`
     * const modelWithIdOnly = await prisma.model.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
     */
    upsert<T extends ModelUpsertArgs>(args: SelectSubset<T, ModelUpsertArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Model model
   */
  readonly fields: ModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModels<T extends Model$yearModelsArgs<ExtArgs> = {}>(args?: Subset<T, Model$yearModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends Model$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, Model$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Model model
   */
  interface ModelFieldRefs {
    readonly id: FieldRef<"Model", 'Int'>
    readonly name: FieldRef<"Model", 'String'>
    readonly createdAt: FieldRef<"Model", 'DateTime'>
    readonly updatedAt: FieldRef<"Model", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Model findUnique
   */
  export type ModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findFirst
   */
  export type ModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model findMany
   */
  export type ModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: ModelOrderByWithRelationInput | ModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: ModelScalarFieldEnum | ModelScalarFieldEnum[]
  }

  /**
   * Model create
   */
  export type ModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }

  /**
   * Model createMany
   */
  export type ModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model createManyAndReturn
   */
  export type ModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * The data used to create many Models.
     */
    data: ModelCreateManyInput | ModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Model update
   */
  export type ModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
  }

  /**
   * Model updateManyAndReturn
   */
  export type ModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to update.
     */
    limit?: number
  }

  /**
   * Model upsert
   */
  export type ModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }

  /**
   * Model delete
   */
  export type ModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
    /**
     * Limit how many Models to delete.
     */
    limit?: number
  }

  /**
   * Model.yearModels
   */
  export type Model$yearModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModel
     */
    select?: YearModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModel
     */
    omit?: YearModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelInclude<ExtArgs> | null
    where?: YearModelWhereInput
    orderBy?: YearModelOrderByWithRelationInput | YearModelOrderByWithRelationInput[]
    cursor?: YearModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelScalarFieldEnum | YearModelScalarFieldEnum[]
  }

  /**
   * Model.vehicleOffers
   */
  export type Model$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * Model without action
   */
  export type ModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
  }


  /**
   * Model YearModelVersion
   */

  export type AggregateYearModelVersion = {
    _count: YearModelVersionCountAggregateOutputType | null
    _avg: YearModelVersionAvgAggregateOutputType | null
    _sum: YearModelVersionSumAggregateOutputType | null
    _min: YearModelVersionMinAggregateOutputType | null
    _max: YearModelVersionMaxAggregateOutputType | null
  }

  export type YearModelVersionAvgAggregateOutputType = {
    id: number | null
    yearModelId: number | null
    versionId: number | null
  }

  export type YearModelVersionSumAggregateOutputType = {
    id: number | null
    yearModelId: number | null
    versionId: number | null
  }

  export type YearModelVersionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelId: number | null
    versionId: number | null
  }

  export type YearModelVersionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelId: number | null
    versionId: number | null
  }

  export type YearModelVersionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    yearModelId: number
    versionId: number
    _all: number
  }


  export type YearModelVersionAvgAggregateInputType = {
    id?: true
    yearModelId?: true
    versionId?: true
  }

  export type YearModelVersionSumAggregateInputType = {
    id?: true
    yearModelId?: true
    versionId?: true
  }

  export type YearModelVersionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelId?: true
    versionId?: true
  }

  export type YearModelVersionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelId?: true
    versionId?: true
  }

  export type YearModelVersionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelId?: true
    versionId?: true
    _all?: true
  }

  export type YearModelVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersion to aggregate.
     */
    where?: YearModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersions to fetch.
     */
    orderBy?: YearModelVersionOrderByWithRelationInput | YearModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearModelVersions
    **/
    _count?: true | YearModelVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearModelVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearModelVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearModelVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearModelVersionMaxAggregateInputType
  }

  export type GetYearModelVersionAggregateType<T extends YearModelVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateYearModelVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearModelVersion[P]>
      : GetScalarType<T[P], AggregateYearModelVersion[P]>
  }




  export type YearModelVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionWhereInput
    orderBy?: YearModelVersionOrderByWithAggregationInput | YearModelVersionOrderByWithAggregationInput[]
    by: YearModelVersionScalarFieldEnum[] | YearModelVersionScalarFieldEnum
    having?: YearModelVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearModelVersionCountAggregateInputType | true
    _avg?: YearModelVersionAvgAggregateInputType
    _sum?: YearModelVersionSumAggregateInputType
    _min?: YearModelVersionMinAggregateInputType
    _max?: YearModelVersionMaxAggregateInputType
  }

  export type YearModelVersionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    yearModelId: number
    versionId: number
    _count: YearModelVersionCountAggregateOutputType | null
    _avg: YearModelVersionAvgAggregateOutputType | null
    _sum: YearModelVersionSumAggregateOutputType | null
    _min: YearModelVersionMinAggregateOutputType | null
    _max: YearModelVersionMaxAggregateOutputType | null
  }

  type GetYearModelVersionGroupByPayload<T extends YearModelVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearModelVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearModelVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearModelVersionGroupByOutputType[P]>
            : GetScalarType<T[P], YearModelVersionGroupByOutputType[P]>
        }
      >
    >


  export type YearModelVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelId?: boolean
    versionId?: boolean
    yearModel?: boolean | YearModelDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
    bodyTypes?: boolean | YearModelVersion$bodyTypesArgs<ExtArgs>
    _count?: boolean | YearModelVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersion"]>

  export type YearModelVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelId?: boolean
    versionId?: boolean
    yearModel?: boolean | YearModelDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersion"]>

  export type YearModelVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelId?: boolean
    versionId?: boolean
    yearModel?: boolean | YearModelDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersion"]>

  export type YearModelVersionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelId?: boolean
    versionId?: boolean
  }

  export type YearModelVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "yearModelId" | "versionId", ExtArgs["result"]["yearModelVersion"]>
  export type YearModelVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModel?: boolean | YearModelDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
    bodyTypes?: boolean | YearModelVersion$bodyTypesArgs<ExtArgs>
    _count?: boolean | YearModelVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModel?: boolean | YearModelDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }
  export type YearModelVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModel?: boolean | YearModelDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }

  export type $YearModelVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearModelVersion"
    objects: {
      yearModel: Prisma.$YearModelPayload<ExtArgs>
      version: Prisma.$VersionPayload<ExtArgs>
      bodyTypes: Prisma.$YearModelVersionBodyTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      yearModelId: number
      versionId: number
    }, ExtArgs["result"]["yearModelVersion"]>
    composites: {}
  }

  type YearModelVersionGetPayload<S extends boolean | null | undefined | YearModelVersionDefaultArgs> = $Result.GetResult<Prisma.$YearModelVersionPayload, S>

  type YearModelVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearModelVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearModelVersionCountAggregateInputType | true
    }

  export interface YearModelVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearModelVersion'], meta: { name: 'YearModelVersion' } }
    /**
     * Find zero or one YearModelVersion that matches the filter.
     * @param {YearModelVersionFindUniqueArgs} args - Arguments to find a YearModelVersion
     * @example
     * // Get one YearModelVersion
     * const yearModelVersion = await prisma.yearModelVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearModelVersionFindUniqueArgs>(args: SelectSubset<T, YearModelVersionFindUniqueArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearModelVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearModelVersionFindUniqueOrThrowArgs} args - Arguments to find a YearModelVersion
     * @example
     * // Get one YearModelVersion
     * const yearModelVersion = await prisma.yearModelVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearModelVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, YearModelVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionFindFirstArgs} args - Arguments to find a YearModelVersion
     * @example
     * // Get one YearModelVersion
     * const yearModelVersion = await prisma.yearModelVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearModelVersionFindFirstArgs>(args?: SelectSubset<T, YearModelVersionFindFirstArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionFindFirstOrThrowArgs} args - Arguments to find a YearModelVersion
     * @example
     * // Get one YearModelVersion
     * const yearModelVersion = await prisma.yearModelVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearModelVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, YearModelVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearModelVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearModelVersions
     * const yearModelVersions = await prisma.yearModelVersion.findMany()
     * 
     * // Get first 10 YearModelVersions
     * const yearModelVersions = await prisma.yearModelVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearModelVersionWithIdOnly = await prisma.yearModelVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearModelVersionFindManyArgs>(args?: SelectSubset<T, YearModelVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearModelVersion.
     * @param {YearModelVersionCreateArgs} args - Arguments to create a YearModelVersion.
     * @example
     * // Create one YearModelVersion
     * const YearModelVersion = await prisma.yearModelVersion.create({
     *   data: {
     *     // ... data to create a YearModelVersion
     *   }
     * })
     * 
     */
    create<T extends YearModelVersionCreateArgs>(args: SelectSubset<T, YearModelVersionCreateArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearModelVersions.
     * @param {YearModelVersionCreateManyArgs} args - Arguments to create many YearModelVersions.
     * @example
     * // Create many YearModelVersions
     * const yearModelVersion = await prisma.yearModelVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearModelVersionCreateManyArgs>(args?: SelectSubset<T, YearModelVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearModelVersions and returns the data saved in the database.
     * @param {YearModelVersionCreateManyAndReturnArgs} args - Arguments to create many YearModelVersions.
     * @example
     * // Create many YearModelVersions
     * const yearModelVersion = await prisma.yearModelVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearModelVersions and only return the `id`
     * const yearModelVersionWithIdOnly = await prisma.yearModelVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearModelVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, YearModelVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearModelVersion.
     * @param {YearModelVersionDeleteArgs} args - Arguments to delete one YearModelVersion.
     * @example
     * // Delete one YearModelVersion
     * const YearModelVersion = await prisma.yearModelVersion.delete({
     *   where: {
     *     // ... filter to delete one YearModelVersion
     *   }
     * })
     * 
     */
    delete<T extends YearModelVersionDeleteArgs>(args: SelectSubset<T, YearModelVersionDeleteArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearModelVersion.
     * @param {YearModelVersionUpdateArgs} args - Arguments to update one YearModelVersion.
     * @example
     * // Update one YearModelVersion
     * const yearModelVersion = await prisma.yearModelVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearModelVersionUpdateArgs>(args: SelectSubset<T, YearModelVersionUpdateArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearModelVersions.
     * @param {YearModelVersionDeleteManyArgs} args - Arguments to filter YearModelVersions to delete.
     * @example
     * // Delete a few YearModelVersions
     * const { count } = await prisma.yearModelVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearModelVersionDeleteManyArgs>(args?: SelectSubset<T, YearModelVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearModelVersions
     * const yearModelVersion = await prisma.yearModelVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearModelVersionUpdateManyArgs>(args: SelectSubset<T, YearModelVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersions and returns the data updated in the database.
     * @param {YearModelVersionUpdateManyAndReturnArgs} args - Arguments to update many YearModelVersions.
     * @example
     * // Update many YearModelVersions
     * const yearModelVersion = await prisma.yearModelVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearModelVersions and only return the `id`
     * const yearModelVersionWithIdOnly = await prisma.yearModelVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearModelVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, YearModelVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearModelVersion.
     * @param {YearModelVersionUpsertArgs} args - Arguments to update or create a YearModelVersion.
     * @example
     * // Update or create a YearModelVersion
     * const yearModelVersion = await prisma.yearModelVersion.upsert({
     *   create: {
     *     // ... data to create a YearModelVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearModelVersion we want to update
     *   }
     * })
     */
    upsert<T extends YearModelVersionUpsertArgs>(args: SelectSubset<T, YearModelVersionUpsertArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearModelVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionCountArgs} args - Arguments to filter YearModelVersions to count.
     * @example
     * // Count the number of YearModelVersions
     * const count = await prisma.yearModelVersion.count({
     *   where: {
     *     // ... the filter for the YearModelVersions we want to count
     *   }
     * })
    **/
    count<T extends YearModelVersionCountArgs>(
      args?: Subset<T, YearModelVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearModelVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearModelVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearModelVersionAggregateArgs>(args: Subset<T, YearModelVersionAggregateArgs>): Prisma.PrismaPromise<GetYearModelVersionAggregateType<T>>

    /**
     * Group by YearModelVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearModelVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearModelVersionGroupByArgs['orderBy'] }
        : { orderBy?: YearModelVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearModelVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearModelVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearModelVersion model
   */
  readonly fields: YearModelVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearModelVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearModelVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModel<T extends YearModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearModelDefaultArgs<ExtArgs>>): Prisma__YearModelClient<$Result.GetResult<Prisma.$YearModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    version<T extends VersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionDefaultArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bodyTypes<T extends YearModelVersion$bodyTypesArgs<ExtArgs> = {}>(args?: Subset<T, YearModelVersion$bodyTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearModelVersion model
   */
  interface YearModelVersionFieldRefs {
    readonly id: FieldRef<"YearModelVersion", 'Int'>
    readonly createdAt: FieldRef<"YearModelVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"YearModelVersion", 'DateTime'>
    readonly yearModelId: FieldRef<"YearModelVersion", 'Int'>
    readonly versionId: FieldRef<"YearModelVersion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearModelVersion findUnique
   */
  export type YearModelVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersion to fetch.
     */
    where: YearModelVersionWhereUniqueInput
  }

  /**
   * YearModelVersion findUniqueOrThrow
   */
  export type YearModelVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersion to fetch.
     */
    where: YearModelVersionWhereUniqueInput
  }

  /**
   * YearModelVersion findFirst
   */
  export type YearModelVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersion to fetch.
     */
    where?: YearModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersions to fetch.
     */
    orderBy?: YearModelVersionOrderByWithRelationInput | YearModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersions.
     */
    cursor?: YearModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersions.
     */
    distinct?: YearModelVersionScalarFieldEnum | YearModelVersionScalarFieldEnum[]
  }

  /**
   * YearModelVersion findFirstOrThrow
   */
  export type YearModelVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersion to fetch.
     */
    where?: YearModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersions to fetch.
     */
    orderBy?: YearModelVersionOrderByWithRelationInput | YearModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersions.
     */
    cursor?: YearModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersions.
     */
    distinct?: YearModelVersionScalarFieldEnum | YearModelVersionScalarFieldEnum[]
  }

  /**
   * YearModelVersion findMany
   */
  export type YearModelVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersions to fetch.
     */
    where?: YearModelVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersions to fetch.
     */
    orderBy?: YearModelVersionOrderByWithRelationInput | YearModelVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearModelVersions.
     */
    cursor?: YearModelVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersions.
     */
    skip?: number
    distinct?: YearModelVersionScalarFieldEnum | YearModelVersionScalarFieldEnum[]
  }

  /**
   * YearModelVersion create
   */
  export type YearModelVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a YearModelVersion.
     */
    data: XOR<YearModelVersionCreateInput, YearModelVersionUncheckedCreateInput>
  }

  /**
   * YearModelVersion createMany
   */
  export type YearModelVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearModelVersions.
     */
    data: YearModelVersionCreateManyInput | YearModelVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearModelVersion createManyAndReturn
   */
  export type YearModelVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * The data used to create many YearModelVersions.
     */
    data: YearModelVersionCreateManyInput | YearModelVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersion update
   */
  export type YearModelVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a YearModelVersion.
     */
    data: XOR<YearModelVersionUpdateInput, YearModelVersionUncheckedUpdateInput>
    /**
     * Choose, which YearModelVersion to update.
     */
    where: YearModelVersionWhereUniqueInput
  }

  /**
   * YearModelVersion updateMany
   */
  export type YearModelVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearModelVersions.
     */
    data: XOR<YearModelVersionUpdateManyMutationInput, YearModelVersionUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersions to update
     */
    where?: YearModelVersionWhereInput
    /**
     * Limit how many YearModelVersions to update.
     */
    limit?: number
  }

  /**
   * YearModelVersion updateManyAndReturn
   */
  export type YearModelVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * The data used to update YearModelVersions.
     */
    data: XOR<YearModelVersionUpdateManyMutationInput, YearModelVersionUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersions to update
     */
    where?: YearModelVersionWhereInput
    /**
     * Limit how many YearModelVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersion upsert
   */
  export type YearModelVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the YearModelVersion to update in case it exists.
     */
    where: YearModelVersionWhereUniqueInput
    /**
     * In case the YearModelVersion found by the `where` argument doesn't exist, create a new YearModelVersion with this data.
     */
    create: XOR<YearModelVersionCreateInput, YearModelVersionUncheckedCreateInput>
    /**
     * In case the YearModelVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearModelVersionUpdateInput, YearModelVersionUncheckedUpdateInput>
  }

  /**
   * YearModelVersion delete
   */
  export type YearModelVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    /**
     * Filter which YearModelVersion to delete.
     */
    where: YearModelVersionWhereUniqueInput
  }

  /**
   * YearModelVersion deleteMany
   */
  export type YearModelVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersions to delete
     */
    where?: YearModelVersionWhereInput
    /**
     * Limit how many YearModelVersions to delete.
     */
    limit?: number
  }

  /**
   * YearModelVersion.bodyTypes
   */
  export type YearModelVersion$bodyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    where?: YearModelVersionBodyTypeWhereInput
    orderBy?: YearModelVersionBodyTypeOrderByWithRelationInput | YearModelVersionBodyTypeOrderByWithRelationInput[]
    cursor?: YearModelVersionBodyTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionBodyTypeScalarFieldEnum | YearModelVersionBodyTypeScalarFieldEnum[]
  }

  /**
   * YearModelVersion without action
   */
  export type YearModelVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
  }


  /**
   * Model Version
   */

  export type AggregateVersion = {
    _count: VersionCountAggregateOutputType | null
    _avg: VersionAvgAggregateOutputType | null
    _sum: VersionSumAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  export type VersionAvgAggregateOutputType = {
    id: number | null
  }

  export type VersionSumAggregateOutputType = {
    id: number | null
  }

  export type VersionMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VersionAvgAggregateInputType = {
    id?: true
  }

  export type VersionSumAggregateInputType = {
    id?: true
  }

  export type VersionMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Version to aggregate.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Versions
    **/
    _count?: true | VersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionMaxAggregateInputType
  }

  export type GetVersionAggregateType<T extends VersionAggregateArgs> = {
        [P in keyof T & keyof AggregateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersion[P]>
      : GetScalarType<T[P], AggregateVersion[P]>
  }




  export type VersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithAggregationInput | VersionOrderByWithAggregationInput[]
    by: VersionScalarFieldEnum[] | VersionScalarFieldEnum
    having?: VersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionCountAggregateInputType | true
    _avg?: VersionAvgAggregateInputType
    _sum?: VersionSumAggregateInputType
    _min?: VersionMinAggregateInputType
    _max?: VersionMaxAggregateInputType
  }

  export type VersionGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: VersionCountAggregateOutputType | null
    _avg: VersionAvgAggregateOutputType | null
    _sum: VersionSumAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  type GetVersionGroupByPayload<T extends VersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupByOutputType[P]>
        }
      >
    >


  export type VersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersions?: boolean | Version$yearModelVersionsArgs<ExtArgs>
    vehicleOffers?: boolean | Version$vehicleOffersArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["version"]>

  export type VersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["version"]>

  export type VersionSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["version"]>
  export type VersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersions?: boolean | Version$yearModelVersionsArgs<ExtArgs>
    vehicleOffers?: boolean | Version$vehicleOffersArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Version"
    objects: {
      yearModelVersions: Prisma.$YearModelVersionPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["version"]>
    composites: {}
  }

  type VersionGetPayload<S extends boolean | null | undefined | VersionDefaultArgs> = $Result.GetResult<Prisma.$VersionPayload, S>

  type VersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionCountAggregateInputType | true
    }

  export interface VersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Version'], meta: { name: 'Version' } }
    /**
     * Find zero or one Version that matches the filter.
     * @param {VersionFindUniqueArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionFindUniqueArgs>(args: SelectSubset<T, VersionFindUniqueArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionFindUniqueOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionFindFirstArgs>(args?: SelectSubset<T, VersionFindFirstArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versions
     * const versions = await prisma.version.findMany()
     * 
     * // Get first 10 Versions
     * const versions = await prisma.version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionWithIdOnly = await prisma.version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionFindManyArgs>(args?: SelectSubset<T, VersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Version.
     * @param {VersionCreateArgs} args - Arguments to create a Version.
     * @example
     * // Create one Version
     * const Version = await prisma.version.create({
     *   data: {
     *     // ... data to create a Version
     *   }
     * })
     * 
     */
    create<T extends VersionCreateArgs>(args: SelectSubset<T, VersionCreateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Versions.
     * @param {VersionCreateManyArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionCreateManyArgs>(args?: SelectSubset<T, VersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Versions and returns the data saved in the database.
     * @param {VersionCreateManyAndReturnArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Versions and only return the `id`
     * const versionWithIdOnly = await prisma.version.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VersionCreateManyAndReturnArgs>(args?: SelectSubset<T, VersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Version.
     * @param {VersionDeleteArgs} args - Arguments to delete one Version.
     * @example
     * // Delete one Version
     * const Version = await prisma.version.delete({
     *   where: {
     *     // ... filter to delete one Version
     *   }
     * })
     * 
     */
    delete<T extends VersionDeleteArgs>(args: SelectSubset<T, VersionDeleteArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Version.
     * @param {VersionUpdateArgs} args - Arguments to update one Version.
     * @example
     * // Update one Version
     * const version = await prisma.version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionUpdateArgs>(args: SelectSubset<T, VersionUpdateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Versions.
     * @param {VersionDeleteManyArgs} args - Arguments to filter Versions to delete.
     * @example
     * // Delete a few Versions
     * const { count } = await prisma.version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionDeleteManyArgs>(args?: SelectSubset<T, VersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionUpdateManyArgs>(args: SelectSubset<T, VersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions and returns the data updated in the database.
     * @param {VersionUpdateManyAndReturnArgs} args - Arguments to update many Versions.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Versions and only return the `id`
     * const versionWithIdOnly = await prisma.version.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VersionUpdateManyAndReturnArgs>(args: SelectSubset<T, VersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Version.
     * @param {VersionUpsertArgs} args - Arguments to update or create a Version.
     * @example
     * // Update or create a Version
     * const version = await prisma.version.upsert({
     *   create: {
     *     // ... data to create a Version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Version we want to update
     *   }
     * })
     */
    upsert<T extends VersionUpsertArgs>(args: SelectSubset<T, VersionUpsertArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionCountArgs} args - Arguments to filter Versions to count.
     * @example
     * // Count the number of Versions
     * const count = await prisma.version.count({
     *   where: {
     *     // ... the filter for the Versions we want to count
     *   }
     * })
    **/
    count<T extends VersionCountArgs>(
      args?: Subset<T, VersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionAggregateArgs>(args: Subset<T, VersionAggregateArgs>): Prisma.PrismaPromise<GetVersionAggregateType<T>>

    /**
     * Group by Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Version model
   */
  readonly fields: VersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersions<T extends Version$yearModelVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Version$yearModelVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends Version$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, Version$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Version model
   */
  interface VersionFieldRefs {
    readonly id: FieldRef<"Version", 'Int'>
    readonly name: FieldRef<"Version", 'String'>
    readonly createdAt: FieldRef<"Version", 'DateTime'>
    readonly updatedAt: FieldRef<"Version", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Version findUnique
   */
  export type VersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findUniqueOrThrow
   */
  export type VersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findFirst
   */
  export type VersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findFirstOrThrow
   */
  export type VersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findMany
   */
  export type VersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Versions to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version create
   */
  export type VersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to create a Version.
     */
    data: XOR<VersionCreateInput, VersionUncheckedCreateInput>
  }

  /**
   * Version createMany
   */
  export type VersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Version createManyAndReturn
   */
  export type VersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Version update
   */
  export type VersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to update a Version.
     */
    data: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
    /**
     * Choose, which Version to update.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version updateMany
   */
  export type VersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
  }

  /**
   * Version updateManyAndReturn
   */
  export type VersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
  }

  /**
   * Version upsert
   */
  export type VersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The filter to search for the Version to update in case it exists.
     */
    where: VersionWhereUniqueInput
    /**
     * In case the Version found by the `where` argument doesn't exist, create a new Version with this data.
     */
    create: XOR<VersionCreateInput, VersionUncheckedCreateInput>
    /**
     * In case the Version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
  }

  /**
   * Version delete
   */
  export type VersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter which Version to delete.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version deleteMany
   */
  export type VersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Versions to delete
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to delete.
     */
    limit?: number
  }

  /**
   * Version.yearModelVersions
   */
  export type Version$yearModelVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersion
     */
    select?: YearModelVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersion
     */
    omit?: YearModelVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionInclude<ExtArgs> | null
    where?: YearModelVersionWhereInput
    orderBy?: YearModelVersionOrderByWithRelationInput | YearModelVersionOrderByWithRelationInput[]
    cursor?: YearModelVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionScalarFieldEnum | YearModelVersionScalarFieldEnum[]
  }

  /**
   * Version.vehicleOffers
   */
  export type Version$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * Version without action
   */
  export type VersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
  }


  /**
   * Model YearModelVersionBodyType
   */

  export type AggregateYearModelVersionBodyType = {
    _count: YearModelVersionBodyTypeCountAggregateOutputType | null
    _avg: YearModelVersionBodyTypeAvgAggregateOutputType | null
    _sum: YearModelVersionBodyTypeSumAggregateOutputType | null
    _min: YearModelVersionBodyTypeMinAggregateOutputType | null
    _max: YearModelVersionBodyTypeMaxAggregateOutputType | null
  }

  export type YearModelVersionBodyTypeAvgAggregateOutputType = {
    id: number | null
    yearModelVersionId: number | null
    bodyTypeId: number | null
  }

  export type YearModelVersionBodyTypeSumAggregateOutputType = {
    id: number | null
    yearModelVersionId: number | null
    bodyTypeId: number | null
  }

  export type YearModelVersionBodyTypeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelVersionId: number | null
    bodyTypeId: number | null
  }

  export type YearModelVersionBodyTypeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelVersionId: number | null
    bodyTypeId: number | null
  }

  export type YearModelVersionBodyTypeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    yearModelVersionId: number
    bodyTypeId: number
    _all: number
  }


  export type YearModelVersionBodyTypeAvgAggregateInputType = {
    id?: true
    yearModelVersionId?: true
    bodyTypeId?: true
  }

  export type YearModelVersionBodyTypeSumAggregateInputType = {
    id?: true
    yearModelVersionId?: true
    bodyTypeId?: true
  }

  export type YearModelVersionBodyTypeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionId?: true
    bodyTypeId?: true
  }

  export type YearModelVersionBodyTypeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionId?: true
    bodyTypeId?: true
  }

  export type YearModelVersionBodyTypeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionId?: true
    bodyTypeId?: true
    _all?: true
  }

  export type YearModelVersionBodyTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersionBodyType to aggregate.
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypes to fetch.
     */
    orderBy?: YearModelVersionBodyTypeOrderByWithRelationInput | YearModelVersionBodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearModelVersionBodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearModelVersionBodyTypes
    **/
    _count?: true | YearModelVersionBodyTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearModelVersionBodyTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearModelVersionBodyTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearModelVersionBodyTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearModelVersionBodyTypeMaxAggregateInputType
  }

  export type GetYearModelVersionBodyTypeAggregateType<T extends YearModelVersionBodyTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateYearModelVersionBodyType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearModelVersionBodyType[P]>
      : GetScalarType<T[P], AggregateYearModelVersionBodyType[P]>
  }




  export type YearModelVersionBodyTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeWhereInput
    orderBy?: YearModelVersionBodyTypeOrderByWithAggregationInput | YearModelVersionBodyTypeOrderByWithAggregationInput[]
    by: YearModelVersionBodyTypeScalarFieldEnum[] | YearModelVersionBodyTypeScalarFieldEnum
    having?: YearModelVersionBodyTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearModelVersionBodyTypeCountAggregateInputType | true
    _avg?: YearModelVersionBodyTypeAvgAggregateInputType
    _sum?: YearModelVersionBodyTypeSumAggregateInputType
    _min?: YearModelVersionBodyTypeMinAggregateInputType
    _max?: YearModelVersionBodyTypeMaxAggregateInputType
  }

  export type YearModelVersionBodyTypeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    yearModelVersionId: number
    bodyTypeId: number
    _count: YearModelVersionBodyTypeCountAggregateOutputType | null
    _avg: YearModelVersionBodyTypeAvgAggregateOutputType | null
    _sum: YearModelVersionBodyTypeSumAggregateOutputType | null
    _min: YearModelVersionBodyTypeMinAggregateOutputType | null
    _max: YearModelVersionBodyTypeMaxAggregateOutputType | null
  }

  type GetYearModelVersionBodyTypeGroupByPayload<T extends YearModelVersionBodyTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearModelVersionBodyTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearModelVersionBodyTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearModelVersionBodyTypeGroupByOutputType[P]>
            : GetScalarType<T[P], YearModelVersionBodyTypeGroupByOutputType[P]>
        }
      >
    >


  export type YearModelVersionBodyTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionId?: boolean
    bodyTypeId?: boolean
    yearModelVersion?: boolean | YearModelVersionDefaultArgs<ExtArgs>
    bodyType?: boolean | BodyTypeDefaultArgs<ExtArgs>
    fuelTypes?: boolean | YearModelVersionBodyType$fuelTypesArgs<ExtArgs>
    _count?: boolean | YearModelVersionBodyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyType"]>

  export type YearModelVersionBodyTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionId?: boolean
    bodyTypeId?: boolean
    yearModelVersion?: boolean | YearModelVersionDefaultArgs<ExtArgs>
    bodyType?: boolean | BodyTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyType"]>

  export type YearModelVersionBodyTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionId?: boolean
    bodyTypeId?: boolean
    yearModelVersion?: boolean | YearModelVersionDefaultArgs<ExtArgs>
    bodyType?: boolean | BodyTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyType"]>

  export type YearModelVersionBodyTypeSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionId?: boolean
    bodyTypeId?: boolean
  }

  export type YearModelVersionBodyTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "yearModelVersionId" | "bodyTypeId", ExtArgs["result"]["yearModelVersionBodyType"]>
  export type YearModelVersionBodyTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersion?: boolean | YearModelVersionDefaultArgs<ExtArgs>
    bodyType?: boolean | BodyTypeDefaultArgs<ExtArgs>
    fuelTypes?: boolean | YearModelVersionBodyType$fuelTypesArgs<ExtArgs>
    _count?: boolean | YearModelVersionBodyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionBodyTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersion?: boolean | YearModelVersionDefaultArgs<ExtArgs>
    bodyType?: boolean | BodyTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionBodyTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersion?: boolean | YearModelVersionDefaultArgs<ExtArgs>
    bodyType?: boolean | BodyTypeDefaultArgs<ExtArgs>
  }

  export type $YearModelVersionBodyTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearModelVersionBodyType"
    objects: {
      yearModelVersion: Prisma.$YearModelVersionPayload<ExtArgs>
      bodyType: Prisma.$BodyTypePayload<ExtArgs>
      fuelTypes: Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      yearModelVersionId: number
      bodyTypeId: number
    }, ExtArgs["result"]["yearModelVersionBodyType"]>
    composites: {}
  }

  type YearModelVersionBodyTypeGetPayload<S extends boolean | null | undefined | YearModelVersionBodyTypeDefaultArgs> = $Result.GetResult<Prisma.$YearModelVersionBodyTypePayload, S>

  type YearModelVersionBodyTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearModelVersionBodyTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearModelVersionBodyTypeCountAggregateInputType | true
    }

  export interface YearModelVersionBodyTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearModelVersionBodyType'], meta: { name: 'YearModelVersionBodyType' } }
    /**
     * Find zero or one YearModelVersionBodyType that matches the filter.
     * @param {YearModelVersionBodyTypeFindUniqueArgs} args - Arguments to find a YearModelVersionBodyType
     * @example
     * // Get one YearModelVersionBodyType
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearModelVersionBodyTypeFindUniqueArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFindUniqueArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearModelVersionBodyType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearModelVersionBodyTypeFindUniqueOrThrowArgs} args - Arguments to find a YearModelVersionBodyType
     * @example
     * // Get one YearModelVersionBodyType
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearModelVersionBodyTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersionBodyType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFindFirstArgs} args - Arguments to find a YearModelVersionBodyType
     * @example
     * // Get one YearModelVersionBodyType
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearModelVersionBodyTypeFindFirstArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFindFirstArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersionBodyType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFindFirstOrThrowArgs} args - Arguments to find a YearModelVersionBodyType
     * @example
     * // Get one YearModelVersionBodyType
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearModelVersionBodyTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearModelVersionBodyTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearModelVersionBodyTypes
     * const yearModelVersionBodyTypes = await prisma.yearModelVersionBodyType.findMany()
     * 
     * // Get first 10 YearModelVersionBodyTypes
     * const yearModelVersionBodyTypes = await prisma.yearModelVersionBodyType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearModelVersionBodyTypeWithIdOnly = await prisma.yearModelVersionBodyType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearModelVersionBodyTypeFindManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearModelVersionBodyType.
     * @param {YearModelVersionBodyTypeCreateArgs} args - Arguments to create a YearModelVersionBodyType.
     * @example
     * // Create one YearModelVersionBodyType
     * const YearModelVersionBodyType = await prisma.yearModelVersionBodyType.create({
     *   data: {
     *     // ... data to create a YearModelVersionBodyType
     *   }
     * })
     * 
     */
    create<T extends YearModelVersionBodyTypeCreateArgs>(args: SelectSubset<T, YearModelVersionBodyTypeCreateArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearModelVersionBodyTypes.
     * @param {YearModelVersionBodyTypeCreateManyArgs} args - Arguments to create many YearModelVersionBodyTypes.
     * @example
     * // Create many YearModelVersionBodyTypes
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearModelVersionBodyTypeCreateManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearModelVersionBodyTypes and returns the data saved in the database.
     * @param {YearModelVersionBodyTypeCreateManyAndReturnArgs} args - Arguments to create many YearModelVersionBodyTypes.
     * @example
     * // Create many YearModelVersionBodyTypes
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearModelVersionBodyTypes and only return the `id`
     * const yearModelVersionBodyTypeWithIdOnly = await prisma.yearModelVersionBodyType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearModelVersionBodyTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearModelVersionBodyType.
     * @param {YearModelVersionBodyTypeDeleteArgs} args - Arguments to delete one YearModelVersionBodyType.
     * @example
     * // Delete one YearModelVersionBodyType
     * const YearModelVersionBodyType = await prisma.yearModelVersionBodyType.delete({
     *   where: {
     *     // ... filter to delete one YearModelVersionBodyType
     *   }
     * })
     * 
     */
    delete<T extends YearModelVersionBodyTypeDeleteArgs>(args: SelectSubset<T, YearModelVersionBodyTypeDeleteArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearModelVersionBodyType.
     * @param {YearModelVersionBodyTypeUpdateArgs} args - Arguments to update one YearModelVersionBodyType.
     * @example
     * // Update one YearModelVersionBodyType
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearModelVersionBodyTypeUpdateArgs>(args: SelectSubset<T, YearModelVersionBodyTypeUpdateArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearModelVersionBodyTypes.
     * @param {YearModelVersionBodyTypeDeleteManyArgs} args - Arguments to filter YearModelVersionBodyTypes to delete.
     * @example
     * // Delete a few YearModelVersionBodyTypes
     * const { count } = await prisma.yearModelVersionBodyType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearModelVersionBodyTypeDeleteManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersionBodyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearModelVersionBodyTypes
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearModelVersionBodyTypeUpdateManyArgs>(args: SelectSubset<T, YearModelVersionBodyTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersionBodyTypes and returns the data updated in the database.
     * @param {YearModelVersionBodyTypeUpdateManyAndReturnArgs} args - Arguments to update many YearModelVersionBodyTypes.
     * @example
     * // Update many YearModelVersionBodyTypes
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearModelVersionBodyTypes and only return the `id`
     * const yearModelVersionBodyTypeWithIdOnly = await prisma.yearModelVersionBodyType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearModelVersionBodyTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, YearModelVersionBodyTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearModelVersionBodyType.
     * @param {YearModelVersionBodyTypeUpsertArgs} args - Arguments to update or create a YearModelVersionBodyType.
     * @example
     * // Update or create a YearModelVersionBodyType
     * const yearModelVersionBodyType = await prisma.yearModelVersionBodyType.upsert({
     *   create: {
     *     // ... data to create a YearModelVersionBodyType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearModelVersionBodyType we want to update
     *   }
     * })
     */
    upsert<T extends YearModelVersionBodyTypeUpsertArgs>(args: SelectSubset<T, YearModelVersionBodyTypeUpsertArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearModelVersionBodyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeCountArgs} args - Arguments to filter YearModelVersionBodyTypes to count.
     * @example
     * // Count the number of YearModelVersionBodyTypes
     * const count = await prisma.yearModelVersionBodyType.count({
     *   where: {
     *     // ... the filter for the YearModelVersionBodyTypes we want to count
     *   }
     * })
    **/
    count<T extends YearModelVersionBodyTypeCountArgs>(
      args?: Subset<T, YearModelVersionBodyTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearModelVersionBodyTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearModelVersionBodyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearModelVersionBodyTypeAggregateArgs>(args: Subset<T, YearModelVersionBodyTypeAggregateArgs>): Prisma.PrismaPromise<GetYearModelVersionBodyTypeAggregateType<T>>

    /**
     * Group by YearModelVersionBodyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearModelVersionBodyTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearModelVersionBodyTypeGroupByArgs['orderBy'] }
        : { orderBy?: YearModelVersionBodyTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearModelVersionBodyTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearModelVersionBodyTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearModelVersionBodyType model
   */
  readonly fields: YearModelVersionBodyTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearModelVersionBodyType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearModelVersionBodyTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersion<T extends YearModelVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearModelVersionDefaultArgs<ExtArgs>>): Prisma__YearModelVersionClient<$Result.GetResult<Prisma.$YearModelVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bodyType<T extends BodyTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BodyTypeDefaultArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fuelTypes<T extends YearModelVersionBodyType$fuelTypesArgs<ExtArgs> = {}>(args?: Subset<T, YearModelVersionBodyType$fuelTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearModelVersionBodyType model
   */
  interface YearModelVersionBodyTypeFieldRefs {
    readonly id: FieldRef<"YearModelVersionBodyType", 'Int'>
    readonly createdAt: FieldRef<"YearModelVersionBodyType", 'DateTime'>
    readonly updatedAt: FieldRef<"YearModelVersionBodyType", 'DateTime'>
    readonly yearModelVersionId: FieldRef<"YearModelVersionBodyType", 'Int'>
    readonly bodyTypeId: FieldRef<"YearModelVersionBodyType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearModelVersionBodyType findUnique
   */
  export type YearModelVersionBodyTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyType to fetch.
     */
    where: YearModelVersionBodyTypeWhereUniqueInput
  }

  /**
   * YearModelVersionBodyType findUniqueOrThrow
   */
  export type YearModelVersionBodyTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyType to fetch.
     */
    where: YearModelVersionBodyTypeWhereUniqueInput
  }

  /**
   * YearModelVersionBodyType findFirst
   */
  export type YearModelVersionBodyTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyType to fetch.
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypes to fetch.
     */
    orderBy?: YearModelVersionBodyTypeOrderByWithRelationInput | YearModelVersionBodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersionBodyTypes.
     */
    cursor?: YearModelVersionBodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersionBodyTypes.
     */
    distinct?: YearModelVersionBodyTypeScalarFieldEnum | YearModelVersionBodyTypeScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyType findFirstOrThrow
   */
  export type YearModelVersionBodyTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyType to fetch.
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypes to fetch.
     */
    orderBy?: YearModelVersionBodyTypeOrderByWithRelationInput | YearModelVersionBodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersionBodyTypes.
     */
    cursor?: YearModelVersionBodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersionBodyTypes.
     */
    distinct?: YearModelVersionBodyTypeScalarFieldEnum | YearModelVersionBodyTypeScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyType findMany
   */
  export type YearModelVersionBodyTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypes to fetch.
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypes to fetch.
     */
    orderBy?: YearModelVersionBodyTypeOrderByWithRelationInput | YearModelVersionBodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearModelVersionBodyTypes.
     */
    cursor?: YearModelVersionBodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypes.
     */
    skip?: number
    distinct?: YearModelVersionBodyTypeScalarFieldEnum | YearModelVersionBodyTypeScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyType create
   */
  export type YearModelVersionBodyTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a YearModelVersionBodyType.
     */
    data: XOR<YearModelVersionBodyTypeCreateInput, YearModelVersionBodyTypeUncheckedCreateInput>
  }

  /**
   * YearModelVersionBodyType createMany
   */
  export type YearModelVersionBodyTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearModelVersionBodyTypes.
     */
    data: YearModelVersionBodyTypeCreateManyInput | YearModelVersionBodyTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearModelVersionBodyType createManyAndReturn
   */
  export type YearModelVersionBodyTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * The data used to create many YearModelVersionBodyTypes.
     */
    data: YearModelVersionBodyTypeCreateManyInput | YearModelVersionBodyTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyType update
   */
  export type YearModelVersionBodyTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a YearModelVersionBodyType.
     */
    data: XOR<YearModelVersionBodyTypeUpdateInput, YearModelVersionBodyTypeUncheckedUpdateInput>
    /**
     * Choose, which YearModelVersionBodyType to update.
     */
    where: YearModelVersionBodyTypeWhereUniqueInput
  }

  /**
   * YearModelVersionBodyType updateMany
   */
  export type YearModelVersionBodyTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearModelVersionBodyTypes.
     */
    data: XOR<YearModelVersionBodyTypeUpdateManyMutationInput, YearModelVersionBodyTypeUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersionBodyTypes to update
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * Limit how many YearModelVersionBodyTypes to update.
     */
    limit?: number
  }

  /**
   * YearModelVersionBodyType updateManyAndReturn
   */
  export type YearModelVersionBodyTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * The data used to update YearModelVersionBodyTypes.
     */
    data: XOR<YearModelVersionBodyTypeUpdateManyMutationInput, YearModelVersionBodyTypeUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersionBodyTypes to update
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * Limit how many YearModelVersionBodyTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyType upsert
   */
  export type YearModelVersionBodyTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the YearModelVersionBodyType to update in case it exists.
     */
    where: YearModelVersionBodyTypeWhereUniqueInput
    /**
     * In case the YearModelVersionBodyType found by the `where` argument doesn't exist, create a new YearModelVersionBodyType with this data.
     */
    create: XOR<YearModelVersionBodyTypeCreateInput, YearModelVersionBodyTypeUncheckedCreateInput>
    /**
     * In case the YearModelVersionBodyType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearModelVersionBodyTypeUpdateInput, YearModelVersionBodyTypeUncheckedUpdateInput>
  }

  /**
   * YearModelVersionBodyType delete
   */
  export type YearModelVersionBodyTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    /**
     * Filter which YearModelVersionBodyType to delete.
     */
    where: YearModelVersionBodyTypeWhereUniqueInput
  }

  /**
   * YearModelVersionBodyType deleteMany
   */
  export type YearModelVersionBodyTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersionBodyTypes to delete
     */
    where?: YearModelVersionBodyTypeWhereInput
    /**
     * Limit how many YearModelVersionBodyTypes to delete.
     */
    limit?: number
  }

  /**
   * YearModelVersionBodyType.fuelTypes
   */
  export type YearModelVersionBodyType$fuelTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    where?: YearModelVersionBodyTypeFuelWhereInput
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithRelationInput | YearModelVersionBodyTypeFuelOrderByWithRelationInput[]
    cursor?: YearModelVersionBodyTypeFuelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionBodyTypeFuelScalarFieldEnum | YearModelVersionBodyTypeFuelScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyType without action
   */
  export type YearModelVersionBodyTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
  }


  /**
   * Model BodyType
   */

  export type AggregateBodyType = {
    _count: BodyTypeCountAggregateOutputType | null
    _avg: BodyTypeAvgAggregateOutputType | null
    _sum: BodyTypeSumAggregateOutputType | null
    _min: BodyTypeMinAggregateOutputType | null
    _max: BodyTypeMaxAggregateOutputType | null
  }

  export type BodyTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type BodyTypeSumAggregateOutputType = {
    id: number | null
  }

  export type BodyTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BodyTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BodyTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BodyTypeAvgAggregateInputType = {
    id?: true
  }

  export type BodyTypeSumAggregateInputType = {
    id?: true
  }

  export type BodyTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BodyTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BodyTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BodyTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyType to aggregate.
     */
    where?: BodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyTypes to fetch.
     */
    orderBy?: BodyTypeOrderByWithRelationInput | BodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BodyTypes
    **/
    _count?: true | BodyTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BodyTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BodyTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BodyTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BodyTypeMaxAggregateInputType
  }

  export type GetBodyTypeAggregateType<T extends BodyTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBodyType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBodyType[P]>
      : GetScalarType<T[P], AggregateBodyType[P]>
  }




  export type BodyTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BodyTypeWhereInput
    orderBy?: BodyTypeOrderByWithAggregationInput | BodyTypeOrderByWithAggregationInput[]
    by: BodyTypeScalarFieldEnum[] | BodyTypeScalarFieldEnum
    having?: BodyTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BodyTypeCountAggregateInputType | true
    _avg?: BodyTypeAvgAggregateInputType
    _sum?: BodyTypeSumAggregateInputType
    _min?: BodyTypeMinAggregateInputType
    _max?: BodyTypeMaxAggregateInputType
  }

  export type BodyTypeGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BodyTypeCountAggregateOutputType | null
    _avg: BodyTypeAvgAggregateOutputType | null
    _sum: BodyTypeSumAggregateOutputType | null
    _min: BodyTypeMinAggregateOutputType | null
    _max: BodyTypeMaxAggregateOutputType | null
  }

  type GetBodyTypeGroupByPayload<T extends BodyTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BodyTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BodyTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BodyTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BodyTypeGroupByOutputType[P]>
        }
      >
    >


  export type BodyTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypes?: boolean | BodyType$yearModelVersionBodyTypesArgs<ExtArgs>
    vehicleOffers?: boolean | BodyType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | BodyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bodyType"]>

  export type BodyTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bodyType"]>

  export type BodyTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bodyType"]>

  export type BodyTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BodyTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["bodyType"]>
  export type BodyTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypes?: boolean | BodyType$yearModelVersionBodyTypesArgs<ExtArgs>
    vehicleOffers?: boolean | BodyType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | BodyTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BodyTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BodyTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BodyTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BodyType"
    objects: {
      yearModelVersionBodyTypes: Prisma.$YearModelVersionBodyTypePayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bodyType"]>
    composites: {}
  }

  type BodyTypeGetPayload<S extends boolean | null | undefined | BodyTypeDefaultArgs> = $Result.GetResult<Prisma.$BodyTypePayload, S>

  type BodyTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BodyTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BodyTypeCountAggregateInputType | true
    }

  export interface BodyTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BodyType'], meta: { name: 'BodyType' } }
    /**
     * Find zero or one BodyType that matches the filter.
     * @param {BodyTypeFindUniqueArgs} args - Arguments to find a BodyType
     * @example
     * // Get one BodyType
     * const bodyType = await prisma.bodyType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BodyTypeFindUniqueArgs>(args: SelectSubset<T, BodyTypeFindUniqueArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BodyType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BodyTypeFindUniqueOrThrowArgs} args - Arguments to find a BodyType
     * @example
     * // Get one BodyType
     * const bodyType = await prisma.bodyType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BodyTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, BodyTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BodyType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeFindFirstArgs} args - Arguments to find a BodyType
     * @example
     * // Get one BodyType
     * const bodyType = await prisma.bodyType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BodyTypeFindFirstArgs>(args?: SelectSubset<T, BodyTypeFindFirstArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BodyType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeFindFirstOrThrowArgs} args - Arguments to find a BodyType
     * @example
     * // Get one BodyType
     * const bodyType = await prisma.bodyType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BodyTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, BodyTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BodyTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BodyTypes
     * const bodyTypes = await prisma.bodyType.findMany()
     * 
     * // Get first 10 BodyTypes
     * const bodyTypes = await prisma.bodyType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bodyTypeWithIdOnly = await prisma.bodyType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BodyTypeFindManyArgs>(args?: SelectSubset<T, BodyTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BodyType.
     * @param {BodyTypeCreateArgs} args - Arguments to create a BodyType.
     * @example
     * // Create one BodyType
     * const BodyType = await prisma.bodyType.create({
     *   data: {
     *     // ... data to create a BodyType
     *   }
     * })
     * 
     */
    create<T extends BodyTypeCreateArgs>(args: SelectSubset<T, BodyTypeCreateArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BodyTypes.
     * @param {BodyTypeCreateManyArgs} args - Arguments to create many BodyTypes.
     * @example
     * // Create many BodyTypes
     * const bodyType = await prisma.bodyType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BodyTypeCreateManyArgs>(args?: SelectSubset<T, BodyTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BodyTypes and returns the data saved in the database.
     * @param {BodyTypeCreateManyAndReturnArgs} args - Arguments to create many BodyTypes.
     * @example
     * // Create many BodyTypes
     * const bodyType = await prisma.bodyType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BodyTypes and only return the `id`
     * const bodyTypeWithIdOnly = await prisma.bodyType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BodyTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, BodyTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BodyType.
     * @param {BodyTypeDeleteArgs} args - Arguments to delete one BodyType.
     * @example
     * // Delete one BodyType
     * const BodyType = await prisma.bodyType.delete({
     *   where: {
     *     // ... filter to delete one BodyType
     *   }
     * })
     * 
     */
    delete<T extends BodyTypeDeleteArgs>(args: SelectSubset<T, BodyTypeDeleteArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BodyType.
     * @param {BodyTypeUpdateArgs} args - Arguments to update one BodyType.
     * @example
     * // Update one BodyType
     * const bodyType = await prisma.bodyType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BodyTypeUpdateArgs>(args: SelectSubset<T, BodyTypeUpdateArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BodyTypes.
     * @param {BodyTypeDeleteManyArgs} args - Arguments to filter BodyTypes to delete.
     * @example
     * // Delete a few BodyTypes
     * const { count } = await prisma.bodyType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BodyTypeDeleteManyArgs>(args?: SelectSubset<T, BodyTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BodyTypes
     * const bodyType = await prisma.bodyType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BodyTypeUpdateManyArgs>(args: SelectSubset<T, BodyTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BodyTypes and returns the data updated in the database.
     * @param {BodyTypeUpdateManyAndReturnArgs} args - Arguments to update many BodyTypes.
     * @example
     * // Update many BodyTypes
     * const bodyType = await prisma.bodyType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BodyTypes and only return the `id`
     * const bodyTypeWithIdOnly = await prisma.bodyType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BodyTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, BodyTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BodyType.
     * @param {BodyTypeUpsertArgs} args - Arguments to update or create a BodyType.
     * @example
     * // Update or create a BodyType
     * const bodyType = await prisma.bodyType.upsert({
     *   create: {
     *     // ... data to create a BodyType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BodyType we want to update
     *   }
     * })
     */
    upsert<T extends BodyTypeUpsertArgs>(args: SelectSubset<T, BodyTypeUpsertArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BodyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeCountArgs} args - Arguments to filter BodyTypes to count.
     * @example
     * // Count the number of BodyTypes
     * const count = await prisma.bodyType.count({
     *   where: {
     *     // ... the filter for the BodyTypes we want to count
     *   }
     * })
    **/
    count<T extends BodyTypeCountArgs>(
      args?: Subset<T, BodyTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BodyTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BodyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BodyTypeAggregateArgs>(args: Subset<T, BodyTypeAggregateArgs>): Prisma.PrismaPromise<GetBodyTypeAggregateType<T>>

    /**
     * Group by BodyType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BodyTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BodyTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BodyTypeGroupByArgs['orderBy'] }
        : { orderBy?: BodyTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BodyTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBodyTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BodyType model
   */
  readonly fields: BodyTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BodyType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BodyTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersionBodyTypes<T extends BodyType$yearModelVersionBodyTypesArgs<ExtArgs> = {}>(args?: Subset<T, BodyType$yearModelVersionBodyTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends BodyType$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, BodyType$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BodyType model
   */
  interface BodyTypeFieldRefs {
    readonly id: FieldRef<"BodyType", 'Int'>
    readonly name: FieldRef<"BodyType", 'String'>
    readonly createdAt: FieldRef<"BodyType", 'DateTime'>
    readonly updatedAt: FieldRef<"BodyType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BodyType findUnique
   */
  export type BodyTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which BodyType to fetch.
     */
    where: BodyTypeWhereUniqueInput
  }

  /**
   * BodyType findUniqueOrThrow
   */
  export type BodyTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which BodyType to fetch.
     */
    where: BodyTypeWhereUniqueInput
  }

  /**
   * BodyType findFirst
   */
  export type BodyTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which BodyType to fetch.
     */
    where?: BodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyTypes to fetch.
     */
    orderBy?: BodyTypeOrderByWithRelationInput | BodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyTypes.
     */
    cursor?: BodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyTypes.
     */
    distinct?: BodyTypeScalarFieldEnum | BodyTypeScalarFieldEnum[]
  }

  /**
   * BodyType findFirstOrThrow
   */
  export type BodyTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which BodyType to fetch.
     */
    where?: BodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyTypes to fetch.
     */
    orderBy?: BodyTypeOrderByWithRelationInput | BodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BodyTypes.
     */
    cursor?: BodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BodyTypes.
     */
    distinct?: BodyTypeScalarFieldEnum | BodyTypeScalarFieldEnum[]
  }

  /**
   * BodyType findMany
   */
  export type BodyTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * Filter, which BodyTypes to fetch.
     */
    where?: BodyTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BodyTypes to fetch.
     */
    orderBy?: BodyTypeOrderByWithRelationInput | BodyTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BodyTypes.
     */
    cursor?: BodyTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BodyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BodyTypes.
     */
    skip?: number
    distinct?: BodyTypeScalarFieldEnum | BodyTypeScalarFieldEnum[]
  }

  /**
   * BodyType create
   */
  export type BodyTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a BodyType.
     */
    data: XOR<BodyTypeCreateInput, BodyTypeUncheckedCreateInput>
  }

  /**
   * BodyType createMany
   */
  export type BodyTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BodyTypes.
     */
    data: BodyTypeCreateManyInput | BodyTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BodyType createManyAndReturn
   */
  export type BodyTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * The data used to create many BodyTypes.
     */
    data: BodyTypeCreateManyInput | BodyTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BodyType update
   */
  export type BodyTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a BodyType.
     */
    data: XOR<BodyTypeUpdateInput, BodyTypeUncheckedUpdateInput>
    /**
     * Choose, which BodyType to update.
     */
    where: BodyTypeWhereUniqueInput
  }

  /**
   * BodyType updateMany
   */
  export type BodyTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BodyTypes.
     */
    data: XOR<BodyTypeUpdateManyMutationInput, BodyTypeUncheckedUpdateManyInput>
    /**
     * Filter which BodyTypes to update
     */
    where?: BodyTypeWhereInput
    /**
     * Limit how many BodyTypes to update.
     */
    limit?: number
  }

  /**
   * BodyType updateManyAndReturn
   */
  export type BodyTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * The data used to update BodyTypes.
     */
    data: XOR<BodyTypeUpdateManyMutationInput, BodyTypeUncheckedUpdateManyInput>
    /**
     * Filter which BodyTypes to update
     */
    where?: BodyTypeWhereInput
    /**
     * Limit how many BodyTypes to update.
     */
    limit?: number
  }

  /**
   * BodyType upsert
   */
  export type BodyTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the BodyType to update in case it exists.
     */
    where: BodyTypeWhereUniqueInput
    /**
     * In case the BodyType found by the `where` argument doesn't exist, create a new BodyType with this data.
     */
    create: XOR<BodyTypeCreateInput, BodyTypeUncheckedCreateInput>
    /**
     * In case the BodyType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BodyTypeUpdateInput, BodyTypeUncheckedUpdateInput>
  }

  /**
   * BodyType delete
   */
  export type BodyTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    /**
     * Filter which BodyType to delete.
     */
    where: BodyTypeWhereUniqueInput
  }

  /**
   * BodyType deleteMany
   */
  export type BodyTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BodyTypes to delete
     */
    where?: BodyTypeWhereInput
    /**
     * Limit how many BodyTypes to delete.
     */
    limit?: number
  }

  /**
   * BodyType.yearModelVersionBodyTypes
   */
  export type BodyType$yearModelVersionBodyTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyType
     */
    select?: YearModelVersionBodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyType
     */
    omit?: YearModelVersionBodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeInclude<ExtArgs> | null
    where?: YearModelVersionBodyTypeWhereInput
    orderBy?: YearModelVersionBodyTypeOrderByWithRelationInput | YearModelVersionBodyTypeOrderByWithRelationInput[]
    cursor?: YearModelVersionBodyTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionBodyTypeScalarFieldEnum | YearModelVersionBodyTypeScalarFieldEnum[]
  }

  /**
   * BodyType.vehicleOffers
   */
  export type BodyType$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * BodyType without action
   */
  export type BodyTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
  }


  /**
   * Model YearModelVersionBodyTypeFuel
   */

  export type AggregateYearModelVersionBodyTypeFuel = {
    _count: YearModelVersionBodyTypeFuelCountAggregateOutputType | null
    _avg: YearModelVersionBodyTypeFuelAvgAggregateOutputType | null
    _sum: YearModelVersionBodyTypeFuelSumAggregateOutputType | null
    _min: YearModelVersionBodyTypeFuelMinAggregateOutputType | null
    _max: YearModelVersionBodyTypeFuelMaxAggregateOutputType | null
  }

  export type YearModelVersionBodyTypeFuelAvgAggregateOutputType = {
    id: number | null
    yearModelVersionBodyTypeId: number | null
    fuelTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelSumAggregateOutputType = {
    id: number | null
    yearModelVersionBodyTypeId: number | null
    fuelTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelVersionBodyTypeId: number | null
    fuelTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelVersionBodyTypeId: number | null
    fuelTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    yearModelVersionBodyTypeId: number
    fuelTypeId: number
    _all: number
  }


  export type YearModelVersionBodyTypeFuelAvgAggregateInputType = {
    id?: true
    yearModelVersionBodyTypeId?: true
    fuelTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelSumAggregateInputType = {
    id?: true
    yearModelVersionBodyTypeId?: true
    fuelTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionBodyTypeId?: true
    fuelTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionBodyTypeId?: true
    fuelTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionBodyTypeId?: true
    fuelTypeId?: true
    _all?: true
  }

  export type YearModelVersionBodyTypeFuelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersionBodyTypeFuel to aggregate.
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuels to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithRelationInput | YearModelVersionBodyTypeFuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearModelVersionBodyTypeFuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearModelVersionBodyTypeFuels
    **/
    _count?: true | YearModelVersionBodyTypeFuelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearModelVersionBodyTypeFuelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearModelVersionBodyTypeFuelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearModelVersionBodyTypeFuelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearModelVersionBodyTypeFuelMaxAggregateInputType
  }

  export type GetYearModelVersionBodyTypeFuelAggregateType<T extends YearModelVersionBodyTypeFuelAggregateArgs> = {
        [P in keyof T & keyof AggregateYearModelVersionBodyTypeFuel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearModelVersionBodyTypeFuel[P]>
      : GetScalarType<T[P], AggregateYearModelVersionBodyTypeFuel[P]>
  }




  export type YearModelVersionBodyTypeFuelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeFuelWhereInput
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithAggregationInput | YearModelVersionBodyTypeFuelOrderByWithAggregationInput[]
    by: YearModelVersionBodyTypeFuelScalarFieldEnum[] | YearModelVersionBodyTypeFuelScalarFieldEnum
    having?: YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearModelVersionBodyTypeFuelCountAggregateInputType | true
    _avg?: YearModelVersionBodyTypeFuelAvgAggregateInputType
    _sum?: YearModelVersionBodyTypeFuelSumAggregateInputType
    _min?: YearModelVersionBodyTypeFuelMinAggregateInputType
    _max?: YearModelVersionBodyTypeFuelMaxAggregateInputType
  }

  export type YearModelVersionBodyTypeFuelGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    yearModelVersionBodyTypeId: number
    fuelTypeId: number
    _count: YearModelVersionBodyTypeFuelCountAggregateOutputType | null
    _avg: YearModelVersionBodyTypeFuelAvgAggregateOutputType | null
    _sum: YearModelVersionBodyTypeFuelSumAggregateOutputType | null
    _min: YearModelVersionBodyTypeFuelMinAggregateOutputType | null
    _max: YearModelVersionBodyTypeFuelMaxAggregateOutputType | null
  }

  type GetYearModelVersionBodyTypeFuelGroupByPayload<T extends YearModelVersionBodyTypeFuelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearModelVersionBodyTypeFuelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearModelVersionBodyTypeFuelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearModelVersionBodyTypeFuelGroupByOutputType[P]>
            : GetScalarType<T[P], YearModelVersionBodyTypeFuelGroupByOutputType[P]>
        }
      >
    >


  export type YearModelVersionBodyTypeFuelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeId?: boolean
    fuelTypeId?: boolean
    yearModelVersionBodyType?: boolean | YearModelVersionBodyTypeDefaultArgs<ExtArgs>
    fuelType?: boolean | FuelTypeDefaultArgs<ExtArgs>
    transmissionTypes?: boolean | YearModelVersionBodyTypeFuel$transmissionTypesArgs<ExtArgs>
    _count?: boolean | YearModelVersionBodyTypeFuelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyTypeFuel"]>

  export type YearModelVersionBodyTypeFuelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeId?: boolean
    fuelTypeId?: boolean
    yearModelVersionBodyType?: boolean | YearModelVersionBodyTypeDefaultArgs<ExtArgs>
    fuelType?: boolean | FuelTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyTypeFuel"]>

  export type YearModelVersionBodyTypeFuelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeId?: boolean
    fuelTypeId?: boolean
    yearModelVersionBodyType?: boolean | YearModelVersionBodyTypeDefaultArgs<ExtArgs>
    fuelType?: boolean | FuelTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyTypeFuel"]>

  export type YearModelVersionBodyTypeFuelSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeId?: boolean
    fuelTypeId?: boolean
  }

  export type YearModelVersionBodyTypeFuelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "yearModelVersionBodyTypeId" | "fuelTypeId", ExtArgs["result"]["yearModelVersionBodyTypeFuel"]>
  export type YearModelVersionBodyTypeFuelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyType?: boolean | YearModelVersionBodyTypeDefaultArgs<ExtArgs>
    fuelType?: boolean | FuelTypeDefaultArgs<ExtArgs>
    transmissionTypes?: boolean | YearModelVersionBodyTypeFuel$transmissionTypesArgs<ExtArgs>
    _count?: boolean | YearModelVersionBodyTypeFuelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionBodyTypeFuelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyType?: boolean | YearModelVersionBodyTypeDefaultArgs<ExtArgs>
    fuelType?: boolean | FuelTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionBodyTypeFuelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyType?: boolean | YearModelVersionBodyTypeDefaultArgs<ExtArgs>
    fuelType?: boolean | FuelTypeDefaultArgs<ExtArgs>
  }

  export type $YearModelVersionBodyTypeFuelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearModelVersionBodyTypeFuel"
    objects: {
      yearModelVersionBodyType: Prisma.$YearModelVersionBodyTypePayload<ExtArgs>
      fuelType: Prisma.$FuelTypePayload<ExtArgs>
      transmissionTypes: Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      yearModelVersionBodyTypeId: number
      fuelTypeId: number
    }, ExtArgs["result"]["yearModelVersionBodyTypeFuel"]>
    composites: {}
  }

  type YearModelVersionBodyTypeFuelGetPayload<S extends boolean | null | undefined | YearModelVersionBodyTypeFuelDefaultArgs> = $Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload, S>

  type YearModelVersionBodyTypeFuelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearModelVersionBodyTypeFuelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearModelVersionBodyTypeFuelCountAggregateInputType | true
    }

  export interface YearModelVersionBodyTypeFuelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearModelVersionBodyTypeFuel'], meta: { name: 'YearModelVersionBodyTypeFuel' } }
    /**
     * Find zero or one YearModelVersionBodyTypeFuel that matches the filter.
     * @param {YearModelVersionBodyTypeFuelFindUniqueArgs} args - Arguments to find a YearModelVersionBodyTypeFuel
     * @example
     * // Get one YearModelVersionBodyTypeFuel
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearModelVersionBodyTypeFuelFindUniqueArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelFindUniqueArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearModelVersionBodyTypeFuel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearModelVersionBodyTypeFuelFindUniqueOrThrowArgs} args - Arguments to find a YearModelVersionBodyTypeFuel
     * @example
     * // Get one YearModelVersionBodyTypeFuel
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearModelVersionBodyTypeFuelFindUniqueOrThrowArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersionBodyTypeFuel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelFindFirstArgs} args - Arguments to find a YearModelVersionBodyTypeFuel
     * @example
     * // Get one YearModelVersionBodyTypeFuel
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearModelVersionBodyTypeFuelFindFirstArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelFindFirstArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersionBodyTypeFuel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelFindFirstOrThrowArgs} args - Arguments to find a YearModelVersionBodyTypeFuel
     * @example
     * // Get one YearModelVersionBodyTypeFuel
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearModelVersionBodyTypeFuelFindFirstOrThrowArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearModelVersionBodyTypeFuels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearModelVersionBodyTypeFuels
     * const yearModelVersionBodyTypeFuels = await prisma.yearModelVersionBodyTypeFuel.findMany()
     * 
     * // Get first 10 YearModelVersionBodyTypeFuels
     * const yearModelVersionBodyTypeFuels = await prisma.yearModelVersionBodyTypeFuel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearModelVersionBodyTypeFuelWithIdOnly = await prisma.yearModelVersionBodyTypeFuel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearModelVersionBodyTypeFuelFindManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearModelVersionBodyTypeFuel.
     * @param {YearModelVersionBodyTypeFuelCreateArgs} args - Arguments to create a YearModelVersionBodyTypeFuel.
     * @example
     * // Create one YearModelVersionBodyTypeFuel
     * const YearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.create({
     *   data: {
     *     // ... data to create a YearModelVersionBodyTypeFuel
     *   }
     * })
     * 
     */
    create<T extends YearModelVersionBodyTypeFuelCreateArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelCreateArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearModelVersionBodyTypeFuels.
     * @param {YearModelVersionBodyTypeFuelCreateManyArgs} args - Arguments to create many YearModelVersionBodyTypeFuels.
     * @example
     * // Create many YearModelVersionBodyTypeFuels
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearModelVersionBodyTypeFuelCreateManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearModelVersionBodyTypeFuels and returns the data saved in the database.
     * @param {YearModelVersionBodyTypeFuelCreateManyAndReturnArgs} args - Arguments to create many YearModelVersionBodyTypeFuels.
     * @example
     * // Create many YearModelVersionBodyTypeFuels
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearModelVersionBodyTypeFuels and only return the `id`
     * const yearModelVersionBodyTypeFuelWithIdOnly = await prisma.yearModelVersionBodyTypeFuel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearModelVersionBodyTypeFuelCreateManyAndReturnArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearModelVersionBodyTypeFuel.
     * @param {YearModelVersionBodyTypeFuelDeleteArgs} args - Arguments to delete one YearModelVersionBodyTypeFuel.
     * @example
     * // Delete one YearModelVersionBodyTypeFuel
     * const YearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.delete({
     *   where: {
     *     // ... filter to delete one YearModelVersionBodyTypeFuel
     *   }
     * })
     * 
     */
    delete<T extends YearModelVersionBodyTypeFuelDeleteArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelDeleteArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearModelVersionBodyTypeFuel.
     * @param {YearModelVersionBodyTypeFuelUpdateArgs} args - Arguments to update one YearModelVersionBodyTypeFuel.
     * @example
     * // Update one YearModelVersionBodyTypeFuel
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearModelVersionBodyTypeFuelUpdateArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelUpdateArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearModelVersionBodyTypeFuels.
     * @param {YearModelVersionBodyTypeFuelDeleteManyArgs} args - Arguments to filter YearModelVersionBodyTypeFuels to delete.
     * @example
     * // Delete a few YearModelVersionBodyTypeFuels
     * const { count } = await prisma.yearModelVersionBodyTypeFuel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearModelVersionBodyTypeFuelDeleteManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersionBodyTypeFuels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearModelVersionBodyTypeFuels
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearModelVersionBodyTypeFuelUpdateManyArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersionBodyTypeFuels and returns the data updated in the database.
     * @param {YearModelVersionBodyTypeFuelUpdateManyAndReturnArgs} args - Arguments to update many YearModelVersionBodyTypeFuels.
     * @example
     * // Update many YearModelVersionBodyTypeFuels
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearModelVersionBodyTypeFuels and only return the `id`
     * const yearModelVersionBodyTypeFuelWithIdOnly = await prisma.yearModelVersionBodyTypeFuel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearModelVersionBodyTypeFuelUpdateManyAndReturnArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearModelVersionBodyTypeFuel.
     * @param {YearModelVersionBodyTypeFuelUpsertArgs} args - Arguments to update or create a YearModelVersionBodyTypeFuel.
     * @example
     * // Update or create a YearModelVersionBodyTypeFuel
     * const yearModelVersionBodyTypeFuel = await prisma.yearModelVersionBodyTypeFuel.upsert({
     *   create: {
     *     // ... data to create a YearModelVersionBodyTypeFuel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearModelVersionBodyTypeFuel we want to update
     *   }
     * })
     */
    upsert<T extends YearModelVersionBodyTypeFuelUpsertArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelUpsertArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearModelVersionBodyTypeFuels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelCountArgs} args - Arguments to filter YearModelVersionBodyTypeFuels to count.
     * @example
     * // Count the number of YearModelVersionBodyTypeFuels
     * const count = await prisma.yearModelVersionBodyTypeFuel.count({
     *   where: {
     *     // ... the filter for the YearModelVersionBodyTypeFuels we want to count
     *   }
     * })
    **/
    count<T extends YearModelVersionBodyTypeFuelCountArgs>(
      args?: Subset<T, YearModelVersionBodyTypeFuelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearModelVersionBodyTypeFuelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearModelVersionBodyTypeFuel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearModelVersionBodyTypeFuelAggregateArgs>(args: Subset<T, YearModelVersionBodyTypeFuelAggregateArgs>): Prisma.PrismaPromise<GetYearModelVersionBodyTypeFuelAggregateType<T>>

    /**
     * Group by YearModelVersionBodyTypeFuel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearModelVersionBodyTypeFuelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearModelVersionBodyTypeFuelGroupByArgs['orderBy'] }
        : { orderBy?: YearModelVersionBodyTypeFuelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearModelVersionBodyTypeFuelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearModelVersionBodyTypeFuelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearModelVersionBodyTypeFuel model
   */
  readonly fields: YearModelVersionBodyTypeFuelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearModelVersionBodyTypeFuel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearModelVersionBodyTypeFuelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersionBodyType<T extends YearModelVersionBodyTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearModelVersionBodyTypeDefaultArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fuelType<T extends FuelTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FuelTypeDefaultArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transmissionTypes<T extends YearModelVersionBodyTypeFuel$transmissionTypesArgs<ExtArgs> = {}>(args?: Subset<T, YearModelVersionBodyTypeFuel$transmissionTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearModelVersionBodyTypeFuel model
   */
  interface YearModelVersionBodyTypeFuelFieldRefs {
    readonly id: FieldRef<"YearModelVersionBodyTypeFuel", 'Int'>
    readonly createdAt: FieldRef<"YearModelVersionBodyTypeFuel", 'DateTime'>
    readonly updatedAt: FieldRef<"YearModelVersionBodyTypeFuel", 'DateTime'>
    readonly yearModelVersionBodyTypeId: FieldRef<"YearModelVersionBodyTypeFuel", 'Int'>
    readonly fuelTypeId: FieldRef<"YearModelVersionBodyTypeFuel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearModelVersionBodyTypeFuel findUnique
   */
  export type YearModelVersionBodyTypeFuelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuel to fetch.
     */
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuel findUniqueOrThrow
   */
  export type YearModelVersionBodyTypeFuelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuel to fetch.
     */
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuel findFirst
   */
  export type YearModelVersionBodyTypeFuelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuel to fetch.
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuels to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithRelationInput | YearModelVersionBodyTypeFuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersionBodyTypeFuels.
     */
    cursor?: YearModelVersionBodyTypeFuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersionBodyTypeFuels.
     */
    distinct?: YearModelVersionBodyTypeFuelScalarFieldEnum | YearModelVersionBodyTypeFuelScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuel findFirstOrThrow
   */
  export type YearModelVersionBodyTypeFuelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuel to fetch.
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuels to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithRelationInput | YearModelVersionBodyTypeFuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersionBodyTypeFuels.
     */
    cursor?: YearModelVersionBodyTypeFuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersionBodyTypeFuels.
     */
    distinct?: YearModelVersionBodyTypeFuelScalarFieldEnum | YearModelVersionBodyTypeFuelScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuel findMany
   */
  export type YearModelVersionBodyTypeFuelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuels to fetch.
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuels to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithRelationInput | YearModelVersionBodyTypeFuelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearModelVersionBodyTypeFuels.
     */
    cursor?: YearModelVersionBodyTypeFuelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuels.
     */
    skip?: number
    distinct?: YearModelVersionBodyTypeFuelScalarFieldEnum | YearModelVersionBodyTypeFuelScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuel create
   */
  export type YearModelVersionBodyTypeFuelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * The data needed to create a YearModelVersionBodyTypeFuel.
     */
    data: XOR<YearModelVersionBodyTypeFuelCreateInput, YearModelVersionBodyTypeFuelUncheckedCreateInput>
  }

  /**
   * YearModelVersionBodyTypeFuel createMany
   */
  export type YearModelVersionBodyTypeFuelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearModelVersionBodyTypeFuels.
     */
    data: YearModelVersionBodyTypeFuelCreateManyInput | YearModelVersionBodyTypeFuelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearModelVersionBodyTypeFuel createManyAndReturn
   */
  export type YearModelVersionBodyTypeFuelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * The data used to create many YearModelVersionBodyTypeFuels.
     */
    data: YearModelVersionBodyTypeFuelCreateManyInput | YearModelVersionBodyTypeFuelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyTypeFuel update
   */
  export type YearModelVersionBodyTypeFuelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * The data needed to update a YearModelVersionBodyTypeFuel.
     */
    data: XOR<YearModelVersionBodyTypeFuelUpdateInput, YearModelVersionBodyTypeFuelUncheckedUpdateInput>
    /**
     * Choose, which YearModelVersionBodyTypeFuel to update.
     */
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuel updateMany
   */
  export type YearModelVersionBodyTypeFuelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearModelVersionBodyTypeFuels.
     */
    data: XOR<YearModelVersionBodyTypeFuelUpdateManyMutationInput, YearModelVersionBodyTypeFuelUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersionBodyTypeFuels to update
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * Limit how many YearModelVersionBodyTypeFuels to update.
     */
    limit?: number
  }

  /**
   * YearModelVersionBodyTypeFuel updateManyAndReturn
   */
  export type YearModelVersionBodyTypeFuelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * The data used to update YearModelVersionBodyTypeFuels.
     */
    data: XOR<YearModelVersionBodyTypeFuelUpdateManyMutationInput, YearModelVersionBodyTypeFuelUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersionBodyTypeFuels to update
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * Limit how many YearModelVersionBodyTypeFuels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyTypeFuel upsert
   */
  export type YearModelVersionBodyTypeFuelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * The filter to search for the YearModelVersionBodyTypeFuel to update in case it exists.
     */
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    /**
     * In case the YearModelVersionBodyTypeFuel found by the `where` argument doesn't exist, create a new YearModelVersionBodyTypeFuel with this data.
     */
    create: XOR<YearModelVersionBodyTypeFuelCreateInput, YearModelVersionBodyTypeFuelUncheckedCreateInput>
    /**
     * In case the YearModelVersionBodyTypeFuel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearModelVersionBodyTypeFuelUpdateInput, YearModelVersionBodyTypeFuelUncheckedUpdateInput>
  }

  /**
   * YearModelVersionBodyTypeFuel delete
   */
  export type YearModelVersionBodyTypeFuelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    /**
     * Filter which YearModelVersionBodyTypeFuel to delete.
     */
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuel deleteMany
   */
  export type YearModelVersionBodyTypeFuelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersionBodyTypeFuels to delete
     */
    where?: YearModelVersionBodyTypeFuelWhereInput
    /**
     * Limit how many YearModelVersionBodyTypeFuels to delete.
     */
    limit?: number
  }

  /**
   * YearModelVersionBodyTypeFuel.transmissionTypes
   */
  export type YearModelVersionBodyTypeFuel$transmissionTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput[]
    cursor?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum | YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuel without action
   */
  export type YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
  }


  /**
   * Model FuelType
   */

  export type AggregateFuelType = {
    _count: FuelTypeCountAggregateOutputType | null
    _avg: FuelTypeAvgAggregateOutputType | null
    _sum: FuelTypeSumAggregateOutputType | null
    _min: FuelTypeMinAggregateOutputType | null
    _max: FuelTypeMaxAggregateOutputType | null
  }

  export type FuelTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type FuelTypeSumAggregateOutputType = {
    id: number | null
  }

  export type FuelTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FuelTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FuelTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FuelTypeAvgAggregateInputType = {
    id?: true
  }

  export type FuelTypeSumAggregateInputType = {
    id?: true
  }

  export type FuelTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FuelTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FuelTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FuelTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FuelType to aggregate.
     */
    where?: FuelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelTypes to fetch.
     */
    orderBy?: FuelTypeOrderByWithRelationInput | FuelTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FuelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FuelTypes
    **/
    _count?: true | FuelTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FuelTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FuelTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FuelTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FuelTypeMaxAggregateInputType
  }

  export type GetFuelTypeAggregateType<T extends FuelTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateFuelType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFuelType[P]>
      : GetScalarType<T[P], AggregateFuelType[P]>
  }




  export type FuelTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FuelTypeWhereInput
    orderBy?: FuelTypeOrderByWithAggregationInput | FuelTypeOrderByWithAggregationInput[]
    by: FuelTypeScalarFieldEnum[] | FuelTypeScalarFieldEnum
    having?: FuelTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FuelTypeCountAggregateInputType | true
    _avg?: FuelTypeAvgAggregateInputType
    _sum?: FuelTypeSumAggregateInputType
    _min?: FuelTypeMinAggregateInputType
    _max?: FuelTypeMaxAggregateInputType
  }

  export type FuelTypeGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: FuelTypeCountAggregateOutputType | null
    _avg: FuelTypeAvgAggregateOutputType | null
    _sum: FuelTypeSumAggregateOutputType | null
    _min: FuelTypeMinAggregateOutputType | null
    _max: FuelTypeMaxAggregateOutputType | null
  }

  type GetFuelTypeGroupByPayload<T extends FuelTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FuelTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FuelTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FuelTypeGroupByOutputType[P]>
            : GetScalarType<T[P], FuelTypeGroupByOutputType[P]>
        }
      >
    >


  export type FuelTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeFuels?: boolean | FuelType$yearModelVersionBodyTypeFuelsArgs<ExtArgs>
    vehicleOffers?: boolean | FuelType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | FuelTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fuelType"]>

  export type FuelTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fuelType"]>

  export type FuelTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fuelType"]>

  export type FuelTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FuelTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["fuelType"]>
  export type FuelTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuels?: boolean | FuelType$yearModelVersionBodyTypeFuelsArgs<ExtArgs>
    vehicleOffers?: boolean | FuelType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | FuelTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FuelTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FuelTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FuelTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FuelType"
    objects: {
      yearModelVersionBodyTypeFuels: Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fuelType"]>
    composites: {}
  }

  type FuelTypeGetPayload<S extends boolean | null | undefined | FuelTypeDefaultArgs> = $Result.GetResult<Prisma.$FuelTypePayload, S>

  type FuelTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FuelTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FuelTypeCountAggregateInputType | true
    }

  export interface FuelTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FuelType'], meta: { name: 'FuelType' } }
    /**
     * Find zero or one FuelType that matches the filter.
     * @param {FuelTypeFindUniqueArgs} args - Arguments to find a FuelType
     * @example
     * // Get one FuelType
     * const fuelType = await prisma.fuelType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FuelTypeFindUniqueArgs>(args: SelectSubset<T, FuelTypeFindUniqueArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FuelType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FuelTypeFindUniqueOrThrowArgs} args - Arguments to find a FuelType
     * @example
     * // Get one FuelType
     * const fuelType = await prisma.fuelType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FuelTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, FuelTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FuelType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeFindFirstArgs} args - Arguments to find a FuelType
     * @example
     * // Get one FuelType
     * const fuelType = await prisma.fuelType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FuelTypeFindFirstArgs>(args?: SelectSubset<T, FuelTypeFindFirstArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FuelType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeFindFirstOrThrowArgs} args - Arguments to find a FuelType
     * @example
     * // Get one FuelType
     * const fuelType = await prisma.fuelType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FuelTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, FuelTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FuelTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FuelTypes
     * const fuelTypes = await prisma.fuelType.findMany()
     * 
     * // Get first 10 FuelTypes
     * const fuelTypes = await prisma.fuelType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fuelTypeWithIdOnly = await prisma.fuelType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FuelTypeFindManyArgs>(args?: SelectSubset<T, FuelTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FuelType.
     * @param {FuelTypeCreateArgs} args - Arguments to create a FuelType.
     * @example
     * // Create one FuelType
     * const FuelType = await prisma.fuelType.create({
     *   data: {
     *     // ... data to create a FuelType
     *   }
     * })
     * 
     */
    create<T extends FuelTypeCreateArgs>(args: SelectSubset<T, FuelTypeCreateArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FuelTypes.
     * @param {FuelTypeCreateManyArgs} args - Arguments to create many FuelTypes.
     * @example
     * // Create many FuelTypes
     * const fuelType = await prisma.fuelType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FuelTypeCreateManyArgs>(args?: SelectSubset<T, FuelTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FuelTypes and returns the data saved in the database.
     * @param {FuelTypeCreateManyAndReturnArgs} args - Arguments to create many FuelTypes.
     * @example
     * // Create many FuelTypes
     * const fuelType = await prisma.fuelType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FuelTypes and only return the `id`
     * const fuelTypeWithIdOnly = await prisma.fuelType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FuelTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, FuelTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FuelType.
     * @param {FuelTypeDeleteArgs} args - Arguments to delete one FuelType.
     * @example
     * // Delete one FuelType
     * const FuelType = await prisma.fuelType.delete({
     *   where: {
     *     // ... filter to delete one FuelType
     *   }
     * })
     * 
     */
    delete<T extends FuelTypeDeleteArgs>(args: SelectSubset<T, FuelTypeDeleteArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FuelType.
     * @param {FuelTypeUpdateArgs} args - Arguments to update one FuelType.
     * @example
     * // Update one FuelType
     * const fuelType = await prisma.fuelType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FuelTypeUpdateArgs>(args: SelectSubset<T, FuelTypeUpdateArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FuelTypes.
     * @param {FuelTypeDeleteManyArgs} args - Arguments to filter FuelTypes to delete.
     * @example
     * // Delete a few FuelTypes
     * const { count } = await prisma.fuelType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FuelTypeDeleteManyArgs>(args?: SelectSubset<T, FuelTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FuelTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FuelTypes
     * const fuelType = await prisma.fuelType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FuelTypeUpdateManyArgs>(args: SelectSubset<T, FuelTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FuelTypes and returns the data updated in the database.
     * @param {FuelTypeUpdateManyAndReturnArgs} args - Arguments to update many FuelTypes.
     * @example
     * // Update many FuelTypes
     * const fuelType = await prisma.fuelType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FuelTypes and only return the `id`
     * const fuelTypeWithIdOnly = await prisma.fuelType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FuelTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, FuelTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FuelType.
     * @param {FuelTypeUpsertArgs} args - Arguments to update or create a FuelType.
     * @example
     * // Update or create a FuelType
     * const fuelType = await prisma.fuelType.upsert({
     *   create: {
     *     // ... data to create a FuelType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FuelType we want to update
     *   }
     * })
     */
    upsert<T extends FuelTypeUpsertArgs>(args: SelectSubset<T, FuelTypeUpsertArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FuelTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeCountArgs} args - Arguments to filter FuelTypes to count.
     * @example
     * // Count the number of FuelTypes
     * const count = await prisma.fuelType.count({
     *   where: {
     *     // ... the filter for the FuelTypes we want to count
     *   }
     * })
    **/
    count<T extends FuelTypeCountArgs>(
      args?: Subset<T, FuelTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FuelTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FuelType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FuelTypeAggregateArgs>(args: Subset<T, FuelTypeAggregateArgs>): Prisma.PrismaPromise<GetFuelTypeAggregateType<T>>

    /**
     * Group by FuelType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuelTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FuelTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FuelTypeGroupByArgs['orderBy'] }
        : { orderBy?: FuelTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FuelTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFuelTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FuelType model
   */
  readonly fields: FuelTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FuelType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FuelTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersionBodyTypeFuels<T extends FuelType$yearModelVersionBodyTypeFuelsArgs<ExtArgs> = {}>(args?: Subset<T, FuelType$yearModelVersionBodyTypeFuelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends FuelType$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, FuelType$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FuelType model
   */
  interface FuelTypeFieldRefs {
    readonly id: FieldRef<"FuelType", 'Int'>
    readonly name: FieldRef<"FuelType", 'String'>
    readonly createdAt: FieldRef<"FuelType", 'DateTime'>
    readonly updatedAt: FieldRef<"FuelType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FuelType findUnique
   */
  export type FuelTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * Filter, which FuelType to fetch.
     */
    where: FuelTypeWhereUniqueInput
  }

  /**
   * FuelType findUniqueOrThrow
   */
  export type FuelTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * Filter, which FuelType to fetch.
     */
    where: FuelTypeWhereUniqueInput
  }

  /**
   * FuelType findFirst
   */
  export type FuelTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * Filter, which FuelType to fetch.
     */
    where?: FuelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelTypes to fetch.
     */
    orderBy?: FuelTypeOrderByWithRelationInput | FuelTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FuelTypes.
     */
    cursor?: FuelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FuelTypes.
     */
    distinct?: FuelTypeScalarFieldEnum | FuelTypeScalarFieldEnum[]
  }

  /**
   * FuelType findFirstOrThrow
   */
  export type FuelTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * Filter, which FuelType to fetch.
     */
    where?: FuelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelTypes to fetch.
     */
    orderBy?: FuelTypeOrderByWithRelationInput | FuelTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FuelTypes.
     */
    cursor?: FuelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FuelTypes.
     */
    distinct?: FuelTypeScalarFieldEnum | FuelTypeScalarFieldEnum[]
  }

  /**
   * FuelType findMany
   */
  export type FuelTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * Filter, which FuelTypes to fetch.
     */
    where?: FuelTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FuelTypes to fetch.
     */
    orderBy?: FuelTypeOrderByWithRelationInput | FuelTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FuelTypes.
     */
    cursor?: FuelTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FuelTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FuelTypes.
     */
    skip?: number
    distinct?: FuelTypeScalarFieldEnum | FuelTypeScalarFieldEnum[]
  }

  /**
   * FuelType create
   */
  export type FuelTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a FuelType.
     */
    data: XOR<FuelTypeCreateInput, FuelTypeUncheckedCreateInput>
  }

  /**
   * FuelType createMany
   */
  export type FuelTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FuelTypes.
     */
    data: FuelTypeCreateManyInput | FuelTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FuelType createManyAndReturn
   */
  export type FuelTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * The data used to create many FuelTypes.
     */
    data: FuelTypeCreateManyInput | FuelTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FuelType update
   */
  export type FuelTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a FuelType.
     */
    data: XOR<FuelTypeUpdateInput, FuelTypeUncheckedUpdateInput>
    /**
     * Choose, which FuelType to update.
     */
    where: FuelTypeWhereUniqueInput
  }

  /**
   * FuelType updateMany
   */
  export type FuelTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FuelTypes.
     */
    data: XOR<FuelTypeUpdateManyMutationInput, FuelTypeUncheckedUpdateManyInput>
    /**
     * Filter which FuelTypes to update
     */
    where?: FuelTypeWhereInput
    /**
     * Limit how many FuelTypes to update.
     */
    limit?: number
  }

  /**
   * FuelType updateManyAndReturn
   */
  export type FuelTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * The data used to update FuelTypes.
     */
    data: XOR<FuelTypeUpdateManyMutationInput, FuelTypeUncheckedUpdateManyInput>
    /**
     * Filter which FuelTypes to update
     */
    where?: FuelTypeWhereInput
    /**
     * Limit how many FuelTypes to update.
     */
    limit?: number
  }

  /**
   * FuelType upsert
   */
  export type FuelTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the FuelType to update in case it exists.
     */
    where: FuelTypeWhereUniqueInput
    /**
     * In case the FuelType found by the `where` argument doesn't exist, create a new FuelType with this data.
     */
    create: XOR<FuelTypeCreateInput, FuelTypeUncheckedCreateInput>
    /**
     * In case the FuelType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FuelTypeUpdateInput, FuelTypeUncheckedUpdateInput>
  }

  /**
   * FuelType delete
   */
  export type FuelTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    /**
     * Filter which FuelType to delete.
     */
    where: FuelTypeWhereUniqueInput
  }

  /**
   * FuelType deleteMany
   */
  export type FuelTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FuelTypes to delete
     */
    where?: FuelTypeWhereInput
    /**
     * Limit how many FuelTypes to delete.
     */
    limit?: number
  }

  /**
   * FuelType.yearModelVersionBodyTypeFuels
   */
  export type FuelType$yearModelVersionBodyTypeFuelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuel
     */
    select?: YearModelVersionBodyTypeFuelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuel
     */
    omit?: YearModelVersionBodyTypeFuelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelInclude<ExtArgs> | null
    where?: YearModelVersionBodyTypeFuelWhereInput
    orderBy?: YearModelVersionBodyTypeFuelOrderByWithRelationInput | YearModelVersionBodyTypeFuelOrderByWithRelationInput[]
    cursor?: YearModelVersionBodyTypeFuelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionBodyTypeFuelScalarFieldEnum | YearModelVersionBodyTypeFuelScalarFieldEnum[]
  }

  /**
   * FuelType.vehicleOffers
   */
  export type FuelType$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * FuelType without action
   */
  export type FuelTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
  }


  /**
   * Model YearModelVersionBodyTypeFuelTransmission
   */

  export type AggregateYearModelVersionBodyTypeFuelTransmission = {
    _count: YearModelVersionBodyTypeFuelTransmissionCountAggregateOutputType | null
    _avg: YearModelVersionBodyTypeFuelTransmissionAvgAggregateOutputType | null
    _sum: YearModelVersionBodyTypeFuelTransmissionSumAggregateOutputType | null
    _min: YearModelVersionBodyTypeFuelTransmissionMinAggregateOutputType | null
    _max: YearModelVersionBodyTypeFuelTransmissionMaxAggregateOutputType | null
  }

  export type YearModelVersionBodyTypeFuelTransmissionAvgAggregateOutputType = {
    id: number | null
    yearModelVersionBodyTypeFuelId: number | null
    transmissionTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelTransmissionSumAggregateOutputType = {
    id: number | null
    yearModelVersionBodyTypeFuelId: number | null
    transmissionTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelTransmissionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelVersionBodyTypeFuelId: number | null
    transmissionTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelTransmissionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    yearModelVersionBodyTypeFuelId: number | null
    transmissionTypeId: number | null
  }

  export type YearModelVersionBodyTypeFuelTransmissionCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    yearModelVersionBodyTypeFuelId: number
    transmissionTypeId: number
    _all: number
  }


  export type YearModelVersionBodyTypeFuelTransmissionAvgAggregateInputType = {
    id?: true
    yearModelVersionBodyTypeFuelId?: true
    transmissionTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelTransmissionSumAggregateInputType = {
    id?: true
    yearModelVersionBodyTypeFuelId?: true
    transmissionTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelTransmissionMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionBodyTypeFuelId?: true
    transmissionTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelTransmissionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionBodyTypeFuelId?: true
    transmissionTypeId?: true
  }

  export type YearModelVersionBodyTypeFuelTransmissionCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    yearModelVersionBodyTypeFuelId?: true
    transmissionTypeId?: true
    _all?: true
  }

  export type YearModelVersionBodyTypeFuelTransmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersionBodyTypeFuelTransmission to aggregate.
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuelTransmissions to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuelTransmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuelTransmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned YearModelVersionBodyTypeFuelTransmissions
    **/
    _count?: true | YearModelVersionBodyTypeFuelTransmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: YearModelVersionBodyTypeFuelTransmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: YearModelVersionBodyTypeFuelTransmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: YearModelVersionBodyTypeFuelTransmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: YearModelVersionBodyTypeFuelTransmissionMaxAggregateInputType
  }

  export type GetYearModelVersionBodyTypeFuelTransmissionAggregateType<T extends YearModelVersionBodyTypeFuelTransmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateYearModelVersionBodyTypeFuelTransmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateYearModelVersionBodyTypeFuelTransmission[P]>
      : GetScalarType<T[P], AggregateYearModelVersionBodyTypeFuelTransmission[P]>
  }




  export type YearModelVersionBodyTypeFuelTransmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithAggregationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithAggregationInput[]
    by: YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum[] | YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum
    having?: YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: YearModelVersionBodyTypeFuelTransmissionCountAggregateInputType | true
    _avg?: YearModelVersionBodyTypeFuelTransmissionAvgAggregateInputType
    _sum?: YearModelVersionBodyTypeFuelTransmissionSumAggregateInputType
    _min?: YearModelVersionBodyTypeFuelTransmissionMinAggregateInputType
    _max?: YearModelVersionBodyTypeFuelTransmissionMaxAggregateInputType
  }

  export type YearModelVersionBodyTypeFuelTransmissionGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    yearModelVersionBodyTypeFuelId: number
    transmissionTypeId: number
    _count: YearModelVersionBodyTypeFuelTransmissionCountAggregateOutputType | null
    _avg: YearModelVersionBodyTypeFuelTransmissionAvgAggregateOutputType | null
    _sum: YearModelVersionBodyTypeFuelTransmissionSumAggregateOutputType | null
    _min: YearModelVersionBodyTypeFuelTransmissionMinAggregateOutputType | null
    _max: YearModelVersionBodyTypeFuelTransmissionMaxAggregateOutputType | null
  }

  type GetYearModelVersionBodyTypeFuelTransmissionGroupByPayload<T extends YearModelVersionBodyTypeFuelTransmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<YearModelVersionBodyTypeFuelTransmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof YearModelVersionBodyTypeFuelTransmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], YearModelVersionBodyTypeFuelTransmissionGroupByOutputType[P]>
            : GetScalarType<T[P], YearModelVersionBodyTypeFuelTransmissionGroupByOutputType[P]>
        }
      >
    >


  export type YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeFuelId?: boolean
    transmissionTypeId?: boolean
    yearModelVersionBodyTypeFuel?: boolean | YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>
    transmissionType?: boolean | TransmissionTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyTypeFuelTransmission"]>

  export type YearModelVersionBodyTypeFuelTransmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeFuelId?: boolean
    transmissionTypeId?: boolean
    yearModelVersionBodyTypeFuel?: boolean | YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>
    transmissionType?: boolean | TransmissionTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyTypeFuelTransmission"]>

  export type YearModelVersionBodyTypeFuelTransmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeFuelId?: boolean
    transmissionTypeId?: boolean
    yearModelVersionBodyTypeFuel?: boolean | YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>
    transmissionType?: boolean | TransmissionTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["yearModelVersionBodyTypeFuelTransmission"]>

  export type YearModelVersionBodyTypeFuelTransmissionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeFuelId?: boolean
    transmissionTypeId?: boolean
  }

  export type YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "yearModelVersionBodyTypeFuelId" | "transmissionTypeId", ExtArgs["result"]["yearModelVersionBodyTypeFuelTransmission"]>
  export type YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuel?: boolean | YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>
    transmissionType?: boolean | TransmissionTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionBodyTypeFuelTransmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuel?: boolean | YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>
    transmissionType?: boolean | TransmissionTypeDefaultArgs<ExtArgs>
  }
  export type YearModelVersionBodyTypeFuelTransmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuel?: boolean | YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>
    transmissionType?: boolean | TransmissionTypeDefaultArgs<ExtArgs>
  }

  export type $YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "YearModelVersionBodyTypeFuelTransmission"
    objects: {
      yearModelVersionBodyTypeFuel: Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>
      transmissionType: Prisma.$TransmissionTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      updatedAt: Date
      yearModelVersionBodyTypeFuelId: number
      transmissionTypeId: number
    }, ExtArgs["result"]["yearModelVersionBodyTypeFuelTransmission"]>
    composites: {}
  }

  type YearModelVersionBodyTypeFuelTransmissionGetPayload<S extends boolean | null | undefined | YearModelVersionBodyTypeFuelTransmissionDefaultArgs> = $Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload, S>

  type YearModelVersionBodyTypeFuelTransmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<YearModelVersionBodyTypeFuelTransmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: YearModelVersionBodyTypeFuelTransmissionCountAggregateInputType | true
    }

  export interface YearModelVersionBodyTypeFuelTransmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['YearModelVersionBodyTypeFuelTransmission'], meta: { name: 'YearModelVersionBodyTypeFuelTransmission' } }
    /**
     * Find zero or one YearModelVersionBodyTypeFuelTransmission that matches the filter.
     * @param {YearModelVersionBodyTypeFuelTransmissionFindUniqueArgs} args - Arguments to find a YearModelVersionBodyTypeFuelTransmission
     * @example
     * // Get one YearModelVersionBodyTypeFuelTransmission
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends YearModelVersionBodyTypeFuelTransmissionFindUniqueArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionFindUniqueArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one YearModelVersionBodyTypeFuelTransmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {YearModelVersionBodyTypeFuelTransmissionFindUniqueOrThrowArgs} args - Arguments to find a YearModelVersionBodyTypeFuelTransmission
     * @example
     * // Get one YearModelVersionBodyTypeFuelTransmission
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends YearModelVersionBodyTypeFuelTransmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersionBodyTypeFuelTransmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionFindFirstArgs} args - Arguments to find a YearModelVersionBodyTypeFuelTransmission
     * @example
     * // Get one YearModelVersionBodyTypeFuelTransmission
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends YearModelVersionBodyTypeFuelTransmissionFindFirstArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionFindFirstArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first YearModelVersionBodyTypeFuelTransmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionFindFirstOrThrowArgs} args - Arguments to find a YearModelVersionBodyTypeFuelTransmission
     * @example
     * // Get one YearModelVersionBodyTypeFuelTransmission
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends YearModelVersionBodyTypeFuelTransmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more YearModelVersionBodyTypeFuelTransmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all YearModelVersionBodyTypeFuelTransmissions
     * const yearModelVersionBodyTypeFuelTransmissions = await prisma.yearModelVersionBodyTypeFuelTransmission.findMany()
     * 
     * // Get first 10 YearModelVersionBodyTypeFuelTransmissions
     * const yearModelVersionBodyTypeFuelTransmissions = await prisma.yearModelVersionBodyTypeFuelTransmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const yearModelVersionBodyTypeFuelTransmissionWithIdOnly = await prisma.yearModelVersionBodyTypeFuelTransmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends YearModelVersionBodyTypeFuelTransmissionFindManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a YearModelVersionBodyTypeFuelTransmission.
     * @param {YearModelVersionBodyTypeFuelTransmissionCreateArgs} args - Arguments to create a YearModelVersionBodyTypeFuelTransmission.
     * @example
     * // Create one YearModelVersionBodyTypeFuelTransmission
     * const YearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.create({
     *   data: {
     *     // ... data to create a YearModelVersionBodyTypeFuelTransmission
     *   }
     * })
     * 
     */
    create<T extends YearModelVersionBodyTypeFuelTransmissionCreateArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionCreateArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many YearModelVersionBodyTypeFuelTransmissions.
     * @param {YearModelVersionBodyTypeFuelTransmissionCreateManyArgs} args - Arguments to create many YearModelVersionBodyTypeFuelTransmissions.
     * @example
     * // Create many YearModelVersionBodyTypeFuelTransmissions
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends YearModelVersionBodyTypeFuelTransmissionCreateManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many YearModelVersionBodyTypeFuelTransmissions and returns the data saved in the database.
     * @param {YearModelVersionBodyTypeFuelTransmissionCreateManyAndReturnArgs} args - Arguments to create many YearModelVersionBodyTypeFuelTransmissions.
     * @example
     * // Create many YearModelVersionBodyTypeFuelTransmissions
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many YearModelVersionBodyTypeFuelTransmissions and only return the `id`
     * const yearModelVersionBodyTypeFuelTransmissionWithIdOnly = await prisma.yearModelVersionBodyTypeFuelTransmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends YearModelVersionBodyTypeFuelTransmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a YearModelVersionBodyTypeFuelTransmission.
     * @param {YearModelVersionBodyTypeFuelTransmissionDeleteArgs} args - Arguments to delete one YearModelVersionBodyTypeFuelTransmission.
     * @example
     * // Delete one YearModelVersionBodyTypeFuelTransmission
     * const YearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.delete({
     *   where: {
     *     // ... filter to delete one YearModelVersionBodyTypeFuelTransmission
     *   }
     * })
     * 
     */
    delete<T extends YearModelVersionBodyTypeFuelTransmissionDeleteArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionDeleteArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one YearModelVersionBodyTypeFuelTransmission.
     * @param {YearModelVersionBodyTypeFuelTransmissionUpdateArgs} args - Arguments to update one YearModelVersionBodyTypeFuelTransmission.
     * @example
     * // Update one YearModelVersionBodyTypeFuelTransmission
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends YearModelVersionBodyTypeFuelTransmissionUpdateArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionUpdateArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more YearModelVersionBodyTypeFuelTransmissions.
     * @param {YearModelVersionBodyTypeFuelTransmissionDeleteManyArgs} args - Arguments to filter YearModelVersionBodyTypeFuelTransmissions to delete.
     * @example
     * // Delete a few YearModelVersionBodyTypeFuelTransmissions
     * const { count } = await prisma.yearModelVersionBodyTypeFuelTransmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends YearModelVersionBodyTypeFuelTransmissionDeleteManyArgs>(args?: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersionBodyTypeFuelTransmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many YearModelVersionBodyTypeFuelTransmissions
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends YearModelVersionBodyTypeFuelTransmissionUpdateManyArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more YearModelVersionBodyTypeFuelTransmissions and returns the data updated in the database.
     * @param {YearModelVersionBodyTypeFuelTransmissionUpdateManyAndReturnArgs} args - Arguments to update many YearModelVersionBodyTypeFuelTransmissions.
     * @example
     * // Update many YearModelVersionBodyTypeFuelTransmissions
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more YearModelVersionBodyTypeFuelTransmissions and only return the `id`
     * const yearModelVersionBodyTypeFuelTransmissionWithIdOnly = await prisma.yearModelVersionBodyTypeFuelTransmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends YearModelVersionBodyTypeFuelTransmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one YearModelVersionBodyTypeFuelTransmission.
     * @param {YearModelVersionBodyTypeFuelTransmissionUpsertArgs} args - Arguments to update or create a YearModelVersionBodyTypeFuelTransmission.
     * @example
     * // Update or create a YearModelVersionBodyTypeFuelTransmission
     * const yearModelVersionBodyTypeFuelTransmission = await prisma.yearModelVersionBodyTypeFuelTransmission.upsert({
     *   create: {
     *     // ... data to create a YearModelVersionBodyTypeFuelTransmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the YearModelVersionBodyTypeFuelTransmission we want to update
     *   }
     * })
     */
    upsert<T extends YearModelVersionBodyTypeFuelTransmissionUpsertArgs>(args: SelectSubset<T, YearModelVersionBodyTypeFuelTransmissionUpsertArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelTransmissionClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of YearModelVersionBodyTypeFuelTransmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionCountArgs} args - Arguments to filter YearModelVersionBodyTypeFuelTransmissions to count.
     * @example
     * // Count the number of YearModelVersionBodyTypeFuelTransmissions
     * const count = await prisma.yearModelVersionBodyTypeFuelTransmission.count({
     *   where: {
     *     // ... the filter for the YearModelVersionBodyTypeFuelTransmissions we want to count
     *   }
     * })
    **/
    count<T extends YearModelVersionBodyTypeFuelTransmissionCountArgs>(
      args?: Subset<T, YearModelVersionBodyTypeFuelTransmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], YearModelVersionBodyTypeFuelTransmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a YearModelVersionBodyTypeFuelTransmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends YearModelVersionBodyTypeFuelTransmissionAggregateArgs>(args: Subset<T, YearModelVersionBodyTypeFuelTransmissionAggregateArgs>): Prisma.PrismaPromise<GetYearModelVersionBodyTypeFuelTransmissionAggregateType<T>>

    /**
     * Group by YearModelVersionBodyTypeFuelTransmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {YearModelVersionBodyTypeFuelTransmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends YearModelVersionBodyTypeFuelTransmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: YearModelVersionBodyTypeFuelTransmissionGroupByArgs['orderBy'] }
        : { orderBy?: YearModelVersionBodyTypeFuelTransmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, YearModelVersionBodyTypeFuelTransmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetYearModelVersionBodyTypeFuelTransmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the YearModelVersionBodyTypeFuelTransmission model
   */
  readonly fields: YearModelVersionBodyTypeFuelTransmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for YearModelVersionBodyTypeFuelTransmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__YearModelVersionBodyTypeFuelTransmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersionBodyTypeFuel<T extends YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, YearModelVersionBodyTypeFuelDefaultArgs<ExtArgs>>): Prisma__YearModelVersionBodyTypeFuelClient<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transmissionType<T extends TransmissionTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransmissionTypeDefaultArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the YearModelVersionBodyTypeFuelTransmission model
   */
  interface YearModelVersionBodyTypeFuelTransmissionFieldRefs {
    readonly id: FieldRef<"YearModelVersionBodyTypeFuelTransmission", 'Int'>
    readonly createdAt: FieldRef<"YearModelVersionBodyTypeFuelTransmission", 'DateTime'>
    readonly updatedAt: FieldRef<"YearModelVersionBodyTypeFuelTransmission", 'DateTime'>
    readonly yearModelVersionBodyTypeFuelId: FieldRef<"YearModelVersionBodyTypeFuelTransmission", 'Int'>
    readonly transmissionTypeId: FieldRef<"YearModelVersionBodyTypeFuelTransmission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * YearModelVersionBodyTypeFuelTransmission findUnique
   */
  export type YearModelVersionBodyTypeFuelTransmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuelTransmission to fetch.
     */
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission findUniqueOrThrow
   */
  export type YearModelVersionBodyTypeFuelTransmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuelTransmission to fetch.
     */
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission findFirst
   */
  export type YearModelVersionBodyTypeFuelTransmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuelTransmission to fetch.
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuelTransmissions to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersionBodyTypeFuelTransmissions.
     */
    cursor?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuelTransmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuelTransmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersionBodyTypeFuelTransmissions.
     */
    distinct?: YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum | YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission findFirstOrThrow
   */
  export type YearModelVersionBodyTypeFuelTransmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuelTransmission to fetch.
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuelTransmissions to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for YearModelVersionBodyTypeFuelTransmissions.
     */
    cursor?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuelTransmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuelTransmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of YearModelVersionBodyTypeFuelTransmissions.
     */
    distinct?: YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum | YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission findMany
   */
  export type YearModelVersionBodyTypeFuelTransmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * Filter, which YearModelVersionBodyTypeFuelTransmissions to fetch.
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of YearModelVersionBodyTypeFuelTransmissions to fetch.
     */
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing YearModelVersionBodyTypeFuelTransmissions.
     */
    cursor?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` YearModelVersionBodyTypeFuelTransmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` YearModelVersionBodyTypeFuelTransmissions.
     */
    skip?: number
    distinct?: YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum | YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum[]
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission create
   */
  export type YearModelVersionBodyTypeFuelTransmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a YearModelVersionBodyTypeFuelTransmission.
     */
    data: XOR<YearModelVersionBodyTypeFuelTransmissionCreateInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateInput>
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission createMany
   */
  export type YearModelVersionBodyTypeFuelTransmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many YearModelVersionBodyTypeFuelTransmissions.
     */
    data: YearModelVersionBodyTypeFuelTransmissionCreateManyInput | YearModelVersionBodyTypeFuelTransmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission createManyAndReturn
   */
  export type YearModelVersionBodyTypeFuelTransmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * The data used to create many YearModelVersionBodyTypeFuelTransmissions.
     */
    data: YearModelVersionBodyTypeFuelTransmissionCreateManyInput | YearModelVersionBodyTypeFuelTransmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission update
   */
  export type YearModelVersionBodyTypeFuelTransmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a YearModelVersionBodyTypeFuelTransmission.
     */
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateInput>
    /**
     * Choose, which YearModelVersionBodyTypeFuelTransmission to update.
     */
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission updateMany
   */
  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update YearModelVersionBodyTypeFuelTransmissions.
     */
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateManyMutationInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersionBodyTypeFuelTransmissions to update
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * Limit how many YearModelVersionBodyTypeFuelTransmissions to update.
     */
    limit?: number
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission updateManyAndReturn
   */
  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * The data used to update YearModelVersionBodyTypeFuelTransmissions.
     */
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateManyMutationInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyInput>
    /**
     * Filter which YearModelVersionBodyTypeFuelTransmissions to update
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * Limit how many YearModelVersionBodyTypeFuelTransmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission upsert
   */
  export type YearModelVersionBodyTypeFuelTransmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the YearModelVersionBodyTypeFuelTransmission to update in case it exists.
     */
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    /**
     * In case the YearModelVersionBodyTypeFuelTransmission found by the `where` argument doesn't exist, create a new YearModelVersionBodyTypeFuelTransmission with this data.
     */
    create: XOR<YearModelVersionBodyTypeFuelTransmissionCreateInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateInput>
    /**
     * In case the YearModelVersionBodyTypeFuelTransmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateInput>
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission delete
   */
  export type YearModelVersionBodyTypeFuelTransmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    /**
     * Filter which YearModelVersionBodyTypeFuelTransmission to delete.
     */
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission deleteMany
   */
  export type YearModelVersionBodyTypeFuelTransmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which YearModelVersionBodyTypeFuelTransmissions to delete
     */
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    /**
     * Limit how many YearModelVersionBodyTypeFuelTransmissions to delete.
     */
    limit?: number
  }

  /**
   * YearModelVersionBodyTypeFuelTransmission without action
   */
  export type YearModelVersionBodyTypeFuelTransmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
  }


  /**
   * Model TransmissionType
   */

  export type AggregateTransmissionType = {
    _count: TransmissionTypeCountAggregateOutputType | null
    _avg: TransmissionTypeAvgAggregateOutputType | null
    _sum: TransmissionTypeSumAggregateOutputType | null
    _min: TransmissionTypeMinAggregateOutputType | null
    _max: TransmissionTypeMaxAggregateOutputType | null
  }

  export type TransmissionTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type TransmissionTypeSumAggregateOutputType = {
    id: number | null
  }

  export type TransmissionTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransmissionTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransmissionTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransmissionTypeAvgAggregateInputType = {
    id?: true
  }

  export type TransmissionTypeSumAggregateInputType = {
    id?: true
  }

  export type TransmissionTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransmissionTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransmissionTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransmissionTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransmissionType to aggregate.
     */
    where?: TransmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransmissionTypes to fetch.
     */
    orderBy?: TransmissionTypeOrderByWithRelationInput | TransmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransmissionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransmissionTypes
    **/
    _count?: true | TransmissionTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransmissionTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransmissionTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransmissionTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransmissionTypeMaxAggregateInputType
  }

  export type GetTransmissionTypeAggregateType<T extends TransmissionTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateTransmissionType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransmissionType[P]>
      : GetScalarType<T[P], AggregateTransmissionType[P]>
  }




  export type TransmissionTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransmissionTypeWhereInput
    orderBy?: TransmissionTypeOrderByWithAggregationInput | TransmissionTypeOrderByWithAggregationInput[]
    by: TransmissionTypeScalarFieldEnum[] | TransmissionTypeScalarFieldEnum
    having?: TransmissionTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransmissionTypeCountAggregateInputType | true
    _avg?: TransmissionTypeAvgAggregateInputType
    _sum?: TransmissionTypeSumAggregateInputType
    _min?: TransmissionTypeMinAggregateInputType
    _max?: TransmissionTypeMaxAggregateInputType
  }

  export type TransmissionTypeGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TransmissionTypeCountAggregateOutputType | null
    _avg: TransmissionTypeAvgAggregateOutputType | null
    _sum: TransmissionTypeSumAggregateOutputType | null
    _min: TransmissionTypeMinAggregateOutputType | null
    _max: TransmissionTypeMaxAggregateOutputType | null
  }

  type GetTransmissionTypeGroupByPayload<T extends TransmissionTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransmissionTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransmissionTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransmissionTypeGroupByOutputType[P]>
            : GetScalarType<T[P], TransmissionTypeGroupByOutputType[P]>
        }
      >
    >


  export type TransmissionTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    yearModelVersionBodyTypeFuelTransmissions?: boolean | TransmissionType$yearModelVersionBodyTypeFuelTransmissionsArgs<ExtArgs>
    vehicleOffers?: boolean | TransmissionType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | TransmissionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transmissionType"]>

  export type TransmissionTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transmissionType"]>

  export type TransmissionTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transmissionType"]>

  export type TransmissionTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransmissionTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["transmissionType"]>
  export type TransmissionTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    yearModelVersionBodyTypeFuelTransmissions?: boolean | TransmissionType$yearModelVersionBodyTypeFuelTransmissionsArgs<ExtArgs>
    vehicleOffers?: boolean | TransmissionType$vehicleOffersArgs<ExtArgs>
    _count?: boolean | TransmissionTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransmissionTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TransmissionTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TransmissionTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransmissionType"
    objects: {
      yearModelVersionBodyTypeFuelTransmissions: Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>[]
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transmissionType"]>
    composites: {}
  }

  type TransmissionTypeGetPayload<S extends boolean | null | undefined | TransmissionTypeDefaultArgs> = $Result.GetResult<Prisma.$TransmissionTypePayload, S>

  type TransmissionTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransmissionTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransmissionTypeCountAggregateInputType | true
    }

  export interface TransmissionTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransmissionType'], meta: { name: 'TransmissionType' } }
    /**
     * Find zero or one TransmissionType that matches the filter.
     * @param {TransmissionTypeFindUniqueArgs} args - Arguments to find a TransmissionType
     * @example
     * // Get one TransmissionType
     * const transmissionType = await prisma.transmissionType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransmissionTypeFindUniqueArgs>(args: SelectSubset<T, TransmissionTypeFindUniqueArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransmissionType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransmissionTypeFindUniqueOrThrowArgs} args - Arguments to find a TransmissionType
     * @example
     * // Get one TransmissionType
     * const transmissionType = await prisma.transmissionType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransmissionTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TransmissionTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransmissionType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeFindFirstArgs} args - Arguments to find a TransmissionType
     * @example
     * // Get one TransmissionType
     * const transmissionType = await prisma.transmissionType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransmissionTypeFindFirstArgs>(args?: SelectSubset<T, TransmissionTypeFindFirstArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransmissionType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeFindFirstOrThrowArgs} args - Arguments to find a TransmissionType
     * @example
     * // Get one TransmissionType
     * const transmissionType = await prisma.transmissionType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransmissionTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TransmissionTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransmissionTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransmissionTypes
     * const transmissionTypes = await prisma.transmissionType.findMany()
     * 
     * // Get first 10 TransmissionTypes
     * const transmissionTypes = await prisma.transmissionType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transmissionTypeWithIdOnly = await prisma.transmissionType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransmissionTypeFindManyArgs>(args?: SelectSubset<T, TransmissionTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransmissionType.
     * @param {TransmissionTypeCreateArgs} args - Arguments to create a TransmissionType.
     * @example
     * // Create one TransmissionType
     * const TransmissionType = await prisma.transmissionType.create({
     *   data: {
     *     // ... data to create a TransmissionType
     *   }
     * })
     * 
     */
    create<T extends TransmissionTypeCreateArgs>(args: SelectSubset<T, TransmissionTypeCreateArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransmissionTypes.
     * @param {TransmissionTypeCreateManyArgs} args - Arguments to create many TransmissionTypes.
     * @example
     * // Create many TransmissionTypes
     * const transmissionType = await prisma.transmissionType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransmissionTypeCreateManyArgs>(args?: SelectSubset<T, TransmissionTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransmissionTypes and returns the data saved in the database.
     * @param {TransmissionTypeCreateManyAndReturnArgs} args - Arguments to create many TransmissionTypes.
     * @example
     * // Create many TransmissionTypes
     * const transmissionType = await prisma.transmissionType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransmissionTypes and only return the `id`
     * const transmissionTypeWithIdOnly = await prisma.transmissionType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransmissionTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TransmissionTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransmissionType.
     * @param {TransmissionTypeDeleteArgs} args - Arguments to delete one TransmissionType.
     * @example
     * // Delete one TransmissionType
     * const TransmissionType = await prisma.transmissionType.delete({
     *   where: {
     *     // ... filter to delete one TransmissionType
     *   }
     * })
     * 
     */
    delete<T extends TransmissionTypeDeleteArgs>(args: SelectSubset<T, TransmissionTypeDeleteArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransmissionType.
     * @param {TransmissionTypeUpdateArgs} args - Arguments to update one TransmissionType.
     * @example
     * // Update one TransmissionType
     * const transmissionType = await prisma.transmissionType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransmissionTypeUpdateArgs>(args: SelectSubset<T, TransmissionTypeUpdateArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransmissionTypes.
     * @param {TransmissionTypeDeleteManyArgs} args - Arguments to filter TransmissionTypes to delete.
     * @example
     * // Delete a few TransmissionTypes
     * const { count } = await prisma.transmissionType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransmissionTypeDeleteManyArgs>(args?: SelectSubset<T, TransmissionTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransmissionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransmissionTypes
     * const transmissionType = await prisma.transmissionType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransmissionTypeUpdateManyArgs>(args: SelectSubset<T, TransmissionTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransmissionTypes and returns the data updated in the database.
     * @param {TransmissionTypeUpdateManyAndReturnArgs} args - Arguments to update many TransmissionTypes.
     * @example
     * // Update many TransmissionTypes
     * const transmissionType = await prisma.transmissionType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransmissionTypes and only return the `id`
     * const transmissionTypeWithIdOnly = await prisma.transmissionType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransmissionTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, TransmissionTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransmissionType.
     * @param {TransmissionTypeUpsertArgs} args - Arguments to update or create a TransmissionType.
     * @example
     * // Update or create a TransmissionType
     * const transmissionType = await prisma.transmissionType.upsert({
     *   create: {
     *     // ... data to create a TransmissionType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransmissionType we want to update
     *   }
     * })
     */
    upsert<T extends TransmissionTypeUpsertArgs>(args: SelectSubset<T, TransmissionTypeUpsertArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransmissionTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeCountArgs} args - Arguments to filter TransmissionTypes to count.
     * @example
     * // Count the number of TransmissionTypes
     * const count = await prisma.transmissionType.count({
     *   where: {
     *     // ... the filter for the TransmissionTypes we want to count
     *   }
     * })
    **/
    count<T extends TransmissionTypeCountArgs>(
      args?: Subset<T, TransmissionTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransmissionTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransmissionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransmissionTypeAggregateArgs>(args: Subset<T, TransmissionTypeAggregateArgs>): Prisma.PrismaPromise<GetTransmissionTypeAggregateType<T>>

    /**
     * Group by TransmissionType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransmissionTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransmissionTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransmissionTypeGroupByArgs['orderBy'] }
        : { orderBy?: TransmissionTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransmissionTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransmissionTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransmissionType model
   */
  readonly fields: TransmissionTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransmissionType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransmissionTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    yearModelVersionBodyTypeFuelTransmissions<T extends TransmissionType$yearModelVersionBodyTypeFuelTransmissionsArgs<ExtArgs> = {}>(args?: Subset<T, TransmissionType$yearModelVersionBodyTypeFuelTransmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$YearModelVersionBodyTypeFuelTransmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleOffers<T extends TransmissionType$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, TransmissionType$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransmissionType model
   */
  interface TransmissionTypeFieldRefs {
    readonly id: FieldRef<"TransmissionType", 'Int'>
    readonly name: FieldRef<"TransmissionType", 'String'>
    readonly createdAt: FieldRef<"TransmissionType", 'DateTime'>
    readonly updatedAt: FieldRef<"TransmissionType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransmissionType findUnique
   */
  export type TransmissionTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which TransmissionType to fetch.
     */
    where: TransmissionTypeWhereUniqueInput
  }

  /**
   * TransmissionType findUniqueOrThrow
   */
  export type TransmissionTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which TransmissionType to fetch.
     */
    where: TransmissionTypeWhereUniqueInput
  }

  /**
   * TransmissionType findFirst
   */
  export type TransmissionTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which TransmissionType to fetch.
     */
    where?: TransmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransmissionTypes to fetch.
     */
    orderBy?: TransmissionTypeOrderByWithRelationInput | TransmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransmissionTypes.
     */
    cursor?: TransmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransmissionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransmissionTypes.
     */
    distinct?: TransmissionTypeScalarFieldEnum | TransmissionTypeScalarFieldEnum[]
  }

  /**
   * TransmissionType findFirstOrThrow
   */
  export type TransmissionTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which TransmissionType to fetch.
     */
    where?: TransmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransmissionTypes to fetch.
     */
    orderBy?: TransmissionTypeOrderByWithRelationInput | TransmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransmissionTypes.
     */
    cursor?: TransmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransmissionTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransmissionTypes.
     */
    distinct?: TransmissionTypeScalarFieldEnum | TransmissionTypeScalarFieldEnum[]
  }

  /**
   * TransmissionType findMany
   */
  export type TransmissionTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * Filter, which TransmissionTypes to fetch.
     */
    where?: TransmissionTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransmissionTypes to fetch.
     */
    orderBy?: TransmissionTypeOrderByWithRelationInput | TransmissionTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransmissionTypes.
     */
    cursor?: TransmissionTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransmissionTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransmissionTypes.
     */
    skip?: number
    distinct?: TransmissionTypeScalarFieldEnum | TransmissionTypeScalarFieldEnum[]
  }

  /**
   * TransmissionType create
   */
  export type TransmissionTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a TransmissionType.
     */
    data: XOR<TransmissionTypeCreateInput, TransmissionTypeUncheckedCreateInput>
  }

  /**
   * TransmissionType createMany
   */
  export type TransmissionTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransmissionTypes.
     */
    data: TransmissionTypeCreateManyInput | TransmissionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransmissionType createManyAndReturn
   */
  export type TransmissionTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * The data used to create many TransmissionTypes.
     */
    data: TransmissionTypeCreateManyInput | TransmissionTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransmissionType update
   */
  export type TransmissionTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a TransmissionType.
     */
    data: XOR<TransmissionTypeUpdateInput, TransmissionTypeUncheckedUpdateInput>
    /**
     * Choose, which TransmissionType to update.
     */
    where: TransmissionTypeWhereUniqueInput
  }

  /**
   * TransmissionType updateMany
   */
  export type TransmissionTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransmissionTypes.
     */
    data: XOR<TransmissionTypeUpdateManyMutationInput, TransmissionTypeUncheckedUpdateManyInput>
    /**
     * Filter which TransmissionTypes to update
     */
    where?: TransmissionTypeWhereInput
    /**
     * Limit how many TransmissionTypes to update.
     */
    limit?: number
  }

  /**
   * TransmissionType updateManyAndReturn
   */
  export type TransmissionTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * The data used to update TransmissionTypes.
     */
    data: XOR<TransmissionTypeUpdateManyMutationInput, TransmissionTypeUncheckedUpdateManyInput>
    /**
     * Filter which TransmissionTypes to update
     */
    where?: TransmissionTypeWhereInput
    /**
     * Limit how many TransmissionTypes to update.
     */
    limit?: number
  }

  /**
   * TransmissionType upsert
   */
  export type TransmissionTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the TransmissionType to update in case it exists.
     */
    where: TransmissionTypeWhereUniqueInput
    /**
     * In case the TransmissionType found by the `where` argument doesn't exist, create a new TransmissionType with this data.
     */
    create: XOR<TransmissionTypeCreateInput, TransmissionTypeUncheckedCreateInput>
    /**
     * In case the TransmissionType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransmissionTypeUpdateInput, TransmissionTypeUncheckedUpdateInput>
  }

  /**
   * TransmissionType delete
   */
  export type TransmissionTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    /**
     * Filter which TransmissionType to delete.
     */
    where: TransmissionTypeWhereUniqueInput
  }

  /**
   * TransmissionType deleteMany
   */
  export type TransmissionTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransmissionTypes to delete
     */
    where?: TransmissionTypeWhereInput
    /**
     * Limit how many TransmissionTypes to delete.
     */
    limit?: number
  }

  /**
   * TransmissionType.yearModelVersionBodyTypeFuelTransmissions
   */
  export type TransmissionType$yearModelVersionBodyTypeFuelTransmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the YearModelVersionBodyTypeFuelTransmission
     */
    select?: YearModelVersionBodyTypeFuelTransmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the YearModelVersionBodyTypeFuelTransmission
     */
    omit?: YearModelVersionBodyTypeFuelTransmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: YearModelVersionBodyTypeFuelTransmissionInclude<ExtArgs> | null
    where?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    orderBy?: YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput | YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput[]
    cursor?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum | YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum[]
  }

  /**
   * TransmissionType.vehicleOffers
   */
  export type TransmissionType$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * TransmissionType without action
   */
  export type TransmissionTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
  }


  /**
   * Model Color
   */

  export type AggregateColor = {
    _count: ColorCountAggregateOutputType | null
    _avg: ColorAvgAggregateOutputType | null
    _sum: ColorSumAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  export type ColorAvgAggregateOutputType = {
    id: number | null
  }

  export type ColorSumAggregateOutputType = {
    id: number | null
  }

  export type ColorMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ColorCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ColorAvgAggregateInputType = {
    id?: true
  }

  export type ColorSumAggregateInputType = {
    id?: true
  }

  export type ColorMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColorMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ColorCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ColorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Color to aggregate.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Colors
    **/
    _count?: true | ColorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ColorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ColorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ColorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ColorMaxAggregateInputType
  }

  export type GetColorAggregateType<T extends ColorAggregateArgs> = {
        [P in keyof T & keyof AggregateColor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateColor[P]>
      : GetScalarType<T[P], AggregateColor[P]>
  }




  export type ColorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ColorWhereInput
    orderBy?: ColorOrderByWithAggregationInput | ColorOrderByWithAggregationInput[]
    by: ColorScalarFieldEnum[] | ColorScalarFieldEnum
    having?: ColorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ColorCountAggregateInputType | true
    _avg?: ColorAvgAggregateInputType
    _sum?: ColorSumAggregateInputType
    _min?: ColorMinAggregateInputType
    _max?: ColorMaxAggregateInputType
  }

  export type ColorGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ColorCountAggregateOutputType | null
    _avg: ColorAvgAggregateOutputType | null
    _sum: ColorSumAggregateOutputType | null
    _min: ColorMinAggregateOutputType | null
    _max: ColorMaxAggregateOutputType | null
  }

  type GetColorGroupByPayload<T extends ColorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ColorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ColorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ColorGroupByOutputType[P]>
            : GetScalarType<T[P], ColorGroupByOutputType[P]>
        }
      >
    >


  export type ColorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleOffers?: boolean | Color$vehicleOffersArgs<ExtArgs>
    _count?: boolean | ColorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["color"]>

  export type ColorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["color"]>

  export type ColorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["color"]>

  export type ColorSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ColorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["color"]>
  export type ColorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleOffers?: boolean | Color$vehicleOffersArgs<ExtArgs>
    _count?: boolean | ColorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ColorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ColorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ColorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Color"
    objects: {
      vehicleOffers: Prisma.$VehicleOfferPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["color"]>
    composites: {}
  }

  type ColorGetPayload<S extends boolean | null | undefined | ColorDefaultArgs> = $Result.GetResult<Prisma.$ColorPayload, S>

  type ColorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ColorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ColorCountAggregateInputType | true
    }

  export interface ColorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Color'], meta: { name: 'Color' } }
    /**
     * Find zero or one Color that matches the filter.
     * @param {ColorFindUniqueArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ColorFindUniqueArgs>(args: SelectSubset<T, ColorFindUniqueArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Color that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ColorFindUniqueOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ColorFindUniqueOrThrowArgs>(args: SelectSubset<T, ColorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Color that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindFirstArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ColorFindFirstArgs>(args?: SelectSubset<T, ColorFindFirstArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Color that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindFirstOrThrowArgs} args - Arguments to find a Color
     * @example
     * // Get one Color
     * const color = await prisma.color.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ColorFindFirstOrThrowArgs>(args?: SelectSubset<T, ColorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Colors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Colors
     * const colors = await prisma.color.findMany()
     * 
     * // Get first 10 Colors
     * const colors = await prisma.color.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const colorWithIdOnly = await prisma.color.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ColorFindManyArgs>(args?: SelectSubset<T, ColorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Color.
     * @param {ColorCreateArgs} args - Arguments to create a Color.
     * @example
     * // Create one Color
     * const Color = await prisma.color.create({
     *   data: {
     *     // ... data to create a Color
     *   }
     * })
     * 
     */
    create<T extends ColorCreateArgs>(args: SelectSubset<T, ColorCreateArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Colors.
     * @param {ColorCreateManyArgs} args - Arguments to create many Colors.
     * @example
     * // Create many Colors
     * const color = await prisma.color.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ColorCreateManyArgs>(args?: SelectSubset<T, ColorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Colors and returns the data saved in the database.
     * @param {ColorCreateManyAndReturnArgs} args - Arguments to create many Colors.
     * @example
     * // Create many Colors
     * const color = await prisma.color.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Colors and only return the `id`
     * const colorWithIdOnly = await prisma.color.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ColorCreateManyAndReturnArgs>(args?: SelectSubset<T, ColorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Color.
     * @param {ColorDeleteArgs} args - Arguments to delete one Color.
     * @example
     * // Delete one Color
     * const Color = await prisma.color.delete({
     *   where: {
     *     // ... filter to delete one Color
     *   }
     * })
     * 
     */
    delete<T extends ColorDeleteArgs>(args: SelectSubset<T, ColorDeleteArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Color.
     * @param {ColorUpdateArgs} args - Arguments to update one Color.
     * @example
     * // Update one Color
     * const color = await prisma.color.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ColorUpdateArgs>(args: SelectSubset<T, ColorUpdateArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Colors.
     * @param {ColorDeleteManyArgs} args - Arguments to filter Colors to delete.
     * @example
     * // Delete a few Colors
     * const { count } = await prisma.color.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ColorDeleteManyArgs>(args?: SelectSubset<T, ColorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ColorUpdateManyArgs>(args: SelectSubset<T, ColorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Colors and returns the data updated in the database.
     * @param {ColorUpdateManyAndReturnArgs} args - Arguments to update many Colors.
     * @example
     * // Update many Colors
     * const color = await prisma.color.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Colors and only return the `id`
     * const colorWithIdOnly = await prisma.color.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ColorUpdateManyAndReturnArgs>(args: SelectSubset<T, ColorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Color.
     * @param {ColorUpsertArgs} args - Arguments to update or create a Color.
     * @example
     * // Update or create a Color
     * const color = await prisma.color.upsert({
     *   create: {
     *     // ... data to create a Color
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Color we want to update
     *   }
     * })
     */
    upsert<T extends ColorUpsertArgs>(args: SelectSubset<T, ColorUpsertArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Colors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorCountArgs} args - Arguments to filter Colors to count.
     * @example
     * // Count the number of Colors
     * const count = await prisma.color.count({
     *   where: {
     *     // ... the filter for the Colors we want to count
     *   }
     * })
    **/
    count<T extends ColorCountArgs>(
      args?: Subset<T, ColorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ColorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ColorAggregateArgs>(args: Subset<T, ColorAggregateArgs>): Prisma.PrismaPromise<GetColorAggregateType<T>>

    /**
     * Group by Color.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ColorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ColorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ColorGroupByArgs['orderBy'] }
        : { orderBy?: ColorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ColorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetColorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Color model
   */
  readonly fields: ColorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Color.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ColorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleOffers<T extends Color$vehicleOffersArgs<ExtArgs> = {}>(args?: Subset<T, Color$vehicleOffersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Color model
   */
  interface ColorFieldRefs {
    readonly id: FieldRef<"Color", 'Int'>
    readonly name: FieldRef<"Color", 'String'>
    readonly createdAt: FieldRef<"Color", 'DateTime'>
    readonly updatedAt: FieldRef<"Color", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Color findUnique
   */
  export type ColorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color findUniqueOrThrow
   */
  export type ColorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color findFirst
   */
  export type ColorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color findFirstOrThrow
   */
  export type ColorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Color to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Colors.
     */
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color findMany
   */
  export type ColorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter, which Colors to fetch.
     */
    where?: ColorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Colors to fetch.
     */
    orderBy?: ColorOrderByWithRelationInput | ColorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Colors.
     */
    cursor?: ColorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Colors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Colors.
     */
    skip?: number
    distinct?: ColorScalarFieldEnum | ColorScalarFieldEnum[]
  }

  /**
   * Color create
   */
  export type ColorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The data needed to create a Color.
     */
    data: XOR<ColorCreateInput, ColorUncheckedCreateInput>
  }

  /**
   * Color createMany
   */
  export type ColorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Colors.
     */
    data: ColorCreateManyInput | ColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Color createManyAndReturn
   */
  export type ColorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * The data used to create many Colors.
     */
    data: ColorCreateManyInput | ColorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Color update
   */
  export type ColorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The data needed to update a Color.
     */
    data: XOR<ColorUpdateInput, ColorUncheckedUpdateInput>
    /**
     * Choose, which Color to update.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color updateMany
   */
  export type ColorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to update.
     */
    limit?: number
  }

  /**
   * Color updateManyAndReturn
   */
  export type ColorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * The data used to update Colors.
     */
    data: XOR<ColorUpdateManyMutationInput, ColorUncheckedUpdateManyInput>
    /**
     * Filter which Colors to update
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to update.
     */
    limit?: number
  }

  /**
   * Color upsert
   */
  export type ColorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * The filter to search for the Color to update in case it exists.
     */
    where: ColorWhereUniqueInput
    /**
     * In case the Color found by the `where` argument doesn't exist, create a new Color with this data.
     */
    create: XOR<ColorCreateInput, ColorUncheckedCreateInput>
    /**
     * In case the Color was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ColorUpdateInput, ColorUncheckedUpdateInput>
  }

  /**
   * Color delete
   */
  export type ColorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    /**
     * Filter which Color to delete.
     */
    where: ColorWhereUniqueInput
  }

  /**
   * Color deleteMany
   */
  export type ColorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Colors to delete
     */
    where?: ColorWhereInput
    /**
     * Limit how many Colors to delete.
     */
    limit?: number
  }

  /**
   * Color.vehicleOffers
   */
  export type Color$vehicleOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    cursor?: VehicleOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * Color without action
   */
  export type ColorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
  }


  /**
   * Model VehicleImage
   */

  export type AggregateVehicleImage = {
    _count: VehicleImageCountAggregateOutputType | null
    _avg: VehicleImageAvgAggregateOutputType | null
    _sum: VehicleImageSumAggregateOutputType | null
    _min: VehicleImageMinAggregateOutputType | null
    _max: VehicleImageMaxAggregateOutputType | null
  }

  export type VehicleImageAvgAggregateOutputType = {
    id: number | null
    vehicleOfferId: number | null
  }

  export type VehicleImageSumAggregateOutputType = {
    id: number | null
    vehicleOfferId: number | null
  }

  export type VehicleImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleOfferId: number | null
  }

  export type VehicleImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicleOfferId: number | null
  }

  export type VehicleImageCountAggregateOutputType = {
    id: number
    url: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    vehicleOfferId: number
    _all: number
  }


  export type VehicleImageAvgAggregateInputType = {
    id?: true
    vehicleOfferId?: true
  }

  export type VehicleImageSumAggregateInputType = {
    id?: true
    vehicleOfferId?: true
  }

  export type VehicleImageMinAggregateInputType = {
    id?: true
    url?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    vehicleOfferId?: true
  }

  export type VehicleImageMaxAggregateInputType = {
    id?: true
    url?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    vehicleOfferId?: true
  }

  export type VehicleImageCountAggregateInputType = {
    id?: true
    url?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    vehicleOfferId?: true
    _all?: true
  }

  export type VehicleImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleImage to aggregate.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleImages
    **/
    _count?: true | VehicleImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleImageMaxAggregateInputType
  }

  export type GetVehicleImageAggregateType<T extends VehicleImageAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleImage[P]>
      : GetScalarType<T[P], AggregateVehicleImage[P]>
  }




  export type VehicleImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleImageWhereInput
    orderBy?: VehicleImageOrderByWithAggregationInput | VehicleImageOrderByWithAggregationInput[]
    by: VehicleImageScalarFieldEnum[] | VehicleImageScalarFieldEnum
    having?: VehicleImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleImageCountAggregateInputType | true
    _avg?: VehicleImageAvgAggregateInputType
    _sum?: VehicleImageSumAggregateInputType
    _min?: VehicleImageMinAggregateInputType
    _max?: VehicleImageMaxAggregateInputType
  }

  export type VehicleImageGroupByOutputType = {
    id: number
    url: string
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    vehicleOfferId: number
    _count: VehicleImageCountAggregateOutputType | null
    _avg: VehicleImageAvgAggregateOutputType | null
    _sum: VehicleImageSumAggregateOutputType | null
    _min: VehicleImageMinAggregateOutputType | null
    _max: VehicleImageMaxAggregateOutputType | null
  }

  type GetVehicleImageGroupByPayload<T extends VehicleImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleImageGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleImageGroupByOutputType[P]>
        }
      >
    >


  export type VehicleImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleOfferId?: boolean
    vehicleOffer?: boolean | VehicleOfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleImage"]>

  export type VehicleImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleOfferId?: boolean
    vehicleOffer?: boolean | VehicleOfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleImage"]>

  export type VehicleImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleOfferId?: boolean
    vehicleOffer?: boolean | VehicleOfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleImage"]>

  export type VehicleImageSelectScalar = {
    id?: boolean
    url?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicleOfferId?: boolean
  }

  export type VehicleImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "isPrimary" | "createdAt" | "updatedAt" | "vehicleOfferId", ExtArgs["result"]["vehicleImage"]>
  export type VehicleImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleOffer?: boolean | VehicleOfferDefaultArgs<ExtArgs>
  }
  export type VehicleImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleOffer?: boolean | VehicleOfferDefaultArgs<ExtArgs>
  }
  export type VehicleImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleOffer?: boolean | VehicleOfferDefaultArgs<ExtArgs>
  }

  export type $VehicleImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleImage"
    objects: {
      vehicleOffer: Prisma.$VehicleOfferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
      vehicleOfferId: number
    }, ExtArgs["result"]["vehicleImage"]>
    composites: {}
  }

  type VehicleImageGetPayload<S extends boolean | null | undefined | VehicleImageDefaultArgs> = $Result.GetResult<Prisma.$VehicleImagePayload, S>

  type VehicleImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleImageCountAggregateInputType | true
    }

  export interface VehicleImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleImage'], meta: { name: 'VehicleImage' } }
    /**
     * Find zero or one VehicleImage that matches the filter.
     * @param {VehicleImageFindUniqueArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleImageFindUniqueArgs>(args: SelectSubset<T, VehicleImageFindUniqueArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleImageFindUniqueOrThrowArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleImageFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageFindFirstArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleImageFindFirstArgs>(args?: SelectSubset<T, VehicleImageFindFirstArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageFindFirstOrThrowArgs} args - Arguments to find a VehicleImage
     * @example
     * // Get one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleImageFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleImages
     * const vehicleImages = await prisma.vehicleImage.findMany()
     * 
     * // Get first 10 VehicleImages
     * const vehicleImages = await prisma.vehicleImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleImageWithIdOnly = await prisma.vehicleImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleImageFindManyArgs>(args?: SelectSubset<T, VehicleImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleImage.
     * @param {VehicleImageCreateArgs} args - Arguments to create a VehicleImage.
     * @example
     * // Create one VehicleImage
     * const VehicleImage = await prisma.vehicleImage.create({
     *   data: {
     *     // ... data to create a VehicleImage
     *   }
     * })
     * 
     */
    create<T extends VehicleImageCreateArgs>(args: SelectSubset<T, VehicleImageCreateArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleImages.
     * @param {VehicleImageCreateManyArgs} args - Arguments to create many VehicleImages.
     * @example
     * // Create many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleImageCreateManyArgs>(args?: SelectSubset<T, VehicleImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleImages and returns the data saved in the database.
     * @param {VehicleImageCreateManyAndReturnArgs} args - Arguments to create many VehicleImages.
     * @example
     * // Create many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleImages and only return the `id`
     * const vehicleImageWithIdOnly = await prisma.vehicleImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleImageCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleImage.
     * @param {VehicleImageDeleteArgs} args - Arguments to delete one VehicleImage.
     * @example
     * // Delete one VehicleImage
     * const VehicleImage = await prisma.vehicleImage.delete({
     *   where: {
     *     // ... filter to delete one VehicleImage
     *   }
     * })
     * 
     */
    delete<T extends VehicleImageDeleteArgs>(args: SelectSubset<T, VehicleImageDeleteArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleImage.
     * @param {VehicleImageUpdateArgs} args - Arguments to update one VehicleImage.
     * @example
     * // Update one VehicleImage
     * const vehicleImage = await prisma.vehicleImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleImageUpdateArgs>(args: SelectSubset<T, VehicleImageUpdateArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleImages.
     * @param {VehicleImageDeleteManyArgs} args - Arguments to filter VehicleImages to delete.
     * @example
     * // Delete a few VehicleImages
     * const { count } = await prisma.vehicleImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleImageDeleteManyArgs>(args?: SelectSubset<T, VehicleImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleImageUpdateManyArgs>(args: SelectSubset<T, VehicleImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleImages and returns the data updated in the database.
     * @param {VehicleImageUpdateManyAndReturnArgs} args - Arguments to update many VehicleImages.
     * @example
     * // Update many VehicleImages
     * const vehicleImage = await prisma.vehicleImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleImages and only return the `id`
     * const vehicleImageWithIdOnly = await prisma.vehicleImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleImageUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleImage.
     * @param {VehicleImageUpsertArgs} args - Arguments to update or create a VehicleImage.
     * @example
     * // Update or create a VehicleImage
     * const vehicleImage = await prisma.vehicleImage.upsert({
     *   create: {
     *     // ... data to create a VehicleImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleImage we want to update
     *   }
     * })
     */
    upsert<T extends VehicleImageUpsertArgs>(args: SelectSubset<T, VehicleImageUpsertArgs<ExtArgs>>): Prisma__VehicleImageClient<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageCountArgs} args - Arguments to filter VehicleImages to count.
     * @example
     * // Count the number of VehicleImages
     * const count = await prisma.vehicleImage.count({
     *   where: {
     *     // ... the filter for the VehicleImages we want to count
     *   }
     * })
    **/
    count<T extends VehicleImageCountArgs>(
      args?: Subset<T, VehicleImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleImageAggregateArgs>(args: Subset<T, VehicleImageAggregateArgs>): Prisma.PrismaPromise<GetVehicleImageAggregateType<T>>

    /**
     * Group by VehicleImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleImageGroupByArgs['orderBy'] }
        : { orderBy?: VehicleImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleImage model
   */
  readonly fields: VehicleImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleOffer<T extends VehicleOfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOfferDefaultArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleImage model
   */
  interface VehicleImageFieldRefs {
    readonly id: FieldRef<"VehicleImage", 'Int'>
    readonly url: FieldRef<"VehicleImage", 'String'>
    readonly isPrimary: FieldRef<"VehicleImage", 'Boolean'>
    readonly createdAt: FieldRef<"VehicleImage", 'DateTime'>
    readonly updatedAt: FieldRef<"VehicleImage", 'DateTime'>
    readonly vehicleOfferId: FieldRef<"VehicleImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VehicleImage findUnique
   */
  export type VehicleImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage findUniqueOrThrow
   */
  export type VehicleImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage findFirst
   */
  export type VehicleImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleImages.
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleImages.
     */
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleImage findFirstOrThrow
   */
  export type VehicleImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImage to fetch.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleImages.
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleImages.
     */
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleImage findMany
   */
  export type VehicleImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter, which VehicleImages to fetch.
     */
    where?: VehicleImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleImages to fetch.
     */
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleImages.
     */
    cursor?: VehicleImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleImages.
     */
    skip?: number
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleImage create
   */
  export type VehicleImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleImage.
     */
    data: XOR<VehicleImageCreateInput, VehicleImageUncheckedCreateInput>
  }

  /**
   * VehicleImage createMany
   */
  export type VehicleImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleImages.
     */
    data: VehicleImageCreateManyInput | VehicleImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleImage createManyAndReturn
   */
  export type VehicleImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleImages.
     */
    data: VehicleImageCreateManyInput | VehicleImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleImage update
   */
  export type VehicleImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleImage.
     */
    data: XOR<VehicleImageUpdateInput, VehicleImageUncheckedUpdateInput>
    /**
     * Choose, which VehicleImage to update.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage updateMany
   */
  export type VehicleImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleImages.
     */
    data: XOR<VehicleImageUpdateManyMutationInput, VehicleImageUncheckedUpdateManyInput>
    /**
     * Filter which VehicleImages to update
     */
    where?: VehicleImageWhereInput
    /**
     * Limit how many VehicleImages to update.
     */
    limit?: number
  }

  /**
   * VehicleImage updateManyAndReturn
   */
  export type VehicleImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * The data used to update VehicleImages.
     */
    data: XOR<VehicleImageUpdateManyMutationInput, VehicleImageUncheckedUpdateManyInput>
    /**
     * Filter which VehicleImages to update
     */
    where?: VehicleImageWhereInput
    /**
     * Limit how many VehicleImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleImage upsert
   */
  export type VehicleImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleImage to update in case it exists.
     */
    where: VehicleImageWhereUniqueInput
    /**
     * In case the VehicleImage found by the `where` argument doesn't exist, create a new VehicleImage with this data.
     */
    create: XOR<VehicleImageCreateInput, VehicleImageUncheckedCreateInput>
    /**
     * In case the VehicleImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleImageUpdateInput, VehicleImageUncheckedUpdateInput>
  }

  /**
   * VehicleImage delete
   */
  export type VehicleImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    /**
     * Filter which VehicleImage to delete.
     */
    where: VehicleImageWhereUniqueInput
  }

  /**
   * VehicleImage deleteMany
   */
  export type VehicleImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleImages to delete
     */
    where?: VehicleImageWhereInput
    /**
     * Limit how many VehicleImages to delete.
     */
    limit?: number
  }

  /**
   * VehicleImage without action
   */
  export type VehicleImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
  }


  /**
   * Model VehicleOffer
   */

  export type AggregateVehicleOffer = {
    _count: VehicleOfferCountAggregateOutputType | null
    _avg: VehicleOfferAvgAggregateOutputType | null
    _sum: VehicleOfferSumAggregateOutputType | null
    _min: VehicleOfferMinAggregateOutputType | null
    _max: VehicleOfferMaxAggregateOutputType | null
  }

  export type VehicleOfferAvgAggregateOutputType = {
    id: number | null
    year: number | null
    kilometer: number | null
    accidentAmount: number | null
    price: number | null
    vehicleTypeId: number | null
    vehicleYearId: number | null
    brandId: number | null
    modelId: number | null
    versionId: number | null
    bodyTypeId: number | null
    fuelTypeId: number | null
    transmissionTypeId: number | null
    colorId: number | null
  }

  export type VehicleOfferSumAggregateOutputType = {
    id: number | null
    year: number | null
    kilometer: number | null
    accidentAmount: number | null
    price: number | null
    vehicleTypeId: number | null
    vehicleYearId: number | null
    brandId: number | null
    modelId: number | null
    versionId: number | null
    bodyTypeId: number | null
    fuelTypeId: number | null
    transmissionTypeId: number | null
    colorId: number | null
  }

  export type VehicleOfferMinAggregateOutputType = {
    id: number | null
    year: number | null
    kilometer: number | null
    accidentStatus: string | null
    accidentAmount: number | null
    status: string | null
    price: number | null
    displayValues: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
    vehicleTypeId: number | null
    vehicleYearId: number | null
    brandId: number | null
    modelId: number | null
    versionId: number | null
    bodyTypeId: number | null
    fuelTypeId: number | null
    transmissionTypeId: number | null
    colorId: number | null
    notes: string | null
    adminNotes: string | null
    description: string | null
    registrationDate: Date | null
    listingStatus: string | null
  }

  export type VehicleOfferMaxAggregateOutputType = {
    id: number | null
    year: number | null
    kilometer: number | null
    accidentStatus: string | null
    accidentAmount: number | null
    status: string | null
    price: number | null
    displayValues: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    processedAt: Date | null
    vehicleTypeId: number | null
    vehicleYearId: number | null
    brandId: number | null
    modelId: number | null
    versionId: number | null
    bodyTypeId: number | null
    fuelTypeId: number | null
    transmissionTypeId: number | null
    colorId: number | null
    notes: string | null
    adminNotes: string | null
    description: string | null
    registrationDate: Date | null
    listingStatus: string | null
  }

  export type VehicleOfferCountAggregateOutputType = {
    id: number
    year: number
    kilometer: number
    accidentStatus: number
    accidentAmount: number
    status: number
    price: number
    displayValues: number
    userId: number
    createdAt: number
    updatedAt: number
    processedAt: number
    vehicleTypeId: number
    vehicleYearId: number
    brandId: number
    modelId: number
    versionId: number
    bodyTypeId: number
    fuelTypeId: number
    transmissionTypeId: number
    colorId: number
    notes: number
    adminNotes: number
    description: number
    registrationDate: number
    listingStatus: number
    _all: number
  }


  export type VehicleOfferAvgAggregateInputType = {
    id?: true
    year?: true
    kilometer?: true
    accidentAmount?: true
    price?: true
    vehicleTypeId?: true
    vehicleYearId?: true
    brandId?: true
    modelId?: true
    versionId?: true
    bodyTypeId?: true
    fuelTypeId?: true
    transmissionTypeId?: true
    colorId?: true
  }

  export type VehicleOfferSumAggregateInputType = {
    id?: true
    year?: true
    kilometer?: true
    accidentAmount?: true
    price?: true
    vehicleTypeId?: true
    vehicleYearId?: true
    brandId?: true
    modelId?: true
    versionId?: true
    bodyTypeId?: true
    fuelTypeId?: true
    transmissionTypeId?: true
    colorId?: true
  }

  export type VehicleOfferMinAggregateInputType = {
    id?: true
    year?: true
    kilometer?: true
    accidentStatus?: true
    accidentAmount?: true
    status?: true
    price?: true
    displayValues?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    vehicleTypeId?: true
    vehicleYearId?: true
    brandId?: true
    modelId?: true
    versionId?: true
    bodyTypeId?: true
    fuelTypeId?: true
    transmissionTypeId?: true
    colorId?: true
    notes?: true
    adminNotes?: true
    description?: true
    registrationDate?: true
    listingStatus?: true
  }

  export type VehicleOfferMaxAggregateInputType = {
    id?: true
    year?: true
    kilometer?: true
    accidentStatus?: true
    accidentAmount?: true
    status?: true
    price?: true
    displayValues?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    vehicleTypeId?: true
    vehicleYearId?: true
    brandId?: true
    modelId?: true
    versionId?: true
    bodyTypeId?: true
    fuelTypeId?: true
    transmissionTypeId?: true
    colorId?: true
    notes?: true
    adminNotes?: true
    description?: true
    registrationDate?: true
    listingStatus?: true
  }

  export type VehicleOfferCountAggregateInputType = {
    id?: true
    year?: true
    kilometer?: true
    accidentStatus?: true
    accidentAmount?: true
    status?: true
    price?: true
    displayValues?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    processedAt?: true
    vehicleTypeId?: true
    vehicleYearId?: true
    brandId?: true
    modelId?: true
    versionId?: true
    bodyTypeId?: true
    fuelTypeId?: true
    transmissionTypeId?: true
    colorId?: true
    notes?: true
    adminNotes?: true
    description?: true
    registrationDate?: true
    listingStatus?: true
    _all?: true
  }

  export type VehicleOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleOffer to aggregate.
     */
    where?: VehicleOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleOffers to fetch.
     */
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleOffers
    **/
    _count?: true | VehicleOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleOfferMaxAggregateInputType
  }

  export type GetVehicleOfferAggregateType<T extends VehicleOfferAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleOffer[P]>
      : GetScalarType<T[P], AggregateVehicleOffer[P]>
  }




  export type VehicleOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleOfferWhereInput
    orderBy?: VehicleOfferOrderByWithAggregationInput | VehicleOfferOrderByWithAggregationInput[]
    by: VehicleOfferScalarFieldEnum[] | VehicleOfferScalarFieldEnum
    having?: VehicleOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleOfferCountAggregateInputType | true
    _avg?: VehicleOfferAvgAggregateInputType
    _sum?: VehicleOfferSumAggregateInputType
    _min?: VehicleOfferMinAggregateInputType
    _max?: VehicleOfferMaxAggregateInputType
  }

  export type VehicleOfferGroupByOutputType = {
    id: number
    year: number | null
    kilometer: number | null
    accidentStatus: string | null
    accidentAmount: number | null
    status: string
    price: number | null
    displayValues: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    processedAt: Date | null
    vehicleTypeId: number | null
    vehicleYearId: number | null
    brandId: number | null
    modelId: number | null
    versionId: number | null
    bodyTypeId: number | null
    fuelTypeId: number | null
    transmissionTypeId: number | null
    colorId: number | null
    notes: string | null
    adminNotes: string | null
    description: string | null
    registrationDate: Date | null
    listingStatus: string
    _count: VehicleOfferCountAggregateOutputType | null
    _avg: VehicleOfferAvgAggregateOutputType | null
    _sum: VehicleOfferSumAggregateOutputType | null
    _min: VehicleOfferMinAggregateOutputType | null
    _max: VehicleOfferMaxAggregateOutputType | null
  }

  type GetVehicleOfferGroupByPayload<T extends VehicleOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleOfferGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleOfferGroupByOutputType[P]>
        }
      >
    >


  export type VehicleOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    kilometer?: boolean
    accidentStatus?: boolean
    accidentAmount?: boolean
    status?: boolean
    price?: boolean
    displayValues?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    vehicleTypeId?: boolean
    vehicleYearId?: boolean
    brandId?: boolean
    modelId?: boolean
    versionId?: boolean
    bodyTypeId?: boolean
    fuelTypeId?: boolean
    transmissionTypeId?: boolean
    colorId?: boolean
    notes?: boolean
    adminNotes?: boolean
    description?: boolean
    registrationDate?: boolean
    listingStatus?: boolean
    vehicleType?: boolean | VehicleOffer$vehicleTypeArgs<ExtArgs>
    vehicleYear?: boolean | VehicleOffer$vehicleYearArgs<ExtArgs>
    brand?: boolean | VehicleOffer$brandArgs<ExtArgs>
    model?: boolean | VehicleOffer$modelArgs<ExtArgs>
    version?: boolean | VehicleOffer$versionArgs<ExtArgs>
    bodyType?: boolean | VehicleOffer$bodyTypeArgs<ExtArgs>
    fuelType?: boolean | VehicleOffer$fuelTypeArgs<ExtArgs>
    transmissionType?: boolean | VehicleOffer$transmissionTypeArgs<ExtArgs>
    color?: boolean | VehicleOffer$colorArgs<ExtArgs>
    images?: boolean | VehicleOffer$imagesArgs<ExtArgs>
    _count?: boolean | VehicleOfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleOffer"]>

  export type VehicleOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    kilometer?: boolean
    accidentStatus?: boolean
    accidentAmount?: boolean
    status?: boolean
    price?: boolean
    displayValues?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    vehicleTypeId?: boolean
    vehicleYearId?: boolean
    brandId?: boolean
    modelId?: boolean
    versionId?: boolean
    bodyTypeId?: boolean
    fuelTypeId?: boolean
    transmissionTypeId?: boolean
    colorId?: boolean
    notes?: boolean
    adminNotes?: boolean
    description?: boolean
    registrationDate?: boolean
    listingStatus?: boolean
    vehicleType?: boolean | VehicleOffer$vehicleTypeArgs<ExtArgs>
    vehicleYear?: boolean | VehicleOffer$vehicleYearArgs<ExtArgs>
    brand?: boolean | VehicleOffer$brandArgs<ExtArgs>
    model?: boolean | VehicleOffer$modelArgs<ExtArgs>
    version?: boolean | VehicleOffer$versionArgs<ExtArgs>
    bodyType?: boolean | VehicleOffer$bodyTypeArgs<ExtArgs>
    fuelType?: boolean | VehicleOffer$fuelTypeArgs<ExtArgs>
    transmissionType?: boolean | VehicleOffer$transmissionTypeArgs<ExtArgs>
    color?: boolean | VehicleOffer$colorArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleOffer"]>

  export type VehicleOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    kilometer?: boolean
    accidentStatus?: boolean
    accidentAmount?: boolean
    status?: boolean
    price?: boolean
    displayValues?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    vehicleTypeId?: boolean
    vehicleYearId?: boolean
    brandId?: boolean
    modelId?: boolean
    versionId?: boolean
    bodyTypeId?: boolean
    fuelTypeId?: boolean
    transmissionTypeId?: boolean
    colorId?: boolean
    notes?: boolean
    adminNotes?: boolean
    description?: boolean
    registrationDate?: boolean
    listingStatus?: boolean
    vehicleType?: boolean | VehicleOffer$vehicleTypeArgs<ExtArgs>
    vehicleYear?: boolean | VehicleOffer$vehicleYearArgs<ExtArgs>
    brand?: boolean | VehicleOffer$brandArgs<ExtArgs>
    model?: boolean | VehicleOffer$modelArgs<ExtArgs>
    version?: boolean | VehicleOffer$versionArgs<ExtArgs>
    bodyType?: boolean | VehicleOffer$bodyTypeArgs<ExtArgs>
    fuelType?: boolean | VehicleOffer$fuelTypeArgs<ExtArgs>
    transmissionType?: boolean | VehicleOffer$transmissionTypeArgs<ExtArgs>
    color?: boolean | VehicleOffer$colorArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleOffer"]>

  export type VehicleOfferSelectScalar = {
    id?: boolean
    year?: boolean
    kilometer?: boolean
    accidentStatus?: boolean
    accidentAmount?: boolean
    status?: boolean
    price?: boolean
    displayValues?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    processedAt?: boolean
    vehicleTypeId?: boolean
    vehicleYearId?: boolean
    brandId?: boolean
    modelId?: boolean
    versionId?: boolean
    bodyTypeId?: boolean
    fuelTypeId?: boolean
    transmissionTypeId?: boolean
    colorId?: boolean
    notes?: boolean
    adminNotes?: boolean
    description?: boolean
    registrationDate?: boolean
    listingStatus?: boolean
  }

  export type VehicleOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "kilometer" | "accidentStatus" | "accidentAmount" | "status" | "price" | "displayValues" | "userId" | "createdAt" | "updatedAt" | "processedAt" | "vehicleTypeId" | "vehicleYearId" | "brandId" | "modelId" | "versionId" | "bodyTypeId" | "fuelTypeId" | "transmissionTypeId" | "colorId" | "notes" | "adminNotes" | "description" | "registrationDate" | "listingStatus", ExtArgs["result"]["vehicleOffer"]>
  export type VehicleOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleType?: boolean | VehicleOffer$vehicleTypeArgs<ExtArgs>
    vehicleYear?: boolean | VehicleOffer$vehicleYearArgs<ExtArgs>
    brand?: boolean | VehicleOffer$brandArgs<ExtArgs>
    model?: boolean | VehicleOffer$modelArgs<ExtArgs>
    version?: boolean | VehicleOffer$versionArgs<ExtArgs>
    bodyType?: boolean | VehicleOffer$bodyTypeArgs<ExtArgs>
    fuelType?: boolean | VehicleOffer$fuelTypeArgs<ExtArgs>
    transmissionType?: boolean | VehicleOffer$transmissionTypeArgs<ExtArgs>
    color?: boolean | VehicleOffer$colorArgs<ExtArgs>
    images?: boolean | VehicleOffer$imagesArgs<ExtArgs>
    _count?: boolean | VehicleOfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleType?: boolean | VehicleOffer$vehicleTypeArgs<ExtArgs>
    vehicleYear?: boolean | VehicleOffer$vehicleYearArgs<ExtArgs>
    brand?: boolean | VehicleOffer$brandArgs<ExtArgs>
    model?: boolean | VehicleOffer$modelArgs<ExtArgs>
    version?: boolean | VehicleOffer$versionArgs<ExtArgs>
    bodyType?: boolean | VehicleOffer$bodyTypeArgs<ExtArgs>
    fuelType?: boolean | VehicleOffer$fuelTypeArgs<ExtArgs>
    transmissionType?: boolean | VehicleOffer$transmissionTypeArgs<ExtArgs>
    color?: boolean | VehicleOffer$colorArgs<ExtArgs>
  }
  export type VehicleOfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicleType?: boolean | VehicleOffer$vehicleTypeArgs<ExtArgs>
    vehicleYear?: boolean | VehicleOffer$vehicleYearArgs<ExtArgs>
    brand?: boolean | VehicleOffer$brandArgs<ExtArgs>
    model?: boolean | VehicleOffer$modelArgs<ExtArgs>
    version?: boolean | VehicleOffer$versionArgs<ExtArgs>
    bodyType?: boolean | VehicleOffer$bodyTypeArgs<ExtArgs>
    fuelType?: boolean | VehicleOffer$fuelTypeArgs<ExtArgs>
    transmissionType?: boolean | VehicleOffer$transmissionTypeArgs<ExtArgs>
    color?: boolean | VehicleOffer$colorArgs<ExtArgs>
  }

  export type $VehicleOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleOffer"
    objects: {
      vehicleType: Prisma.$VehicleTypePayload<ExtArgs> | null
      vehicleYear: Prisma.$VehicleYearPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      model: Prisma.$ModelPayload<ExtArgs> | null
      version: Prisma.$VersionPayload<ExtArgs> | null
      bodyType: Prisma.$BodyTypePayload<ExtArgs> | null
      fuelType: Prisma.$FuelTypePayload<ExtArgs> | null
      transmissionType: Prisma.$TransmissionTypePayload<ExtArgs> | null
      color: Prisma.$ColorPayload<ExtArgs> | null
      images: Prisma.$VehicleImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      year: number | null
      kilometer: number | null
      accidentStatus: string | null
      accidentAmount: number | null
      status: string
      price: number | null
      displayValues: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
      processedAt: Date | null
      vehicleTypeId: number | null
      vehicleYearId: number | null
      brandId: number | null
      modelId: number | null
      versionId: number | null
      bodyTypeId: number | null
      fuelTypeId: number | null
      transmissionTypeId: number | null
      colorId: number | null
      notes: string | null
      adminNotes: string | null
      description: string | null
      registrationDate: Date | null
      listingStatus: string
    }, ExtArgs["result"]["vehicleOffer"]>
    composites: {}
  }

  type VehicleOfferGetPayload<S extends boolean | null | undefined | VehicleOfferDefaultArgs> = $Result.GetResult<Prisma.$VehicleOfferPayload, S>

  type VehicleOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleOfferCountAggregateInputType | true
    }

  export interface VehicleOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleOffer'], meta: { name: 'VehicleOffer' } }
    /**
     * Find zero or one VehicleOffer that matches the filter.
     * @param {VehicleOfferFindUniqueArgs} args - Arguments to find a VehicleOffer
     * @example
     * // Get one VehicleOffer
     * const vehicleOffer = await prisma.vehicleOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleOfferFindUniqueArgs>(args: SelectSubset<T, VehicleOfferFindUniqueArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleOfferFindUniqueOrThrowArgs} args - Arguments to find a VehicleOffer
     * @example
     * // Get one VehicleOffer
     * const vehicleOffer = await prisma.vehicleOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferFindFirstArgs} args - Arguments to find a VehicleOffer
     * @example
     * // Get one VehicleOffer
     * const vehicleOffer = await prisma.vehicleOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleOfferFindFirstArgs>(args?: SelectSubset<T, VehicleOfferFindFirstArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferFindFirstOrThrowArgs} args - Arguments to find a VehicleOffer
     * @example
     * // Get one VehicleOffer
     * const vehicleOffer = await prisma.vehicleOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleOffers
     * const vehicleOffers = await prisma.vehicleOffer.findMany()
     * 
     * // Get first 10 VehicleOffers
     * const vehicleOffers = await prisma.vehicleOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleOfferWithIdOnly = await prisma.vehicleOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleOfferFindManyArgs>(args?: SelectSubset<T, VehicleOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleOffer.
     * @param {VehicleOfferCreateArgs} args - Arguments to create a VehicleOffer.
     * @example
     * // Create one VehicleOffer
     * const VehicleOffer = await prisma.vehicleOffer.create({
     *   data: {
     *     // ... data to create a VehicleOffer
     *   }
     * })
     * 
     */
    create<T extends VehicleOfferCreateArgs>(args: SelectSubset<T, VehicleOfferCreateArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleOffers.
     * @param {VehicleOfferCreateManyArgs} args - Arguments to create many VehicleOffers.
     * @example
     * // Create many VehicleOffers
     * const vehicleOffer = await prisma.vehicleOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleOfferCreateManyArgs>(args?: SelectSubset<T, VehicleOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleOffers and returns the data saved in the database.
     * @param {VehicleOfferCreateManyAndReturnArgs} args - Arguments to create many VehicleOffers.
     * @example
     * // Create many VehicleOffers
     * const vehicleOffer = await prisma.vehicleOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleOffers and only return the `id`
     * const vehicleOfferWithIdOnly = await prisma.vehicleOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleOffer.
     * @param {VehicleOfferDeleteArgs} args - Arguments to delete one VehicleOffer.
     * @example
     * // Delete one VehicleOffer
     * const VehicleOffer = await prisma.vehicleOffer.delete({
     *   where: {
     *     // ... filter to delete one VehicleOffer
     *   }
     * })
     * 
     */
    delete<T extends VehicleOfferDeleteArgs>(args: SelectSubset<T, VehicleOfferDeleteArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleOffer.
     * @param {VehicleOfferUpdateArgs} args - Arguments to update one VehicleOffer.
     * @example
     * // Update one VehicleOffer
     * const vehicleOffer = await prisma.vehicleOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleOfferUpdateArgs>(args: SelectSubset<T, VehicleOfferUpdateArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleOffers.
     * @param {VehicleOfferDeleteManyArgs} args - Arguments to filter VehicleOffers to delete.
     * @example
     * // Delete a few VehicleOffers
     * const { count } = await prisma.vehicleOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleOfferDeleteManyArgs>(args?: SelectSubset<T, VehicleOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleOffers
     * const vehicleOffer = await prisma.vehicleOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleOfferUpdateManyArgs>(args: SelectSubset<T, VehicleOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleOffers and returns the data updated in the database.
     * @param {VehicleOfferUpdateManyAndReturnArgs} args - Arguments to update many VehicleOffers.
     * @example
     * // Update many VehicleOffers
     * const vehicleOffer = await prisma.vehicleOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleOffers and only return the `id`
     * const vehicleOfferWithIdOnly = await prisma.vehicleOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleOffer.
     * @param {VehicleOfferUpsertArgs} args - Arguments to update or create a VehicleOffer.
     * @example
     * // Update or create a VehicleOffer
     * const vehicleOffer = await prisma.vehicleOffer.upsert({
     *   create: {
     *     // ... data to create a VehicleOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleOffer we want to update
     *   }
     * })
     */
    upsert<T extends VehicleOfferUpsertArgs>(args: SelectSubset<T, VehicleOfferUpsertArgs<ExtArgs>>): Prisma__VehicleOfferClient<$Result.GetResult<Prisma.$VehicleOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferCountArgs} args - Arguments to filter VehicleOffers to count.
     * @example
     * // Count the number of VehicleOffers
     * const count = await prisma.vehicleOffer.count({
     *   where: {
     *     // ... the filter for the VehicleOffers we want to count
     *   }
     * })
    **/
    count<T extends VehicleOfferCountArgs>(
      args?: Subset<T, VehicleOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleOfferAggregateArgs>(args: Subset<T, VehicleOfferAggregateArgs>): Prisma.PrismaPromise<GetVehicleOfferAggregateType<T>>

    /**
     * Group by VehicleOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleOfferGroupByArgs['orderBy'] }
        : { orderBy?: VehicleOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleOffer model
   */
  readonly fields: VehicleOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicleType<T extends VehicleOffer$vehicleTypeArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$vehicleTypeArgs<ExtArgs>>): Prisma__VehicleTypeClient<$Result.GetResult<Prisma.$VehicleTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicleYear<T extends VehicleOffer$vehicleYearArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$vehicleYearArgs<ExtArgs>>): Prisma__VehicleYearClient<$Result.GetResult<Prisma.$VehicleYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends VehicleOffer$brandArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    model<T extends VehicleOffer$modelArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$modelArgs<ExtArgs>>): Prisma__ModelClient<$Result.GetResult<Prisma.$ModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    version<T extends VehicleOffer$versionArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$versionArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bodyType<T extends VehicleOffer$bodyTypeArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$bodyTypeArgs<ExtArgs>>): Prisma__BodyTypeClient<$Result.GetResult<Prisma.$BodyTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fuelType<T extends VehicleOffer$fuelTypeArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$fuelTypeArgs<ExtArgs>>): Prisma__FuelTypeClient<$Result.GetResult<Prisma.$FuelTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transmissionType<T extends VehicleOffer$transmissionTypeArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$transmissionTypeArgs<ExtArgs>>): Prisma__TransmissionTypeClient<$Result.GetResult<Prisma.$TransmissionTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    color<T extends VehicleOffer$colorArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$colorArgs<ExtArgs>>): Prisma__ColorClient<$Result.GetResult<Prisma.$ColorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends VehicleOffer$imagesArgs<ExtArgs> = {}>(args?: Subset<T, VehicleOffer$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleOffer model
   */
  interface VehicleOfferFieldRefs {
    readonly id: FieldRef<"VehicleOffer", 'Int'>
    readonly year: FieldRef<"VehicleOffer", 'Int'>
    readonly kilometer: FieldRef<"VehicleOffer", 'Int'>
    readonly accidentStatus: FieldRef<"VehicleOffer", 'String'>
    readonly accidentAmount: FieldRef<"VehicleOffer", 'Int'>
    readonly status: FieldRef<"VehicleOffer", 'String'>
    readonly price: FieldRef<"VehicleOffer", 'Float'>
    readonly displayValues: FieldRef<"VehicleOffer", 'String'>
    readonly userId: FieldRef<"VehicleOffer", 'String'>
    readonly createdAt: FieldRef<"VehicleOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"VehicleOffer", 'DateTime'>
    readonly processedAt: FieldRef<"VehicleOffer", 'DateTime'>
    readonly vehicleTypeId: FieldRef<"VehicleOffer", 'Int'>
    readonly vehicleYearId: FieldRef<"VehicleOffer", 'Int'>
    readonly brandId: FieldRef<"VehicleOffer", 'Int'>
    readonly modelId: FieldRef<"VehicleOffer", 'Int'>
    readonly versionId: FieldRef<"VehicleOffer", 'Int'>
    readonly bodyTypeId: FieldRef<"VehicleOffer", 'Int'>
    readonly fuelTypeId: FieldRef<"VehicleOffer", 'Int'>
    readonly transmissionTypeId: FieldRef<"VehicleOffer", 'Int'>
    readonly colorId: FieldRef<"VehicleOffer", 'Int'>
    readonly notes: FieldRef<"VehicleOffer", 'String'>
    readonly adminNotes: FieldRef<"VehicleOffer", 'String'>
    readonly description: FieldRef<"VehicleOffer", 'String'>
    readonly registrationDate: FieldRef<"VehicleOffer", 'DateTime'>
    readonly listingStatus: FieldRef<"VehicleOffer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleOffer findUnique
   */
  export type VehicleOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * Filter, which VehicleOffer to fetch.
     */
    where: VehicleOfferWhereUniqueInput
  }

  /**
   * VehicleOffer findUniqueOrThrow
   */
  export type VehicleOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * Filter, which VehicleOffer to fetch.
     */
    where: VehicleOfferWhereUniqueInput
  }

  /**
   * VehicleOffer findFirst
   */
  export type VehicleOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * Filter, which VehicleOffer to fetch.
     */
    where?: VehicleOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleOffers to fetch.
     */
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleOffers.
     */
    cursor?: VehicleOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleOffers.
     */
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * VehicleOffer findFirstOrThrow
   */
  export type VehicleOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * Filter, which VehicleOffer to fetch.
     */
    where?: VehicleOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleOffers to fetch.
     */
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleOffers.
     */
    cursor?: VehicleOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleOffers.
     */
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * VehicleOffer findMany
   */
  export type VehicleOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * Filter, which VehicleOffers to fetch.
     */
    where?: VehicleOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleOffers to fetch.
     */
    orderBy?: VehicleOfferOrderByWithRelationInput | VehicleOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleOffers.
     */
    cursor?: VehicleOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleOffers.
     */
    skip?: number
    distinct?: VehicleOfferScalarFieldEnum | VehicleOfferScalarFieldEnum[]
  }

  /**
   * VehicleOffer create
   */
  export type VehicleOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleOffer.
     */
    data: XOR<VehicleOfferCreateInput, VehicleOfferUncheckedCreateInput>
  }

  /**
   * VehicleOffer createMany
   */
  export type VehicleOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleOffers.
     */
    data: VehicleOfferCreateManyInput | VehicleOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleOffer createManyAndReturn
   */
  export type VehicleOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleOffers.
     */
    data: VehicleOfferCreateManyInput | VehicleOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleOffer update
   */
  export type VehicleOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleOffer.
     */
    data: XOR<VehicleOfferUpdateInput, VehicleOfferUncheckedUpdateInput>
    /**
     * Choose, which VehicleOffer to update.
     */
    where: VehicleOfferWhereUniqueInput
  }

  /**
   * VehicleOffer updateMany
   */
  export type VehicleOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleOffers.
     */
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyInput>
    /**
     * Filter which VehicleOffers to update
     */
    where?: VehicleOfferWhereInput
    /**
     * Limit how many VehicleOffers to update.
     */
    limit?: number
  }

  /**
   * VehicleOffer updateManyAndReturn
   */
  export type VehicleOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * The data used to update VehicleOffers.
     */
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyInput>
    /**
     * Filter which VehicleOffers to update
     */
    where?: VehicleOfferWhereInput
    /**
     * Limit how many VehicleOffers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleOffer upsert
   */
  export type VehicleOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleOffer to update in case it exists.
     */
    where: VehicleOfferWhereUniqueInput
    /**
     * In case the VehicleOffer found by the `where` argument doesn't exist, create a new VehicleOffer with this data.
     */
    create: XOR<VehicleOfferCreateInput, VehicleOfferUncheckedCreateInput>
    /**
     * In case the VehicleOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleOfferUpdateInput, VehicleOfferUncheckedUpdateInput>
  }

  /**
   * VehicleOffer delete
   */
  export type VehicleOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
    /**
     * Filter which VehicleOffer to delete.
     */
    where: VehicleOfferWhereUniqueInput
  }

  /**
   * VehicleOffer deleteMany
   */
  export type VehicleOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleOffers to delete
     */
    where?: VehicleOfferWhereInput
    /**
     * Limit how many VehicleOffers to delete.
     */
    limit?: number
  }

  /**
   * VehicleOffer.vehicleType
   */
  export type VehicleOffer$vehicleTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleType
     */
    select?: VehicleTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleType
     */
    omit?: VehicleTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleTypeInclude<ExtArgs> | null
    where?: VehicleTypeWhereInput
  }

  /**
   * VehicleOffer.vehicleYear
   */
  export type VehicleOffer$vehicleYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleYear
     */
    select?: VehicleYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleYear
     */
    omit?: VehicleYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleYearInclude<ExtArgs> | null
    where?: VehicleYearWhereInput
  }

  /**
   * VehicleOffer.brand
   */
  export type VehicleOffer$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * VehicleOffer.model
   */
  export type VehicleOffer$modelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Model
     */
    omit?: ModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModelInclude<ExtArgs> | null
    where?: ModelWhereInput
  }

  /**
   * VehicleOffer.version
   */
  export type VehicleOffer$versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    where?: VersionWhereInput
  }

  /**
   * VehicleOffer.bodyType
   */
  export type VehicleOffer$bodyTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BodyType
     */
    select?: BodyTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BodyType
     */
    omit?: BodyTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BodyTypeInclude<ExtArgs> | null
    where?: BodyTypeWhereInput
  }

  /**
   * VehicleOffer.fuelType
   */
  export type VehicleOffer$fuelTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FuelType
     */
    select?: FuelTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FuelType
     */
    omit?: FuelTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FuelTypeInclude<ExtArgs> | null
    where?: FuelTypeWhereInput
  }

  /**
   * VehicleOffer.transmissionType
   */
  export type VehicleOffer$transmissionTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransmissionType
     */
    select?: TransmissionTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransmissionType
     */
    omit?: TransmissionTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransmissionTypeInclude<ExtArgs> | null
    where?: TransmissionTypeWhereInput
  }

  /**
   * VehicleOffer.color
   */
  export type VehicleOffer$colorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Color
     */
    select?: ColorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Color
     */
    omit?: ColorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ColorInclude<ExtArgs> | null
    where?: ColorWhereInput
  }

  /**
   * VehicleOffer.images
   */
  export type VehicleOffer$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleImage
     */
    select?: VehicleImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleImage
     */
    omit?: VehicleImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleImageInclude<ExtArgs> | null
    where?: VehicleImageWhereInput
    orderBy?: VehicleImageOrderByWithRelationInput | VehicleImageOrderByWithRelationInput[]
    cursor?: VehicleImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleImageScalarFieldEnum | VehicleImageScalarFieldEnum[]
  }

  /**
   * VehicleOffer without action
   */
  export type VehicleOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleOffer
     */
    select?: VehicleOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleOffer
     */
    omit?: VehicleOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleOfferInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VehicleTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleTypeScalarFieldEnum = (typeof VehicleTypeScalarFieldEnum)[keyof typeof VehicleTypeScalarFieldEnum]


  export const VehicleYearScalarFieldEnum: {
    id: 'id',
    year: 'year',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vehicleTypeId: 'vehicleTypeId'
  };

  export type VehicleYearScalarFieldEnum = (typeof VehicleYearScalarFieldEnum)[keyof typeof VehicleYearScalarFieldEnum]


  export const YearBrandScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yearId: 'yearId',
    brandId: 'brandId'
  };

  export type YearBrandScalarFieldEnum = (typeof YearBrandScalarFieldEnum)[keyof typeof YearBrandScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const YearModelScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yearBrandId: 'yearBrandId',
    modelId: 'modelId'
  };

  export type YearModelScalarFieldEnum = (typeof YearModelScalarFieldEnum)[keyof typeof YearModelScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const YearModelVersionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yearModelId: 'yearModelId',
    versionId: 'versionId'
  };

  export type YearModelVersionScalarFieldEnum = (typeof YearModelVersionScalarFieldEnum)[keyof typeof YearModelVersionScalarFieldEnum]


  export const VersionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VersionScalarFieldEnum = (typeof VersionScalarFieldEnum)[keyof typeof VersionScalarFieldEnum]


  export const YearModelVersionBodyTypeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yearModelVersionId: 'yearModelVersionId',
    bodyTypeId: 'bodyTypeId'
  };

  export type YearModelVersionBodyTypeScalarFieldEnum = (typeof YearModelVersionBodyTypeScalarFieldEnum)[keyof typeof YearModelVersionBodyTypeScalarFieldEnum]


  export const BodyTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BodyTypeScalarFieldEnum = (typeof BodyTypeScalarFieldEnum)[keyof typeof BodyTypeScalarFieldEnum]


  export const YearModelVersionBodyTypeFuelScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yearModelVersionBodyTypeId: 'yearModelVersionBodyTypeId',
    fuelTypeId: 'fuelTypeId'
  };

  export type YearModelVersionBodyTypeFuelScalarFieldEnum = (typeof YearModelVersionBodyTypeFuelScalarFieldEnum)[keyof typeof YearModelVersionBodyTypeFuelScalarFieldEnum]


  export const FuelTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FuelTypeScalarFieldEnum = (typeof FuelTypeScalarFieldEnum)[keyof typeof FuelTypeScalarFieldEnum]


  export const YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    yearModelVersionBodyTypeFuelId: 'yearModelVersionBodyTypeFuelId',
    transmissionTypeId: 'transmissionTypeId'
  };

  export type YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum = (typeof YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum)[keyof typeof YearModelVersionBodyTypeFuelTransmissionScalarFieldEnum]


  export const TransmissionTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransmissionTypeScalarFieldEnum = (typeof TransmissionTypeScalarFieldEnum)[keyof typeof TransmissionTypeScalarFieldEnum]


  export const ColorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ColorScalarFieldEnum = (typeof ColorScalarFieldEnum)[keyof typeof ColorScalarFieldEnum]


  export const VehicleImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vehicleOfferId: 'vehicleOfferId'
  };

  export type VehicleImageScalarFieldEnum = (typeof VehicleImageScalarFieldEnum)[keyof typeof VehicleImageScalarFieldEnum]


  export const VehicleOfferScalarFieldEnum: {
    id: 'id',
    year: 'year',
    kilometer: 'kilometer',
    accidentStatus: 'accidentStatus',
    accidentAmount: 'accidentAmount',
    status: 'status',
    price: 'price',
    displayValues: 'displayValues',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    processedAt: 'processedAt',
    vehicleTypeId: 'vehicleTypeId',
    vehicleYearId: 'vehicleYearId',
    brandId: 'brandId',
    modelId: 'modelId',
    versionId: 'versionId',
    bodyTypeId: 'bodyTypeId',
    fuelTypeId: 'fuelTypeId',
    transmissionTypeId: 'transmissionTypeId',
    colorId: 'colorId',
    notes: 'notes',
    adminNotes: 'adminNotes',
    description: 'description',
    registrationDate: 'registrationDate',
    listingStatus: 'listingStatus'
  };

  export type VehicleOfferScalarFieldEnum = (typeof VehicleOfferScalarFieldEnum)[keyof typeof VehicleOfferScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type VehicleTypeWhereInput = {
    AND?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    OR?: VehicleTypeWhereInput[]
    NOT?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    id?: IntFilter<"VehicleType"> | number
    name?: StringFilter<"VehicleType"> | string
    createdAt?: DateTimeFilter<"VehicleType"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleType"> | Date | string
    years?: VehicleYearListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type VehicleTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    years?: VehicleYearOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type VehicleTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    OR?: VehicleTypeWhereInput[]
    NOT?: VehicleTypeWhereInput | VehicleTypeWhereInput[]
    createdAt?: DateTimeFilter<"VehicleType"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleType"> | Date | string
    years?: VehicleYearListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type VehicleTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleTypeCountOrderByAggregateInput
    _avg?: VehicleTypeAvgOrderByAggregateInput
    _max?: VehicleTypeMaxOrderByAggregateInput
    _min?: VehicleTypeMinOrderByAggregateInput
    _sum?: VehicleTypeSumOrderByAggregateInput
  }

  export type VehicleTypeScalarWhereWithAggregatesInput = {
    AND?: VehicleTypeScalarWhereWithAggregatesInput | VehicleTypeScalarWhereWithAggregatesInput[]
    OR?: VehicleTypeScalarWhereWithAggregatesInput[]
    NOT?: VehicleTypeScalarWhereWithAggregatesInput | VehicleTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VehicleType"> | number
    name?: StringWithAggregatesFilter<"VehicleType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VehicleType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VehicleType"> | Date | string
  }

  export type VehicleYearWhereInput = {
    AND?: VehicleYearWhereInput | VehicleYearWhereInput[]
    OR?: VehicleYearWhereInput[]
    NOT?: VehicleYearWhereInput | VehicleYearWhereInput[]
    id?: IntFilter<"VehicleYear"> | number
    year?: IntFilter<"VehicleYear"> | number
    createdAt?: DateTimeFilter<"VehicleYear"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleYear"> | Date | string
    vehicleTypeId?: IntFilter<"VehicleYear"> | number
    vehicleType?: XOR<VehicleTypeScalarRelationFilter, VehicleTypeWhereInput>
    brands?: YearBrandListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type VehicleYearOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleTypeId?: SortOrder
    vehicleType?: VehicleTypeOrderByWithRelationInput
    brands?: YearBrandOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type VehicleYearWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    vehicleTypeId_year?: VehicleYearVehicleTypeIdYearCompoundUniqueInput
    AND?: VehicleYearWhereInput | VehicleYearWhereInput[]
    OR?: VehicleYearWhereInput[]
    NOT?: VehicleYearWhereInput | VehicleYearWhereInput[]
    year?: IntFilter<"VehicleYear"> | number
    createdAt?: DateTimeFilter<"VehicleYear"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleYear"> | Date | string
    vehicleTypeId?: IntFilter<"VehicleYear"> | number
    vehicleType?: XOR<VehicleTypeScalarRelationFilter, VehicleTypeWhereInput>
    brands?: YearBrandListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "vehicleTypeId_year">

  export type VehicleYearOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleTypeId?: SortOrder
    _count?: VehicleYearCountOrderByAggregateInput
    _avg?: VehicleYearAvgOrderByAggregateInput
    _max?: VehicleYearMaxOrderByAggregateInput
    _min?: VehicleYearMinOrderByAggregateInput
    _sum?: VehicleYearSumOrderByAggregateInput
  }

  export type VehicleYearScalarWhereWithAggregatesInput = {
    AND?: VehicleYearScalarWhereWithAggregatesInput | VehicleYearScalarWhereWithAggregatesInput[]
    OR?: VehicleYearScalarWhereWithAggregatesInput[]
    NOT?: VehicleYearScalarWhereWithAggregatesInput | VehicleYearScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VehicleYear"> | number
    year?: IntWithAggregatesFilter<"VehicleYear"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VehicleYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VehicleYear"> | Date | string
    vehicleTypeId?: IntWithAggregatesFilter<"VehicleYear"> | number
  }

  export type YearBrandWhereInput = {
    AND?: YearBrandWhereInput | YearBrandWhereInput[]
    OR?: YearBrandWhereInput[]
    NOT?: YearBrandWhereInput | YearBrandWhereInput[]
    id?: IntFilter<"YearBrand"> | number
    createdAt?: DateTimeFilter<"YearBrand"> | Date | string
    updatedAt?: DateTimeFilter<"YearBrand"> | Date | string
    yearId?: IntFilter<"YearBrand"> | number
    brandId?: IntFilter<"YearBrand"> | number
    vehicleYear?: XOR<VehicleYearScalarRelationFilter, VehicleYearWhereInput>
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    models?: YearModelListRelationFilter
  }

  export type YearBrandOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
    vehicleYear?: VehicleYearOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    models?: YearModelOrderByRelationAggregateInput
  }

  export type YearBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    yearId_brandId?: YearBrandYearIdBrandIdCompoundUniqueInput
    AND?: YearBrandWhereInput | YearBrandWhereInput[]
    OR?: YearBrandWhereInput[]
    NOT?: YearBrandWhereInput | YearBrandWhereInput[]
    createdAt?: DateTimeFilter<"YearBrand"> | Date | string
    updatedAt?: DateTimeFilter<"YearBrand"> | Date | string
    yearId?: IntFilter<"YearBrand"> | number
    brandId?: IntFilter<"YearBrand"> | number
    vehicleYear?: XOR<VehicleYearScalarRelationFilter, VehicleYearWhereInput>
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    models?: YearModelListRelationFilter
  }, "id" | "yearId_brandId">

  export type YearBrandOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
    _count?: YearBrandCountOrderByAggregateInput
    _avg?: YearBrandAvgOrderByAggregateInput
    _max?: YearBrandMaxOrderByAggregateInput
    _min?: YearBrandMinOrderByAggregateInput
    _sum?: YearBrandSumOrderByAggregateInput
  }

  export type YearBrandScalarWhereWithAggregatesInput = {
    AND?: YearBrandScalarWhereWithAggregatesInput | YearBrandScalarWhereWithAggregatesInput[]
    OR?: YearBrandScalarWhereWithAggregatesInput[]
    NOT?: YearBrandScalarWhereWithAggregatesInput | YearBrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearBrand"> | number
    createdAt?: DateTimeWithAggregatesFilter<"YearBrand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearBrand"> | Date | string
    yearId?: IntWithAggregatesFilter<"YearBrand"> | number
    brandId?: IntWithAggregatesFilter<"YearBrand"> | number
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: IntFilter<"Brand"> | number
    name?: StringFilter<"Brand"> | string
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    yearBrands?: YearBrandListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearBrands?: YearBrandOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    yearBrands?: YearBrandListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brand"> | number
    name?: StringWithAggregatesFilter<"Brand"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type YearModelWhereInput = {
    AND?: YearModelWhereInput | YearModelWhereInput[]
    OR?: YearModelWhereInput[]
    NOT?: YearModelWhereInput | YearModelWhereInput[]
    id?: IntFilter<"YearModel"> | number
    createdAt?: DateTimeFilter<"YearModel"> | Date | string
    updatedAt?: DateTimeFilter<"YearModel"> | Date | string
    yearBrandId?: IntFilter<"YearModel"> | number
    modelId?: IntFilter<"YearModel"> | number
    yearBrand?: XOR<YearBrandScalarRelationFilter, YearBrandWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    versions?: YearModelVersionListRelationFilter
  }

  export type YearModelOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
    yearBrand?: YearBrandOrderByWithRelationInput
    model?: ModelOrderByWithRelationInput
    versions?: YearModelVersionOrderByRelationAggregateInput
  }

  export type YearModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    yearBrandId_modelId?: YearModelYearBrandIdModelIdCompoundUniqueInput
    AND?: YearModelWhereInput | YearModelWhereInput[]
    OR?: YearModelWhereInput[]
    NOT?: YearModelWhereInput | YearModelWhereInput[]
    createdAt?: DateTimeFilter<"YearModel"> | Date | string
    updatedAt?: DateTimeFilter<"YearModel"> | Date | string
    yearBrandId?: IntFilter<"YearModel"> | number
    modelId?: IntFilter<"YearModel"> | number
    yearBrand?: XOR<YearBrandScalarRelationFilter, YearBrandWhereInput>
    model?: XOR<ModelScalarRelationFilter, ModelWhereInput>
    versions?: YearModelVersionListRelationFilter
  }, "id" | "yearBrandId_modelId">

  export type YearModelOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
    _count?: YearModelCountOrderByAggregateInput
    _avg?: YearModelAvgOrderByAggregateInput
    _max?: YearModelMaxOrderByAggregateInput
    _min?: YearModelMinOrderByAggregateInput
    _sum?: YearModelSumOrderByAggregateInput
  }

  export type YearModelScalarWhereWithAggregatesInput = {
    AND?: YearModelScalarWhereWithAggregatesInput | YearModelScalarWhereWithAggregatesInput[]
    OR?: YearModelScalarWhereWithAggregatesInput[]
    NOT?: YearModelScalarWhereWithAggregatesInput | YearModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearModel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"YearModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearModel"> | Date | string
    yearBrandId?: IntWithAggregatesFilter<"YearModel"> | number
    modelId?: IntWithAggregatesFilter<"YearModel"> | number
  }

  export type ModelWhereInput = {
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    id?: IntFilter<"Model"> | number
    name?: StringFilter<"Model"> | string
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    yearModels?: YearModelListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModels?: YearModelOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ModelWhereInput | ModelWhereInput[]
    OR?: ModelWhereInput[]
    NOT?: ModelWhereInput | ModelWhereInput[]
    createdAt?: DateTimeFilter<"Model"> | Date | string
    updatedAt?: DateTimeFilter<"Model"> | Date | string
    yearModels?: YearModelListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _avg?: ModelAvgOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
    _sum?: ModelSumOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    OR?: ModelScalarWhereWithAggregatesInput[]
    NOT?: ModelScalarWhereWithAggregatesInput | ModelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Model"> | number
    name?: StringWithAggregatesFilter<"Model"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Model"> | Date | string
  }

  export type YearModelVersionWhereInput = {
    AND?: YearModelVersionWhereInput | YearModelVersionWhereInput[]
    OR?: YearModelVersionWhereInput[]
    NOT?: YearModelVersionWhereInput | YearModelVersionWhereInput[]
    id?: IntFilter<"YearModelVersion"> | number
    createdAt?: DateTimeFilter<"YearModelVersion"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersion"> | Date | string
    yearModelId?: IntFilter<"YearModelVersion"> | number
    versionId?: IntFilter<"YearModelVersion"> | number
    yearModel?: XOR<YearModelScalarRelationFilter, YearModelWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    bodyTypes?: YearModelVersionBodyTypeListRelationFilter
  }

  export type YearModelVersionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
    yearModel?: YearModelOrderByWithRelationInput
    version?: VersionOrderByWithRelationInput
    bodyTypes?: YearModelVersionBodyTypeOrderByRelationAggregateInput
  }

  export type YearModelVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    yearModelId_versionId?: YearModelVersionYearModelIdVersionIdCompoundUniqueInput
    AND?: YearModelVersionWhereInput | YearModelVersionWhereInput[]
    OR?: YearModelVersionWhereInput[]
    NOT?: YearModelVersionWhereInput | YearModelVersionWhereInput[]
    createdAt?: DateTimeFilter<"YearModelVersion"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersion"> | Date | string
    yearModelId?: IntFilter<"YearModelVersion"> | number
    versionId?: IntFilter<"YearModelVersion"> | number
    yearModel?: XOR<YearModelScalarRelationFilter, YearModelWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    bodyTypes?: YearModelVersionBodyTypeListRelationFilter
  }, "id" | "yearModelId_versionId">

  export type YearModelVersionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
    _count?: YearModelVersionCountOrderByAggregateInput
    _avg?: YearModelVersionAvgOrderByAggregateInput
    _max?: YearModelVersionMaxOrderByAggregateInput
    _min?: YearModelVersionMinOrderByAggregateInput
    _sum?: YearModelVersionSumOrderByAggregateInput
  }

  export type YearModelVersionScalarWhereWithAggregatesInput = {
    AND?: YearModelVersionScalarWhereWithAggregatesInput | YearModelVersionScalarWhereWithAggregatesInput[]
    OR?: YearModelVersionScalarWhereWithAggregatesInput[]
    NOT?: YearModelVersionScalarWhereWithAggregatesInput | YearModelVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearModelVersion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"YearModelVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearModelVersion"> | Date | string
    yearModelId?: IntWithAggregatesFilter<"YearModelVersion"> | number
    versionId?: IntWithAggregatesFilter<"YearModelVersion"> | number
  }

  export type VersionWhereInput = {
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    id?: IntFilter<"Version"> | number
    name?: StringFilter<"Version"> | string
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
    yearModelVersions?: YearModelVersionListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type VersionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersions?: YearModelVersionOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type VersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
    yearModelVersions?: YearModelVersionListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type VersionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VersionCountOrderByAggregateInput
    _avg?: VersionAvgOrderByAggregateInput
    _max?: VersionMaxOrderByAggregateInput
    _min?: VersionMinOrderByAggregateInput
    _sum?: VersionSumOrderByAggregateInput
  }

  export type VersionScalarWhereWithAggregatesInput = {
    AND?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    OR?: VersionScalarWhereWithAggregatesInput[]
    NOT?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Version"> | number
    name?: StringWithAggregatesFilter<"Version"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Version"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Version"> | Date | string
  }

  export type YearModelVersionBodyTypeWhereInput = {
    AND?: YearModelVersionBodyTypeWhereInput | YearModelVersionBodyTypeWhereInput[]
    OR?: YearModelVersionBodyTypeWhereInput[]
    NOT?: YearModelVersionBodyTypeWhereInput | YearModelVersionBodyTypeWhereInput[]
    id?: IntFilter<"YearModelVersionBodyType"> | number
    createdAt?: DateTimeFilter<"YearModelVersionBodyType"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyType"> | Date | string
    yearModelVersionId?: IntFilter<"YearModelVersionBodyType"> | number
    bodyTypeId?: IntFilter<"YearModelVersionBodyType"> | number
    yearModelVersion?: XOR<YearModelVersionScalarRelationFilter, YearModelVersionWhereInput>
    bodyType?: XOR<BodyTypeScalarRelationFilter, BodyTypeWhereInput>
    fuelTypes?: YearModelVersionBodyTypeFuelListRelationFilter
  }

  export type YearModelVersionBodyTypeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
    yearModelVersion?: YearModelVersionOrderByWithRelationInput
    bodyType?: BodyTypeOrderByWithRelationInput
    fuelTypes?: YearModelVersionBodyTypeFuelOrderByRelationAggregateInput
  }

  export type YearModelVersionBodyTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    yearModelVersionId_bodyTypeId?: YearModelVersionBodyTypeYearModelVersionIdBodyTypeIdCompoundUniqueInput
    AND?: YearModelVersionBodyTypeWhereInput | YearModelVersionBodyTypeWhereInput[]
    OR?: YearModelVersionBodyTypeWhereInput[]
    NOT?: YearModelVersionBodyTypeWhereInput | YearModelVersionBodyTypeWhereInput[]
    createdAt?: DateTimeFilter<"YearModelVersionBodyType"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyType"> | Date | string
    yearModelVersionId?: IntFilter<"YearModelVersionBodyType"> | number
    bodyTypeId?: IntFilter<"YearModelVersionBodyType"> | number
    yearModelVersion?: XOR<YearModelVersionScalarRelationFilter, YearModelVersionWhereInput>
    bodyType?: XOR<BodyTypeScalarRelationFilter, BodyTypeWhereInput>
    fuelTypes?: YearModelVersionBodyTypeFuelListRelationFilter
  }, "id" | "yearModelVersionId_bodyTypeId">

  export type YearModelVersionBodyTypeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
    _count?: YearModelVersionBodyTypeCountOrderByAggregateInput
    _avg?: YearModelVersionBodyTypeAvgOrderByAggregateInput
    _max?: YearModelVersionBodyTypeMaxOrderByAggregateInput
    _min?: YearModelVersionBodyTypeMinOrderByAggregateInput
    _sum?: YearModelVersionBodyTypeSumOrderByAggregateInput
  }

  export type YearModelVersionBodyTypeScalarWhereWithAggregatesInput = {
    AND?: YearModelVersionBodyTypeScalarWhereWithAggregatesInput | YearModelVersionBodyTypeScalarWhereWithAggregatesInput[]
    OR?: YearModelVersionBodyTypeScalarWhereWithAggregatesInput[]
    NOT?: YearModelVersionBodyTypeScalarWhereWithAggregatesInput | YearModelVersionBodyTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearModelVersionBodyType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"YearModelVersionBodyType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearModelVersionBodyType"> | Date | string
    yearModelVersionId?: IntWithAggregatesFilter<"YearModelVersionBodyType"> | number
    bodyTypeId?: IntWithAggregatesFilter<"YearModelVersionBodyType"> | number
  }

  export type BodyTypeWhereInput = {
    AND?: BodyTypeWhereInput | BodyTypeWhereInput[]
    OR?: BodyTypeWhereInput[]
    NOT?: BodyTypeWhereInput | BodyTypeWhereInput[]
    id?: IntFilter<"BodyType"> | number
    name?: StringFilter<"BodyType"> | string
    createdAt?: DateTimeFilter<"BodyType"> | Date | string
    updatedAt?: DateTimeFilter<"BodyType"> | Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type BodyTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type BodyTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BodyTypeWhereInput | BodyTypeWhereInput[]
    OR?: BodyTypeWhereInput[]
    NOT?: BodyTypeWhereInput | BodyTypeWhereInput[]
    createdAt?: DateTimeFilter<"BodyType"> | Date | string
    updatedAt?: DateTimeFilter<"BodyType"> | Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type BodyTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BodyTypeCountOrderByAggregateInput
    _avg?: BodyTypeAvgOrderByAggregateInput
    _max?: BodyTypeMaxOrderByAggregateInput
    _min?: BodyTypeMinOrderByAggregateInput
    _sum?: BodyTypeSumOrderByAggregateInput
  }

  export type BodyTypeScalarWhereWithAggregatesInput = {
    AND?: BodyTypeScalarWhereWithAggregatesInput | BodyTypeScalarWhereWithAggregatesInput[]
    OR?: BodyTypeScalarWhereWithAggregatesInput[]
    NOT?: BodyTypeScalarWhereWithAggregatesInput | BodyTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BodyType"> | number
    name?: StringWithAggregatesFilter<"BodyType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BodyType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BodyType"> | Date | string
  }

  export type YearModelVersionBodyTypeFuelWhereInput = {
    AND?: YearModelVersionBodyTypeFuelWhereInput | YearModelVersionBodyTypeFuelWhereInput[]
    OR?: YearModelVersionBodyTypeFuelWhereInput[]
    NOT?: YearModelVersionBodyTypeFuelWhereInput | YearModelVersionBodyTypeFuelWhereInput[]
    id?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    createdAt?: DateTimeFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    yearModelVersionBodyTypeId?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    fuelTypeId?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    yearModelVersionBodyType?: XOR<YearModelVersionBodyTypeScalarRelationFilter, YearModelVersionBodyTypeWhereInput>
    fuelType?: XOR<FuelTypeScalarRelationFilter, FuelTypeWhereInput>
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionListRelationFilter
  }

  export type YearModelVersionBodyTypeFuelOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    yearModelVersionBodyType?: YearModelVersionBodyTypeOrderByWithRelationInput
    fuelType?: FuelTypeOrderByWithRelationInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionOrderByRelationAggregateInput
  }

  export type YearModelVersionBodyTypeFuelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    yearModelVersionBodyTypeId_fuelTypeId?: YearModelVersionBodyTypeFuelYearModelVersionBodyTypeIdFuelTypeIdCompoundUniqueInput
    AND?: YearModelVersionBodyTypeFuelWhereInput | YearModelVersionBodyTypeFuelWhereInput[]
    OR?: YearModelVersionBodyTypeFuelWhereInput[]
    NOT?: YearModelVersionBodyTypeFuelWhereInput | YearModelVersionBodyTypeFuelWhereInput[]
    createdAt?: DateTimeFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    yearModelVersionBodyTypeId?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    fuelTypeId?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    yearModelVersionBodyType?: XOR<YearModelVersionBodyTypeScalarRelationFilter, YearModelVersionBodyTypeWhereInput>
    fuelType?: XOR<FuelTypeScalarRelationFilter, FuelTypeWhereInput>
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionListRelationFilter
  }, "id" | "yearModelVersionBodyTypeId_fuelTypeId">

  export type YearModelVersionBodyTypeFuelOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    _count?: YearModelVersionBodyTypeFuelCountOrderByAggregateInput
    _avg?: YearModelVersionBodyTypeFuelAvgOrderByAggregateInput
    _max?: YearModelVersionBodyTypeFuelMaxOrderByAggregateInput
    _min?: YearModelVersionBodyTypeFuelMinOrderByAggregateInput
    _sum?: YearModelVersionBodyTypeFuelSumOrderByAggregateInput
  }

  export type YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput = {
    AND?: YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput | YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput[]
    OR?: YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput[]
    NOT?: YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput | YearModelVersionBodyTypeFuelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearModelVersionBodyTypeFuel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    yearModelVersionBodyTypeId?: IntWithAggregatesFilter<"YearModelVersionBodyTypeFuel"> | number
    fuelTypeId?: IntWithAggregatesFilter<"YearModelVersionBodyTypeFuel"> | number
  }

  export type FuelTypeWhereInput = {
    AND?: FuelTypeWhereInput | FuelTypeWhereInput[]
    OR?: FuelTypeWhereInput[]
    NOT?: FuelTypeWhereInput | FuelTypeWhereInput[]
    id?: IntFilter<"FuelType"> | number
    name?: StringFilter<"FuelType"> | string
    createdAt?: DateTimeFilter<"FuelType"> | Date | string
    updatedAt?: DateTimeFilter<"FuelType"> | Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type FuelTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type FuelTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: FuelTypeWhereInput | FuelTypeWhereInput[]
    OR?: FuelTypeWhereInput[]
    NOT?: FuelTypeWhereInput | FuelTypeWhereInput[]
    createdAt?: DateTimeFilter<"FuelType"> | Date | string
    updatedAt?: DateTimeFilter<"FuelType"> | Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type FuelTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FuelTypeCountOrderByAggregateInput
    _avg?: FuelTypeAvgOrderByAggregateInput
    _max?: FuelTypeMaxOrderByAggregateInput
    _min?: FuelTypeMinOrderByAggregateInput
    _sum?: FuelTypeSumOrderByAggregateInput
  }

  export type FuelTypeScalarWhereWithAggregatesInput = {
    AND?: FuelTypeScalarWhereWithAggregatesInput | FuelTypeScalarWhereWithAggregatesInput[]
    OR?: FuelTypeScalarWhereWithAggregatesInput[]
    NOT?: FuelTypeScalarWhereWithAggregatesInput | FuelTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FuelType"> | number
    name?: StringWithAggregatesFilter<"FuelType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FuelType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FuelType"> | Date | string
  }

  export type YearModelVersionBodyTypeFuelTransmissionWhereInput = {
    AND?: YearModelVersionBodyTypeFuelTransmissionWhereInput | YearModelVersionBodyTypeFuelTransmissionWhereInput[]
    OR?: YearModelVersionBodyTypeFuelTransmissionWhereInput[]
    NOT?: YearModelVersionBodyTypeFuelTransmissionWhereInput | YearModelVersionBodyTypeFuelTransmissionWhereInput[]
    id?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    createdAt?: DateTimeFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    yearModelVersionBodyTypeFuelId?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    transmissionTypeId?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    yearModelVersionBodyTypeFuel?: XOR<YearModelVersionBodyTypeFuelScalarRelationFilter, YearModelVersionBodyTypeFuelWhereInput>
    transmissionType?: XOR<TransmissionTypeScalarRelationFilter, TransmissionTypeWhereInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
    yearModelVersionBodyTypeFuel?: YearModelVersionBodyTypeFuelOrderByWithRelationInput
    transmissionType?: TransmissionTypeOrderByWithRelationInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    yearModelVersionBodyTypeFuelId_transmissionTypeId?: YearModelVersionBodyTypeFuelTransmissionYearModelVersionBodyTypeFuelIdTransmissionTypeIdCompoundUniqueInput
    AND?: YearModelVersionBodyTypeFuelTransmissionWhereInput | YearModelVersionBodyTypeFuelTransmissionWhereInput[]
    OR?: YearModelVersionBodyTypeFuelTransmissionWhereInput[]
    NOT?: YearModelVersionBodyTypeFuelTransmissionWhereInput | YearModelVersionBodyTypeFuelTransmissionWhereInput[]
    createdAt?: DateTimeFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    yearModelVersionBodyTypeFuelId?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    transmissionTypeId?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    yearModelVersionBodyTypeFuel?: XOR<YearModelVersionBodyTypeFuelScalarRelationFilter, YearModelVersionBodyTypeFuelWhereInput>
    transmissionType?: XOR<TransmissionTypeScalarRelationFilter, TransmissionTypeWhereInput>
  }, "id" | "yearModelVersionBodyTypeFuelId_transmissionTypeId">

  export type YearModelVersionBodyTypeFuelTransmissionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
    _count?: YearModelVersionBodyTypeFuelTransmissionCountOrderByAggregateInput
    _avg?: YearModelVersionBodyTypeFuelTransmissionAvgOrderByAggregateInput
    _max?: YearModelVersionBodyTypeFuelTransmissionMaxOrderByAggregateInput
    _min?: YearModelVersionBodyTypeFuelTransmissionMinOrderByAggregateInput
    _sum?: YearModelVersionBodyTypeFuelTransmissionSumOrderByAggregateInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput = {
    AND?: YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput[]
    OR?: YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput[]
    NOT?: YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    createdAt?: DateTimeWithAggregatesFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    yearModelVersionBodyTypeFuelId?: IntWithAggregatesFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    transmissionTypeId?: IntWithAggregatesFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
  }

  export type TransmissionTypeWhereInput = {
    AND?: TransmissionTypeWhereInput | TransmissionTypeWhereInput[]
    OR?: TransmissionTypeWhereInput[]
    NOT?: TransmissionTypeWhereInput | TransmissionTypeWhereInput[]
    id?: IntFilter<"TransmissionType"> | number
    name?: StringFilter<"TransmissionType"> | string
    createdAt?: DateTimeFilter<"TransmissionType"> | Date | string
    updatedAt?: DateTimeFilter<"TransmissionType"> | Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type TransmissionTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionOrderByRelationAggregateInput
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type TransmissionTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TransmissionTypeWhereInput | TransmissionTypeWhereInput[]
    OR?: TransmissionTypeWhereInput[]
    NOT?: TransmissionTypeWhereInput | TransmissionTypeWhereInput[]
    createdAt?: DateTimeFilter<"TransmissionType"> | Date | string
    updatedAt?: DateTimeFilter<"TransmissionType"> | Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionListRelationFilter
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type TransmissionTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransmissionTypeCountOrderByAggregateInput
    _avg?: TransmissionTypeAvgOrderByAggregateInput
    _max?: TransmissionTypeMaxOrderByAggregateInput
    _min?: TransmissionTypeMinOrderByAggregateInput
    _sum?: TransmissionTypeSumOrderByAggregateInput
  }

  export type TransmissionTypeScalarWhereWithAggregatesInput = {
    AND?: TransmissionTypeScalarWhereWithAggregatesInput | TransmissionTypeScalarWhereWithAggregatesInput[]
    OR?: TransmissionTypeScalarWhereWithAggregatesInput[]
    NOT?: TransmissionTypeScalarWhereWithAggregatesInput | TransmissionTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TransmissionType"> | number
    name?: StringWithAggregatesFilter<"TransmissionType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TransmissionType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransmissionType"> | Date | string
  }

  export type ColorWhereInput = {
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    id?: IntFilter<"Color"> | number
    name?: StringFilter<"Color"> | string
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
    vehicleOffers?: VehicleOfferListRelationFilter
  }

  export type ColorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleOffers?: VehicleOfferOrderByRelationAggregateInput
  }

  export type ColorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ColorWhereInput | ColorWhereInput[]
    OR?: ColorWhereInput[]
    NOT?: ColorWhereInput | ColorWhereInput[]
    createdAt?: DateTimeFilter<"Color"> | Date | string
    updatedAt?: DateTimeFilter<"Color"> | Date | string
    vehicleOffers?: VehicleOfferListRelationFilter
  }, "id" | "name">

  export type ColorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ColorCountOrderByAggregateInput
    _avg?: ColorAvgOrderByAggregateInput
    _max?: ColorMaxOrderByAggregateInput
    _min?: ColorMinOrderByAggregateInput
    _sum?: ColorSumOrderByAggregateInput
  }

  export type ColorScalarWhereWithAggregatesInput = {
    AND?: ColorScalarWhereWithAggregatesInput | ColorScalarWhereWithAggregatesInput[]
    OR?: ColorScalarWhereWithAggregatesInput[]
    NOT?: ColorScalarWhereWithAggregatesInput | ColorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Color"> | number
    name?: StringWithAggregatesFilter<"Color"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Color"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Color"> | Date | string
  }

  export type VehicleImageWhereInput = {
    AND?: VehicleImageWhereInput | VehicleImageWhereInput[]
    OR?: VehicleImageWhereInput[]
    NOT?: VehicleImageWhereInput | VehicleImageWhereInput[]
    id?: IntFilter<"VehicleImage"> | number
    url?: StringFilter<"VehicleImage"> | string
    isPrimary?: BoolFilter<"VehicleImage"> | boolean
    createdAt?: DateTimeFilter<"VehicleImage"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleImage"> | Date | string
    vehicleOfferId?: IntFilter<"VehicleImage"> | number
    vehicleOffer?: XOR<VehicleOfferScalarRelationFilter, VehicleOfferWhereInput>
  }

  export type VehicleImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleOfferId?: SortOrder
    vehicleOffer?: VehicleOfferOrderByWithRelationInput
  }

  export type VehicleImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VehicleImageWhereInput | VehicleImageWhereInput[]
    OR?: VehicleImageWhereInput[]
    NOT?: VehicleImageWhereInput | VehicleImageWhereInput[]
    url?: StringFilter<"VehicleImage"> | string
    isPrimary?: BoolFilter<"VehicleImage"> | boolean
    createdAt?: DateTimeFilter<"VehicleImage"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleImage"> | Date | string
    vehicleOfferId?: IntFilter<"VehicleImage"> | number
    vehicleOffer?: XOR<VehicleOfferScalarRelationFilter, VehicleOfferWhereInput>
  }, "id">

  export type VehicleImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleOfferId?: SortOrder
    _count?: VehicleImageCountOrderByAggregateInput
    _avg?: VehicleImageAvgOrderByAggregateInput
    _max?: VehicleImageMaxOrderByAggregateInput
    _min?: VehicleImageMinOrderByAggregateInput
    _sum?: VehicleImageSumOrderByAggregateInput
  }

  export type VehicleImageScalarWhereWithAggregatesInput = {
    AND?: VehicleImageScalarWhereWithAggregatesInput | VehicleImageScalarWhereWithAggregatesInput[]
    OR?: VehicleImageScalarWhereWithAggregatesInput[]
    NOT?: VehicleImageScalarWhereWithAggregatesInput | VehicleImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VehicleImage"> | number
    url?: StringWithAggregatesFilter<"VehicleImage"> | string
    isPrimary?: BoolWithAggregatesFilter<"VehicleImage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VehicleImage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VehicleImage"> | Date | string
    vehicleOfferId?: IntWithAggregatesFilter<"VehicleImage"> | number
  }

  export type VehicleOfferWhereInput = {
    AND?: VehicleOfferWhereInput | VehicleOfferWhereInput[]
    OR?: VehicleOfferWhereInput[]
    NOT?: VehicleOfferWhereInput | VehicleOfferWhereInput[]
    id?: IntFilter<"VehicleOffer"> | number
    year?: IntNullableFilter<"VehicleOffer"> | number | null
    kilometer?: IntNullableFilter<"VehicleOffer"> | number | null
    accidentStatus?: StringNullableFilter<"VehicleOffer"> | string | null
    accidentAmount?: IntNullableFilter<"VehicleOffer"> | number | null
    status?: StringFilter<"VehicleOffer"> | string
    price?: FloatNullableFilter<"VehicleOffer"> | number | null
    displayValues?: StringNullableFilter<"VehicleOffer"> | string | null
    userId?: StringFilter<"VehicleOffer"> | string
    createdAt?: DateTimeFilter<"VehicleOffer"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleOffer"> | Date | string
    processedAt?: DateTimeNullableFilter<"VehicleOffer"> | Date | string | null
    vehicleTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    vehicleYearId?: IntNullableFilter<"VehicleOffer"> | number | null
    brandId?: IntNullableFilter<"VehicleOffer"> | number | null
    modelId?: IntNullableFilter<"VehicleOffer"> | number | null
    versionId?: IntNullableFilter<"VehicleOffer"> | number | null
    bodyTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    fuelTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    transmissionTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    colorId?: IntNullableFilter<"VehicleOffer"> | number | null
    notes?: StringNullableFilter<"VehicleOffer"> | string | null
    adminNotes?: StringNullableFilter<"VehicleOffer"> | string | null
    description?: StringNullableFilter<"VehicleOffer"> | string | null
    registrationDate?: DateTimeNullableFilter<"VehicleOffer"> | Date | string | null
    listingStatus?: StringFilter<"VehicleOffer"> | string
    vehicleType?: XOR<VehicleTypeNullableScalarRelationFilter, VehicleTypeWhereInput> | null
    vehicleYear?: XOR<VehicleYearNullableScalarRelationFilter, VehicleYearWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    model?: XOR<ModelNullableScalarRelationFilter, ModelWhereInput> | null
    version?: XOR<VersionNullableScalarRelationFilter, VersionWhereInput> | null
    bodyType?: XOR<BodyTypeNullableScalarRelationFilter, BodyTypeWhereInput> | null
    fuelType?: XOR<FuelTypeNullableScalarRelationFilter, FuelTypeWhereInput> | null
    transmissionType?: XOR<TransmissionTypeNullableScalarRelationFilter, TransmissionTypeWhereInput> | null
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    images?: VehicleImageListRelationFilter
  }

  export type VehicleOfferOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrderInput | SortOrder
    kilometer?: SortOrderInput | SortOrder
    accidentStatus?: SortOrderInput | SortOrder
    accidentAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    displayValues?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    vehicleTypeId?: SortOrderInput | SortOrder
    vehicleYearId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    versionId?: SortOrderInput | SortOrder
    bodyTypeId?: SortOrderInput | SortOrder
    fuelTypeId?: SortOrderInput | SortOrder
    transmissionTypeId?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    registrationDate?: SortOrderInput | SortOrder
    listingStatus?: SortOrder
    vehicleType?: VehicleTypeOrderByWithRelationInput
    vehicleYear?: VehicleYearOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    model?: ModelOrderByWithRelationInput
    version?: VersionOrderByWithRelationInput
    bodyType?: BodyTypeOrderByWithRelationInput
    fuelType?: FuelTypeOrderByWithRelationInput
    transmissionType?: TransmissionTypeOrderByWithRelationInput
    color?: ColorOrderByWithRelationInput
    images?: VehicleImageOrderByRelationAggregateInput
  }

  export type VehicleOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VehicleOfferWhereInput | VehicleOfferWhereInput[]
    OR?: VehicleOfferWhereInput[]
    NOT?: VehicleOfferWhereInput | VehicleOfferWhereInput[]
    year?: IntNullableFilter<"VehicleOffer"> | number | null
    kilometer?: IntNullableFilter<"VehicleOffer"> | number | null
    accidentStatus?: StringNullableFilter<"VehicleOffer"> | string | null
    accidentAmount?: IntNullableFilter<"VehicleOffer"> | number | null
    status?: StringFilter<"VehicleOffer"> | string
    price?: FloatNullableFilter<"VehicleOffer"> | number | null
    displayValues?: StringNullableFilter<"VehicleOffer"> | string | null
    userId?: StringFilter<"VehicleOffer"> | string
    createdAt?: DateTimeFilter<"VehicleOffer"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleOffer"> | Date | string
    processedAt?: DateTimeNullableFilter<"VehicleOffer"> | Date | string | null
    vehicleTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    vehicleYearId?: IntNullableFilter<"VehicleOffer"> | number | null
    brandId?: IntNullableFilter<"VehicleOffer"> | number | null
    modelId?: IntNullableFilter<"VehicleOffer"> | number | null
    versionId?: IntNullableFilter<"VehicleOffer"> | number | null
    bodyTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    fuelTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    transmissionTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    colorId?: IntNullableFilter<"VehicleOffer"> | number | null
    notes?: StringNullableFilter<"VehicleOffer"> | string | null
    adminNotes?: StringNullableFilter<"VehicleOffer"> | string | null
    description?: StringNullableFilter<"VehicleOffer"> | string | null
    registrationDate?: DateTimeNullableFilter<"VehicleOffer"> | Date | string | null
    listingStatus?: StringFilter<"VehicleOffer"> | string
    vehicleType?: XOR<VehicleTypeNullableScalarRelationFilter, VehicleTypeWhereInput> | null
    vehicleYear?: XOR<VehicleYearNullableScalarRelationFilter, VehicleYearWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    model?: XOR<ModelNullableScalarRelationFilter, ModelWhereInput> | null
    version?: XOR<VersionNullableScalarRelationFilter, VersionWhereInput> | null
    bodyType?: XOR<BodyTypeNullableScalarRelationFilter, BodyTypeWhereInput> | null
    fuelType?: XOR<FuelTypeNullableScalarRelationFilter, FuelTypeWhereInput> | null
    transmissionType?: XOR<TransmissionTypeNullableScalarRelationFilter, TransmissionTypeWhereInput> | null
    color?: XOR<ColorNullableScalarRelationFilter, ColorWhereInput> | null
    images?: VehicleImageListRelationFilter
  }, "id">

  export type VehicleOfferOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrderInput | SortOrder
    kilometer?: SortOrderInput | SortOrder
    accidentStatus?: SortOrderInput | SortOrder
    accidentAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    displayValues?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    vehicleTypeId?: SortOrderInput | SortOrder
    vehicleYearId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    versionId?: SortOrderInput | SortOrder
    bodyTypeId?: SortOrderInput | SortOrder
    fuelTypeId?: SortOrderInput | SortOrder
    transmissionTypeId?: SortOrderInput | SortOrder
    colorId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    registrationDate?: SortOrderInput | SortOrder
    listingStatus?: SortOrder
    _count?: VehicleOfferCountOrderByAggregateInput
    _avg?: VehicleOfferAvgOrderByAggregateInput
    _max?: VehicleOfferMaxOrderByAggregateInput
    _min?: VehicleOfferMinOrderByAggregateInput
    _sum?: VehicleOfferSumOrderByAggregateInput
  }

  export type VehicleOfferScalarWhereWithAggregatesInput = {
    AND?: VehicleOfferScalarWhereWithAggregatesInput | VehicleOfferScalarWhereWithAggregatesInput[]
    OR?: VehicleOfferScalarWhereWithAggregatesInput[]
    NOT?: VehicleOfferScalarWhereWithAggregatesInput | VehicleOfferScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VehicleOffer"> | number
    year?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    kilometer?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    accidentStatus?: StringNullableWithAggregatesFilter<"VehicleOffer"> | string | null
    accidentAmount?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    status?: StringWithAggregatesFilter<"VehicleOffer"> | string
    price?: FloatNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    displayValues?: StringNullableWithAggregatesFilter<"VehicleOffer"> | string | null
    userId?: StringWithAggregatesFilter<"VehicleOffer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VehicleOffer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VehicleOffer"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"VehicleOffer"> | Date | string | null
    vehicleTypeId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    vehicleYearId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    brandId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    modelId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    versionId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    bodyTypeId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    fuelTypeId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    transmissionTypeId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    colorId?: IntNullableWithAggregatesFilter<"VehicleOffer"> | number | null
    notes?: StringNullableWithAggregatesFilter<"VehicleOffer"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"VehicleOffer"> | string | null
    description?: StringNullableWithAggregatesFilter<"VehicleOffer"> | string | null
    registrationDate?: DateTimeNullableWithAggregatesFilter<"VehicleOffer"> | Date | string | null
    listingStatus?: StringWithAggregatesFilter<"VehicleOffer"> | string
  }

  export type VehicleTypeCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    years?: VehicleYearCreateNestedManyWithoutVehicleTypeInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVehicleTypeInput
  }

  export type VehicleTypeUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    years?: VehicleYearUncheckedCreateNestedManyWithoutVehicleTypeInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVehicleTypeInput
  }

  export type VehicleTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: VehicleYearUpdateManyWithoutVehicleTypeNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutVehicleTypeNestedInput
  }

  export type VehicleTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: VehicleYearUncheckedUpdateManyWithoutVehicleTypeNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVehicleTypeNestedInput
  }

  export type VehicleTypeCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleYearCreateInput = {
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleType: VehicleTypeCreateNestedOneWithoutYearsInput
    brands?: YearBrandCreateNestedManyWithoutVehicleYearInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearUncheckedCreateInput = {
    id?: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleTypeId: number
    brands?: YearBrandUncheckedCreateNestedManyWithoutVehicleYearInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearUpdateInput = {
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleType?: VehicleTypeUpdateOneRequiredWithoutYearsNestedInput
    brands?: YearBrandUpdateManyWithoutVehicleYearNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutVehicleYearNestedInput
  }

  export type VehicleYearUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleTypeId?: IntFieldUpdateOperationsInput | number
    brands?: YearBrandUncheckedUpdateManyWithoutVehicleYearNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVehicleYearNestedInput
  }

  export type VehicleYearCreateManyInput = {
    id?: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleTypeId: number
  }

  export type VehicleYearUpdateManyMutationInput = {
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleYearUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearBrandCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleYear: VehicleYearCreateNestedOneWithoutBrandsInput
    brand: BrandCreateNestedOneWithoutYearBrandsInput
    models?: YearModelCreateNestedManyWithoutYearBrandInput
  }

  export type YearBrandUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearId: number
    brandId: number
    models?: YearModelUncheckedCreateNestedManyWithoutYearBrandInput
  }

  export type YearBrandUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleYear?: VehicleYearUpdateOneRequiredWithoutBrandsNestedInput
    brand?: BrandUpdateOneRequiredWithoutYearBrandsNestedInput
    models?: YearModelUpdateManyWithoutYearBrandNestedInput
  }

  export type YearBrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    models?: YearModelUncheckedUpdateManyWithoutYearBrandNestedInput
  }

  export type YearBrandCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearId: number
    brandId: number
  }

  export type YearBrandUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearBrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
  }

  export type BrandCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrands?: YearBrandCreateNestedManyWithoutBrandInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrands?: YearBrandUncheckedCreateNestedManyWithoutBrandInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrands?: YearBrandUpdateManyWithoutBrandNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrands?: YearBrandUncheckedUpdateManyWithoutBrandNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrand: YearBrandCreateNestedOneWithoutModelsInput
    model: ModelCreateNestedOneWithoutYearModelsInput
    versions?: YearModelVersionCreateNestedManyWithoutYearModelInput
  }

  export type YearModelUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrandId: number
    modelId: number
    versions?: YearModelVersionUncheckedCreateNestedManyWithoutYearModelInput
  }

  export type YearModelUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrand?: YearBrandUpdateOneRequiredWithoutModelsNestedInput
    model?: ModelUpdateOneRequiredWithoutYearModelsNestedInput
    versions?: YearModelVersionUpdateManyWithoutYearModelNestedInput
  }

  export type YearModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrandId?: IntFieldUpdateOperationsInput | number
    modelId?: IntFieldUpdateOperationsInput | number
    versions?: YearModelVersionUncheckedUpdateManyWithoutYearModelNestedInput
  }

  export type YearModelCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrandId: number
    modelId: number
  }

  export type YearModelUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrandId?: IntFieldUpdateOperationsInput | number
    modelId?: IntFieldUpdateOperationsInput | number
  }

  export type ModelCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModels?: YearModelCreateNestedManyWithoutModelInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModels?: YearModelUncheckedCreateNestedManyWithoutModelInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModels?: YearModelUpdateManyWithoutModelNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModels?: YearModelUncheckedUpdateManyWithoutModelNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutModelNestedInput
  }

  export type ModelCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModel: YearModelCreateNestedOneWithoutVersionsInput
    version: VersionCreateNestedOneWithoutYearModelVersionsInput
    bodyTypes?: YearModelVersionBodyTypeCreateNestedManyWithoutYearModelVersionInput
  }

  export type YearModelVersionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelId: number
    versionId: number
    bodyTypes?: YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutYearModelVersionInput
  }

  export type YearModelVersionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModel?: YearModelUpdateOneRequiredWithoutVersionsNestedInput
    version?: VersionUpdateOneRequiredWithoutYearModelVersionsNestedInput
    bodyTypes?: YearModelVersionBodyTypeUpdateManyWithoutYearModelVersionNestedInput
  }

  export type YearModelVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    bodyTypes?: YearModelVersionBodyTypeUncheckedUpdateManyWithoutYearModelVersionNestedInput
  }

  export type YearModelVersionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelId: number
    versionId: number
  }

  export type YearModelVersionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
  }

  export type VersionCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersions?: YearModelVersionCreateNestedManyWithoutVersionInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersions?: YearModelVersionUncheckedCreateNestedManyWithoutVersionInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersions?: YearModelVersionUpdateManyWithoutVersionNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersions?: YearModelVersionUncheckedUpdateManyWithoutVersionNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionBodyTypeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersion: YearModelVersionCreateNestedOneWithoutBodyTypesInput
    bodyType: BodyTypeCreateNestedOneWithoutYearModelVersionBodyTypesInput
    fuelTypes?: YearModelVersionBodyTypeFuelCreateNestedManyWithoutYearModelVersionBodyTypeInput
  }

  export type YearModelVersionBodyTypeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionId: number
    bodyTypeId: number
    fuelTypes?: YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeInput
  }

  export type YearModelVersionBodyTypeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersion?: YearModelVersionUpdateOneRequiredWithoutBodyTypesNestedInput
    bodyType?: BodyTypeUpdateOneRequiredWithoutYearModelVersionBodyTypesNestedInput
    fuelTypes?: YearModelVersionBodyTypeFuelUpdateManyWithoutYearModelVersionBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionId?: IntFieldUpdateOperationsInput | number
    bodyTypeId?: IntFieldUpdateOperationsInput | number
    fuelTypes?: YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutYearModelVersionBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionId: number
    bodyTypeId: number
  }

  export type YearModelVersionBodyTypeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionBodyTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionId?: IntFieldUpdateOperationsInput | number
    bodyTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type BodyTypeCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeCreateNestedManyWithoutBodyTypeInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutBodyTypeInput
  }

  export type BodyTypeUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutBodyTypeInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutBodyTypeInput
  }

  export type BodyTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeUpdateManyWithoutBodyTypeNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutBodyTypeNestedInput
  }

  export type BodyTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeUncheckedUpdateManyWithoutBodyTypeNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutBodyTypeNestedInput
  }

  export type BodyTypeCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BodyTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BodyTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionBodyTypeFuelCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyType: YearModelVersionBodyTypeCreateNestedOneWithoutFuelTypesInput
    fuelType: FuelTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelsInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeId: number
    fuelTypeId: number
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput
  }

  export type YearModelVersionBodyTypeFuelUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyType?: YearModelVersionBodyTypeUpdateOneRequiredWithoutFuelTypesNestedInput
    fuelType?: FuelTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelsNestedInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeId?: IntFieldUpdateOperationsInput | number
    fuelTypeId?: IntFieldUpdateOperationsInput | number
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput
  }

  export type YearModelVersionBodyTypeFuelCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeId: number
    fuelTypeId: number
  }

  export type YearModelVersionBodyTypeFuelUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeId?: IntFieldUpdateOperationsInput | number
    fuelTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type FuelTypeCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelCreateNestedManyWithoutFuelTypeInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutFuelTypeInput
  }

  export type FuelTypeUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutFuelTypeInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutFuelTypeInput
  }

  export type FuelTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelUpdateManyWithoutFuelTypeNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutFuelTypeNestedInput
  }

  export type FuelTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutFuelTypeNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutFuelTypeNestedInput
  }

  export type FuelTypeCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FuelTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FuelTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuel: YearModelVersionBodyTypeFuelCreateNestedOneWithoutTransmissionTypesInput
    transmissionType: TransmissionTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelTransmissionsInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelId: number
    transmissionTypeId: number
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuel?: YearModelVersionBodyTypeFuelUpdateOneRequiredWithoutTransmissionTypesNestedInput
    transmissionType?: TransmissionTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelTransmissionsNestedInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelId?: IntFieldUpdateOperationsInput | number
    transmissionTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelId: number
    transmissionTypeId: number
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelId?: IntFieldUpdateOperationsInput | number
    transmissionTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type TransmissionTypeCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutTransmissionTypeInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutTransmissionTypeInput
  }

  export type TransmissionTypeUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutTransmissionTypeInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutTransmissionTypeInput
  }

  export type TransmissionTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutTransmissionTypeNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutTransmissionTypeNestedInput
  }

  export type TransmissionTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutTransmissionTypeNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutTransmissionTypeNestedInput
  }

  export type TransmissionTypeCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransmissionTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransmissionTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutColorInput
  }

  export type ColorUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutColorInput
  }

  export type ColorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutColorNestedInput
  }

  export type ColorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutColorNestedInput
  }

  export type ColorCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageCreateInput = {
    url: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffer: VehicleOfferCreateNestedOneWithoutImagesInput
  }

  export type VehicleImageUncheckedCreateInput = {
    id?: number
    url: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOfferId: number
  }

  export type VehicleImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffer?: VehicleOfferUpdateOneRequiredWithoutImagesNestedInput
  }

  export type VehicleImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOfferId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleImageCreateManyInput = {
    id?: number
    url: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOfferId: number
  }

  export type VehicleImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOfferId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferCreateInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUpdateInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferCreateManyInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type VehicleOfferUpdateManyMutationInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleOfferUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VehicleYearListRelationFilter = {
    every?: VehicleYearWhereInput
    some?: VehicleYearWhereInput
    none?: VehicleYearWhereInput
  }

  export type VehicleOfferListRelationFilter = {
    every?: VehicleOfferWhereInput
    some?: VehicleOfferWhereInput
    none?: VehicleOfferWhereInput
  }

  export type VehicleYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VehicleTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type VehicleTypeScalarRelationFilter = {
    is?: VehicleTypeWhereInput
    isNot?: VehicleTypeWhereInput
  }

  export type YearBrandListRelationFilter = {
    every?: YearBrandWhereInput
    some?: YearBrandWhereInput
    none?: YearBrandWhereInput
  }

  export type YearBrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleYearVehicleTypeIdYearCompoundUniqueInput = {
    vehicleTypeId: number
    year: number
  }

  export type VehicleYearCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleTypeId?: SortOrder
  }

  export type VehicleYearAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    vehicleTypeId?: SortOrder
  }

  export type VehicleYearMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleTypeId?: SortOrder
  }

  export type VehicleYearMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleTypeId?: SortOrder
  }

  export type VehicleYearSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    vehicleTypeId?: SortOrder
  }

  export type VehicleYearScalarRelationFilter = {
    is?: VehicleYearWhereInput
    isNot?: VehicleYearWhereInput
  }

  export type BrandScalarRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type YearModelListRelationFilter = {
    every?: YearModelWhereInput
    some?: YearModelWhereInput
    none?: YearModelWhereInput
  }

  export type YearModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearBrandYearIdBrandIdCompoundUniqueInput = {
    yearId: number
    brandId: number
  }

  export type YearBrandCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
  }

  export type YearBrandAvgOrderByAggregateInput = {
    id?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
  }

  export type YearBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
  }

  export type YearBrandMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
  }

  export type YearBrandSumOrderByAggregateInput = {
    id?: SortOrder
    yearId?: SortOrder
    brandId?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YearBrandScalarRelationFilter = {
    is?: YearBrandWhereInput
    isNot?: YearBrandWhereInput
  }

  export type ModelScalarRelationFilter = {
    is?: ModelWhereInput
    isNot?: ModelWhereInput
  }

  export type YearModelVersionListRelationFilter = {
    every?: YearModelVersionWhereInput
    some?: YearModelVersionWhereInput
    none?: YearModelVersionWhereInput
  }

  export type YearModelVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearModelYearBrandIdModelIdCompoundUniqueInput = {
    yearBrandId: number
    modelId: number
  }

  export type YearModelCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
  }

  export type YearModelAvgOrderByAggregateInput = {
    id?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
  }

  export type YearModelMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
  }

  export type YearModelMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
  }

  export type YearModelSumOrderByAggregateInput = {
    id?: SortOrder
    yearBrandId?: SortOrder
    modelId?: SortOrder
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YearModelScalarRelationFilter = {
    is?: YearModelWhereInput
    isNot?: YearModelWhereInput
  }

  export type VersionScalarRelationFilter = {
    is?: VersionWhereInput
    isNot?: VersionWhereInput
  }

  export type YearModelVersionBodyTypeListRelationFilter = {
    every?: YearModelVersionBodyTypeWhereInput
    some?: YearModelVersionBodyTypeWhereInput
    none?: YearModelVersionBodyTypeWhereInput
  }

  export type YearModelVersionBodyTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearModelVersionYearModelIdVersionIdCompoundUniqueInput = {
    yearModelId: number
    versionId: number
  }

  export type YearModelVersionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
  }

  export type YearModelVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
  }

  export type YearModelVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
  }

  export type YearModelVersionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
  }

  export type YearModelVersionSumOrderByAggregateInput = {
    id?: SortOrder
    yearModelId?: SortOrder
    versionId?: SortOrder
  }

  export type VersionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VersionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YearModelVersionScalarRelationFilter = {
    is?: YearModelVersionWhereInput
    isNot?: YearModelVersionWhereInput
  }

  export type BodyTypeScalarRelationFilter = {
    is?: BodyTypeWhereInput
    isNot?: BodyTypeWhereInput
  }

  export type YearModelVersionBodyTypeFuelListRelationFilter = {
    every?: YearModelVersionBodyTypeFuelWhereInput
    some?: YearModelVersionBodyTypeFuelWhereInput
    none?: YearModelVersionBodyTypeFuelWhereInput
  }

  export type YearModelVersionBodyTypeFuelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearModelVersionBodyTypeYearModelVersionIdBodyTypeIdCompoundUniqueInput = {
    yearModelVersionId: number
    bodyTypeId: number
  }

  export type YearModelVersionBodyTypeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeSumOrderByAggregateInput = {
    id?: SortOrder
    yearModelVersionId?: SortOrder
    bodyTypeId?: SortOrder
  }

  export type BodyTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BodyTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BodyTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BodyTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BodyTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YearModelVersionBodyTypeScalarRelationFilter = {
    is?: YearModelVersionBodyTypeWhereInput
    isNot?: YearModelVersionBodyTypeWhereInput
  }

  export type FuelTypeScalarRelationFilter = {
    is?: FuelTypeWhereInput
    isNot?: FuelTypeWhereInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionListRelationFilter = {
    every?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    some?: YearModelVersionBodyTypeFuelTransmissionWhereInput
    none?: YearModelVersionBodyTypeFuelTransmissionWhereInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelYearModelVersionBodyTypeIdFuelTypeIdCompoundUniqueInput = {
    yearModelVersionBodyTypeId: number
    fuelTypeId: number
  }

  export type YearModelVersionBodyTypeFuelCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelAvgOrderByAggregateInput = {
    id?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelSumOrderByAggregateInput = {
    id?: SortOrder
    yearModelVersionBodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
  }

  export type FuelTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FuelTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FuelTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FuelTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FuelTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelScalarRelationFilter = {
    is?: YearModelVersionBodyTypeFuelWhereInput
    isNot?: YearModelVersionBodyTypeFuelWhereInput
  }

  export type TransmissionTypeScalarRelationFilter = {
    is?: TransmissionTypeWhereInput
    isNot?: TransmissionTypeWhereInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionYearModelVersionBodyTypeFuelIdTransmissionTypeIdCompoundUniqueInput = {
    yearModelVersionBodyTypeFuelId: number
    transmissionTypeId: number
  }

  export type YearModelVersionBodyTypeFuelTransmissionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelTransmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelTransmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelTransmissionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
  }

  export type YearModelVersionBodyTypeFuelTransmissionSumOrderByAggregateInput = {
    id?: SortOrder
    yearModelVersionBodyTypeFuelId?: SortOrder
    transmissionTypeId?: SortOrder
  }

  export type TransmissionTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransmissionTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TransmissionTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransmissionTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransmissionTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ColorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ColorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ColorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VehicleOfferScalarRelationFilter = {
    is?: VehicleOfferWhereInput
    isNot?: VehicleOfferWhereInput
  }

  export type VehicleImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleOfferId?: SortOrder
  }

  export type VehicleImageAvgOrderByAggregateInput = {
    id?: SortOrder
    vehicleOfferId?: SortOrder
  }

  export type VehicleImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleOfferId?: SortOrder
  }

  export type VehicleImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicleOfferId?: SortOrder
  }

  export type VehicleImageSumOrderByAggregateInput = {
    id?: SortOrder
    vehicleOfferId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type VehicleTypeNullableScalarRelationFilter = {
    is?: VehicleTypeWhereInput | null
    isNot?: VehicleTypeWhereInput | null
  }

  export type VehicleYearNullableScalarRelationFilter = {
    is?: VehicleYearWhereInput | null
    isNot?: VehicleYearWhereInput | null
  }

  export type BrandNullableScalarRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type ModelNullableScalarRelationFilter = {
    is?: ModelWhereInput | null
    isNot?: ModelWhereInput | null
  }

  export type VersionNullableScalarRelationFilter = {
    is?: VersionWhereInput | null
    isNot?: VersionWhereInput | null
  }

  export type BodyTypeNullableScalarRelationFilter = {
    is?: BodyTypeWhereInput | null
    isNot?: BodyTypeWhereInput | null
  }

  export type FuelTypeNullableScalarRelationFilter = {
    is?: FuelTypeWhereInput | null
    isNot?: FuelTypeWhereInput | null
  }

  export type TransmissionTypeNullableScalarRelationFilter = {
    is?: TransmissionTypeWhereInput | null
    isNot?: TransmissionTypeWhereInput | null
  }

  export type ColorNullableScalarRelationFilter = {
    is?: ColorWhereInput | null
    isNot?: ColorWhereInput | null
  }

  export type VehicleImageListRelationFilter = {
    every?: VehicleImageWhereInput
    some?: VehicleImageWhereInput
    none?: VehicleImageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VehicleImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleOfferCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    kilometer?: SortOrder
    accidentStatus?: SortOrder
    accidentAmount?: SortOrder
    status?: SortOrder
    price?: SortOrder
    displayValues?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    vehicleTypeId?: SortOrder
    vehicleYearId?: SortOrder
    brandId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    bodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    transmissionTypeId?: SortOrder
    colorId?: SortOrder
    notes?: SortOrder
    adminNotes?: SortOrder
    description?: SortOrder
    registrationDate?: SortOrder
    listingStatus?: SortOrder
  }

  export type VehicleOfferAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    kilometer?: SortOrder
    accidentAmount?: SortOrder
    price?: SortOrder
    vehicleTypeId?: SortOrder
    vehicleYearId?: SortOrder
    brandId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    bodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    transmissionTypeId?: SortOrder
    colorId?: SortOrder
  }

  export type VehicleOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    kilometer?: SortOrder
    accidentStatus?: SortOrder
    accidentAmount?: SortOrder
    status?: SortOrder
    price?: SortOrder
    displayValues?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    vehicleTypeId?: SortOrder
    vehicleYearId?: SortOrder
    brandId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    bodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    transmissionTypeId?: SortOrder
    colorId?: SortOrder
    notes?: SortOrder
    adminNotes?: SortOrder
    description?: SortOrder
    registrationDate?: SortOrder
    listingStatus?: SortOrder
  }

  export type VehicleOfferMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    kilometer?: SortOrder
    accidentStatus?: SortOrder
    accidentAmount?: SortOrder
    status?: SortOrder
    price?: SortOrder
    displayValues?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    processedAt?: SortOrder
    vehicleTypeId?: SortOrder
    vehicleYearId?: SortOrder
    brandId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    bodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    transmissionTypeId?: SortOrder
    colorId?: SortOrder
    notes?: SortOrder
    adminNotes?: SortOrder
    description?: SortOrder
    registrationDate?: SortOrder
    listingStatus?: SortOrder
  }

  export type VehicleOfferSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    kilometer?: SortOrder
    accidentAmount?: SortOrder
    price?: SortOrder
    vehicleTypeId?: SortOrder
    vehicleYearId?: SortOrder
    brandId?: SortOrder
    modelId?: SortOrder
    versionId?: SortOrder
    bodyTypeId?: SortOrder
    fuelTypeId?: SortOrder
    transmissionTypeId?: SortOrder
    colorId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VehicleYearCreateNestedManyWithoutVehicleTypeInput = {
    create?: XOR<VehicleYearCreateWithoutVehicleTypeInput, VehicleYearUncheckedCreateWithoutVehicleTypeInput> | VehicleYearCreateWithoutVehicleTypeInput[] | VehicleYearUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleYearCreateOrConnectWithoutVehicleTypeInput | VehicleYearCreateOrConnectWithoutVehicleTypeInput[]
    createMany?: VehicleYearCreateManyVehicleTypeInputEnvelope
    connect?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutVehicleTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleTypeInput, VehicleOfferUncheckedCreateWithoutVehicleTypeInput> | VehicleOfferCreateWithoutVehicleTypeInput[] | VehicleOfferUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleTypeInput | VehicleOfferCreateOrConnectWithoutVehicleTypeInput[]
    createMany?: VehicleOfferCreateManyVehicleTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type VehicleYearUncheckedCreateNestedManyWithoutVehicleTypeInput = {
    create?: XOR<VehicleYearCreateWithoutVehicleTypeInput, VehicleYearUncheckedCreateWithoutVehicleTypeInput> | VehicleYearCreateWithoutVehicleTypeInput[] | VehicleYearUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleYearCreateOrConnectWithoutVehicleTypeInput | VehicleYearCreateOrConnectWithoutVehicleTypeInput[]
    createMany?: VehicleYearCreateManyVehicleTypeInputEnvelope
    connect?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutVehicleTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleTypeInput, VehicleOfferUncheckedCreateWithoutVehicleTypeInput> | VehicleOfferCreateWithoutVehicleTypeInput[] | VehicleOfferUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleTypeInput | VehicleOfferCreateOrConnectWithoutVehicleTypeInput[]
    createMany?: VehicleOfferCreateManyVehicleTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type VehicleYearUpdateManyWithoutVehicleTypeNestedInput = {
    create?: XOR<VehicleYearCreateWithoutVehicleTypeInput, VehicleYearUncheckedCreateWithoutVehicleTypeInput> | VehicleYearCreateWithoutVehicleTypeInput[] | VehicleYearUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleYearCreateOrConnectWithoutVehicleTypeInput | VehicleYearCreateOrConnectWithoutVehicleTypeInput[]
    upsert?: VehicleYearUpsertWithWhereUniqueWithoutVehicleTypeInput | VehicleYearUpsertWithWhereUniqueWithoutVehicleTypeInput[]
    createMany?: VehicleYearCreateManyVehicleTypeInputEnvelope
    set?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    disconnect?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    delete?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    connect?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    update?: VehicleYearUpdateWithWhereUniqueWithoutVehicleTypeInput | VehicleYearUpdateWithWhereUniqueWithoutVehicleTypeInput[]
    updateMany?: VehicleYearUpdateManyWithWhereWithoutVehicleTypeInput | VehicleYearUpdateManyWithWhereWithoutVehicleTypeInput[]
    deleteMany?: VehicleYearScalarWhereInput | VehicleYearScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutVehicleTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleTypeInput, VehicleOfferUncheckedCreateWithoutVehicleTypeInput> | VehicleOfferCreateWithoutVehicleTypeInput[] | VehicleOfferUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleTypeInput | VehicleOfferCreateOrConnectWithoutVehicleTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutVehicleTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutVehicleTypeInput[]
    createMany?: VehicleOfferCreateManyVehicleTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutVehicleTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutVehicleTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutVehicleTypeInput | VehicleOfferUpdateManyWithWhereWithoutVehicleTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VehicleYearUncheckedUpdateManyWithoutVehicleTypeNestedInput = {
    create?: XOR<VehicleYearCreateWithoutVehicleTypeInput, VehicleYearUncheckedCreateWithoutVehicleTypeInput> | VehicleYearCreateWithoutVehicleTypeInput[] | VehicleYearUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleYearCreateOrConnectWithoutVehicleTypeInput | VehicleYearCreateOrConnectWithoutVehicleTypeInput[]
    upsert?: VehicleYearUpsertWithWhereUniqueWithoutVehicleTypeInput | VehicleYearUpsertWithWhereUniqueWithoutVehicleTypeInput[]
    createMany?: VehicleYearCreateManyVehicleTypeInputEnvelope
    set?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    disconnect?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    delete?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    connect?: VehicleYearWhereUniqueInput | VehicleYearWhereUniqueInput[]
    update?: VehicleYearUpdateWithWhereUniqueWithoutVehicleTypeInput | VehicleYearUpdateWithWhereUniqueWithoutVehicleTypeInput[]
    updateMany?: VehicleYearUpdateManyWithWhereWithoutVehicleTypeInput | VehicleYearUpdateManyWithWhereWithoutVehicleTypeInput[]
    deleteMany?: VehicleYearScalarWhereInput | VehicleYearScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutVehicleTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleTypeInput, VehicleOfferUncheckedCreateWithoutVehicleTypeInput> | VehicleOfferCreateWithoutVehicleTypeInput[] | VehicleOfferUncheckedCreateWithoutVehicleTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleTypeInput | VehicleOfferCreateOrConnectWithoutVehicleTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutVehicleTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutVehicleTypeInput[]
    createMany?: VehicleOfferCreateManyVehicleTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutVehicleTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutVehicleTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutVehicleTypeInput | VehicleOfferUpdateManyWithWhereWithoutVehicleTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type VehicleTypeCreateNestedOneWithoutYearsInput = {
    create?: XOR<VehicleTypeCreateWithoutYearsInput, VehicleTypeUncheckedCreateWithoutYearsInput>
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutYearsInput
    connect?: VehicleTypeWhereUniqueInput
  }

  export type YearBrandCreateNestedManyWithoutVehicleYearInput = {
    create?: XOR<YearBrandCreateWithoutVehicleYearInput, YearBrandUncheckedCreateWithoutVehicleYearInput> | YearBrandCreateWithoutVehicleYearInput[] | YearBrandUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutVehicleYearInput | YearBrandCreateOrConnectWithoutVehicleYearInput[]
    createMany?: YearBrandCreateManyVehicleYearInputEnvelope
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutVehicleYearInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleYearInput, VehicleOfferUncheckedCreateWithoutVehicleYearInput> | VehicleOfferCreateWithoutVehicleYearInput[] | VehicleOfferUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleYearInput | VehicleOfferCreateOrConnectWithoutVehicleYearInput[]
    createMany?: VehicleOfferCreateManyVehicleYearInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearBrandUncheckedCreateNestedManyWithoutVehicleYearInput = {
    create?: XOR<YearBrandCreateWithoutVehicleYearInput, YearBrandUncheckedCreateWithoutVehicleYearInput> | YearBrandCreateWithoutVehicleYearInput[] | YearBrandUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutVehicleYearInput | YearBrandCreateOrConnectWithoutVehicleYearInput[]
    createMany?: YearBrandCreateManyVehicleYearInputEnvelope
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutVehicleYearInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleYearInput, VehicleOfferUncheckedCreateWithoutVehicleYearInput> | VehicleOfferCreateWithoutVehicleYearInput[] | VehicleOfferUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleYearInput | VehicleOfferCreateOrConnectWithoutVehicleYearInput[]
    createMany?: VehicleOfferCreateManyVehicleYearInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type VehicleTypeUpdateOneRequiredWithoutYearsNestedInput = {
    create?: XOR<VehicleTypeCreateWithoutYearsInput, VehicleTypeUncheckedCreateWithoutYearsInput>
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutYearsInput
    upsert?: VehicleTypeUpsertWithoutYearsInput
    connect?: VehicleTypeWhereUniqueInput
    update?: XOR<XOR<VehicleTypeUpdateToOneWithWhereWithoutYearsInput, VehicleTypeUpdateWithoutYearsInput>, VehicleTypeUncheckedUpdateWithoutYearsInput>
  }

  export type YearBrandUpdateManyWithoutVehicleYearNestedInput = {
    create?: XOR<YearBrandCreateWithoutVehicleYearInput, YearBrandUncheckedCreateWithoutVehicleYearInput> | YearBrandCreateWithoutVehicleYearInput[] | YearBrandUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutVehicleYearInput | YearBrandCreateOrConnectWithoutVehicleYearInput[]
    upsert?: YearBrandUpsertWithWhereUniqueWithoutVehicleYearInput | YearBrandUpsertWithWhereUniqueWithoutVehicleYearInput[]
    createMany?: YearBrandCreateManyVehicleYearInputEnvelope
    set?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    disconnect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    delete?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    update?: YearBrandUpdateWithWhereUniqueWithoutVehicleYearInput | YearBrandUpdateWithWhereUniqueWithoutVehicleYearInput[]
    updateMany?: YearBrandUpdateManyWithWhereWithoutVehicleYearInput | YearBrandUpdateManyWithWhereWithoutVehicleYearInput[]
    deleteMany?: YearBrandScalarWhereInput | YearBrandScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutVehicleYearNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleYearInput, VehicleOfferUncheckedCreateWithoutVehicleYearInput> | VehicleOfferCreateWithoutVehicleYearInput[] | VehicleOfferUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleYearInput | VehicleOfferCreateOrConnectWithoutVehicleYearInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutVehicleYearInput | VehicleOfferUpsertWithWhereUniqueWithoutVehicleYearInput[]
    createMany?: VehicleOfferCreateManyVehicleYearInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutVehicleYearInput | VehicleOfferUpdateWithWhereUniqueWithoutVehicleYearInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutVehicleYearInput | VehicleOfferUpdateManyWithWhereWithoutVehicleYearInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearBrandUncheckedUpdateManyWithoutVehicleYearNestedInput = {
    create?: XOR<YearBrandCreateWithoutVehicleYearInput, YearBrandUncheckedCreateWithoutVehicleYearInput> | YearBrandCreateWithoutVehicleYearInput[] | YearBrandUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutVehicleYearInput | YearBrandCreateOrConnectWithoutVehicleYearInput[]
    upsert?: YearBrandUpsertWithWhereUniqueWithoutVehicleYearInput | YearBrandUpsertWithWhereUniqueWithoutVehicleYearInput[]
    createMany?: YearBrandCreateManyVehicleYearInputEnvelope
    set?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    disconnect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    delete?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    update?: YearBrandUpdateWithWhereUniqueWithoutVehicleYearInput | YearBrandUpdateWithWhereUniqueWithoutVehicleYearInput[]
    updateMany?: YearBrandUpdateManyWithWhereWithoutVehicleYearInput | YearBrandUpdateManyWithWhereWithoutVehicleYearInput[]
    deleteMany?: YearBrandScalarWhereInput | YearBrandScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutVehicleYearNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutVehicleYearInput, VehicleOfferUncheckedCreateWithoutVehicleYearInput> | VehicleOfferCreateWithoutVehicleYearInput[] | VehicleOfferUncheckedCreateWithoutVehicleYearInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVehicleYearInput | VehicleOfferCreateOrConnectWithoutVehicleYearInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutVehicleYearInput | VehicleOfferUpsertWithWhereUniqueWithoutVehicleYearInput[]
    createMany?: VehicleOfferCreateManyVehicleYearInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutVehicleYearInput | VehicleOfferUpdateWithWhereUniqueWithoutVehicleYearInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutVehicleYearInput | VehicleOfferUpdateManyWithWhereWithoutVehicleYearInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type VehicleYearCreateNestedOneWithoutBrandsInput = {
    create?: XOR<VehicleYearCreateWithoutBrandsInput, VehicleYearUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: VehicleYearCreateOrConnectWithoutBrandsInput
    connect?: VehicleYearWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutYearBrandsInput = {
    create?: XOR<BrandCreateWithoutYearBrandsInput, BrandUncheckedCreateWithoutYearBrandsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutYearBrandsInput
    connect?: BrandWhereUniqueInput
  }

  export type YearModelCreateNestedManyWithoutYearBrandInput = {
    create?: XOR<YearModelCreateWithoutYearBrandInput, YearModelUncheckedCreateWithoutYearBrandInput> | YearModelCreateWithoutYearBrandInput[] | YearModelUncheckedCreateWithoutYearBrandInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutYearBrandInput | YearModelCreateOrConnectWithoutYearBrandInput[]
    createMany?: YearModelCreateManyYearBrandInputEnvelope
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
  }

  export type YearModelUncheckedCreateNestedManyWithoutYearBrandInput = {
    create?: XOR<YearModelCreateWithoutYearBrandInput, YearModelUncheckedCreateWithoutYearBrandInput> | YearModelCreateWithoutYearBrandInput[] | YearModelUncheckedCreateWithoutYearBrandInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutYearBrandInput | YearModelCreateOrConnectWithoutYearBrandInput[]
    createMany?: YearModelCreateManyYearBrandInputEnvelope
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
  }

  export type VehicleYearUpdateOneRequiredWithoutBrandsNestedInput = {
    create?: XOR<VehicleYearCreateWithoutBrandsInput, VehicleYearUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: VehicleYearCreateOrConnectWithoutBrandsInput
    upsert?: VehicleYearUpsertWithoutBrandsInput
    connect?: VehicleYearWhereUniqueInput
    update?: XOR<XOR<VehicleYearUpdateToOneWithWhereWithoutBrandsInput, VehicleYearUpdateWithoutBrandsInput>, VehicleYearUncheckedUpdateWithoutBrandsInput>
  }

  export type BrandUpdateOneRequiredWithoutYearBrandsNestedInput = {
    create?: XOR<BrandCreateWithoutYearBrandsInput, BrandUncheckedCreateWithoutYearBrandsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutYearBrandsInput
    upsert?: BrandUpsertWithoutYearBrandsInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutYearBrandsInput, BrandUpdateWithoutYearBrandsInput>, BrandUncheckedUpdateWithoutYearBrandsInput>
  }

  export type YearModelUpdateManyWithoutYearBrandNestedInput = {
    create?: XOR<YearModelCreateWithoutYearBrandInput, YearModelUncheckedCreateWithoutYearBrandInput> | YearModelCreateWithoutYearBrandInput[] | YearModelUncheckedCreateWithoutYearBrandInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutYearBrandInput | YearModelCreateOrConnectWithoutYearBrandInput[]
    upsert?: YearModelUpsertWithWhereUniqueWithoutYearBrandInput | YearModelUpsertWithWhereUniqueWithoutYearBrandInput[]
    createMany?: YearModelCreateManyYearBrandInputEnvelope
    set?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    disconnect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    delete?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    update?: YearModelUpdateWithWhereUniqueWithoutYearBrandInput | YearModelUpdateWithWhereUniqueWithoutYearBrandInput[]
    updateMany?: YearModelUpdateManyWithWhereWithoutYearBrandInput | YearModelUpdateManyWithWhereWithoutYearBrandInput[]
    deleteMany?: YearModelScalarWhereInput | YearModelScalarWhereInput[]
  }

  export type YearModelUncheckedUpdateManyWithoutYearBrandNestedInput = {
    create?: XOR<YearModelCreateWithoutYearBrandInput, YearModelUncheckedCreateWithoutYearBrandInput> | YearModelCreateWithoutYearBrandInput[] | YearModelUncheckedCreateWithoutYearBrandInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutYearBrandInput | YearModelCreateOrConnectWithoutYearBrandInput[]
    upsert?: YearModelUpsertWithWhereUniqueWithoutYearBrandInput | YearModelUpsertWithWhereUniqueWithoutYearBrandInput[]
    createMany?: YearModelCreateManyYearBrandInputEnvelope
    set?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    disconnect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    delete?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    update?: YearModelUpdateWithWhereUniqueWithoutYearBrandInput | YearModelUpdateWithWhereUniqueWithoutYearBrandInput[]
    updateMany?: YearModelUpdateManyWithWhereWithoutYearBrandInput | YearModelUpdateManyWithWhereWithoutYearBrandInput[]
    deleteMany?: YearModelScalarWhereInput | YearModelScalarWhereInput[]
  }

  export type YearBrandCreateNestedManyWithoutBrandInput = {
    create?: XOR<YearBrandCreateWithoutBrandInput, YearBrandUncheckedCreateWithoutBrandInput> | YearBrandCreateWithoutBrandInput[] | YearBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutBrandInput | YearBrandCreateOrConnectWithoutBrandInput[]
    createMany?: YearBrandCreateManyBrandInputEnvelope
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutBrandInput = {
    create?: XOR<VehicleOfferCreateWithoutBrandInput, VehicleOfferUncheckedCreateWithoutBrandInput> | VehicleOfferCreateWithoutBrandInput[] | VehicleOfferUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBrandInput | VehicleOfferCreateOrConnectWithoutBrandInput[]
    createMany?: VehicleOfferCreateManyBrandInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearBrandUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<YearBrandCreateWithoutBrandInput, YearBrandUncheckedCreateWithoutBrandInput> | YearBrandCreateWithoutBrandInput[] | YearBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutBrandInput | YearBrandCreateOrConnectWithoutBrandInput[]
    createMany?: YearBrandCreateManyBrandInputEnvelope
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<VehicleOfferCreateWithoutBrandInput, VehicleOfferUncheckedCreateWithoutBrandInput> | VehicleOfferCreateWithoutBrandInput[] | VehicleOfferUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBrandInput | VehicleOfferCreateOrConnectWithoutBrandInput[]
    createMany?: VehicleOfferCreateManyBrandInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearBrandUpdateManyWithoutBrandNestedInput = {
    create?: XOR<YearBrandCreateWithoutBrandInput, YearBrandUncheckedCreateWithoutBrandInput> | YearBrandCreateWithoutBrandInput[] | YearBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutBrandInput | YearBrandCreateOrConnectWithoutBrandInput[]
    upsert?: YearBrandUpsertWithWhereUniqueWithoutBrandInput | YearBrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: YearBrandCreateManyBrandInputEnvelope
    set?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    disconnect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    delete?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    update?: YearBrandUpdateWithWhereUniqueWithoutBrandInput | YearBrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: YearBrandUpdateManyWithWhereWithoutBrandInput | YearBrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: YearBrandScalarWhereInput | YearBrandScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutBrandNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutBrandInput, VehicleOfferUncheckedCreateWithoutBrandInput> | VehicleOfferCreateWithoutBrandInput[] | VehicleOfferUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBrandInput | VehicleOfferCreateOrConnectWithoutBrandInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutBrandInput | VehicleOfferUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: VehicleOfferCreateManyBrandInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutBrandInput | VehicleOfferUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutBrandInput | VehicleOfferUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearBrandUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<YearBrandCreateWithoutBrandInput, YearBrandUncheckedCreateWithoutBrandInput> | YearBrandCreateWithoutBrandInput[] | YearBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: YearBrandCreateOrConnectWithoutBrandInput | YearBrandCreateOrConnectWithoutBrandInput[]
    upsert?: YearBrandUpsertWithWhereUniqueWithoutBrandInput | YearBrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: YearBrandCreateManyBrandInputEnvelope
    set?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    disconnect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    delete?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    connect?: YearBrandWhereUniqueInput | YearBrandWhereUniqueInput[]
    update?: YearBrandUpdateWithWhereUniqueWithoutBrandInput | YearBrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: YearBrandUpdateManyWithWhereWithoutBrandInput | YearBrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: YearBrandScalarWhereInput | YearBrandScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutBrandInput, VehicleOfferUncheckedCreateWithoutBrandInput> | VehicleOfferCreateWithoutBrandInput[] | VehicleOfferUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBrandInput | VehicleOfferCreateOrConnectWithoutBrandInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutBrandInput | VehicleOfferUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: VehicleOfferCreateManyBrandInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutBrandInput | VehicleOfferUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutBrandInput | VehicleOfferUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearBrandCreateNestedOneWithoutModelsInput = {
    create?: XOR<YearBrandCreateWithoutModelsInput, YearBrandUncheckedCreateWithoutModelsInput>
    connectOrCreate?: YearBrandCreateOrConnectWithoutModelsInput
    connect?: YearBrandWhereUniqueInput
  }

  export type ModelCreateNestedOneWithoutYearModelsInput = {
    create?: XOR<ModelCreateWithoutYearModelsInput, ModelUncheckedCreateWithoutYearModelsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutYearModelsInput
    connect?: ModelWhereUniqueInput
  }

  export type YearModelVersionCreateNestedManyWithoutYearModelInput = {
    create?: XOR<YearModelVersionCreateWithoutYearModelInput, YearModelVersionUncheckedCreateWithoutYearModelInput> | YearModelVersionCreateWithoutYearModelInput[] | YearModelVersionUncheckedCreateWithoutYearModelInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutYearModelInput | YearModelVersionCreateOrConnectWithoutYearModelInput[]
    createMany?: YearModelVersionCreateManyYearModelInputEnvelope
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
  }

  export type YearModelVersionUncheckedCreateNestedManyWithoutYearModelInput = {
    create?: XOR<YearModelVersionCreateWithoutYearModelInput, YearModelVersionUncheckedCreateWithoutYearModelInput> | YearModelVersionCreateWithoutYearModelInput[] | YearModelVersionUncheckedCreateWithoutYearModelInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutYearModelInput | YearModelVersionCreateOrConnectWithoutYearModelInput[]
    createMany?: YearModelVersionCreateManyYearModelInputEnvelope
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
  }

  export type YearBrandUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<YearBrandCreateWithoutModelsInput, YearBrandUncheckedCreateWithoutModelsInput>
    connectOrCreate?: YearBrandCreateOrConnectWithoutModelsInput
    upsert?: YearBrandUpsertWithoutModelsInput
    connect?: YearBrandWhereUniqueInput
    update?: XOR<XOR<YearBrandUpdateToOneWithWhereWithoutModelsInput, YearBrandUpdateWithoutModelsInput>, YearBrandUncheckedUpdateWithoutModelsInput>
  }

  export type ModelUpdateOneRequiredWithoutYearModelsNestedInput = {
    create?: XOR<ModelCreateWithoutYearModelsInput, ModelUncheckedCreateWithoutYearModelsInput>
    connectOrCreate?: ModelCreateOrConnectWithoutYearModelsInput
    upsert?: ModelUpsertWithoutYearModelsInput
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutYearModelsInput, ModelUpdateWithoutYearModelsInput>, ModelUncheckedUpdateWithoutYearModelsInput>
  }

  export type YearModelVersionUpdateManyWithoutYearModelNestedInput = {
    create?: XOR<YearModelVersionCreateWithoutYearModelInput, YearModelVersionUncheckedCreateWithoutYearModelInput> | YearModelVersionCreateWithoutYearModelInput[] | YearModelVersionUncheckedCreateWithoutYearModelInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutYearModelInput | YearModelVersionCreateOrConnectWithoutYearModelInput[]
    upsert?: YearModelVersionUpsertWithWhereUniqueWithoutYearModelInput | YearModelVersionUpsertWithWhereUniqueWithoutYearModelInput[]
    createMany?: YearModelVersionCreateManyYearModelInputEnvelope
    set?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    disconnect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    delete?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    update?: YearModelVersionUpdateWithWhereUniqueWithoutYearModelInput | YearModelVersionUpdateWithWhereUniqueWithoutYearModelInput[]
    updateMany?: YearModelVersionUpdateManyWithWhereWithoutYearModelInput | YearModelVersionUpdateManyWithWhereWithoutYearModelInput[]
    deleteMany?: YearModelVersionScalarWhereInput | YearModelVersionScalarWhereInput[]
  }

  export type YearModelVersionUncheckedUpdateManyWithoutYearModelNestedInput = {
    create?: XOR<YearModelVersionCreateWithoutYearModelInput, YearModelVersionUncheckedCreateWithoutYearModelInput> | YearModelVersionCreateWithoutYearModelInput[] | YearModelVersionUncheckedCreateWithoutYearModelInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutYearModelInput | YearModelVersionCreateOrConnectWithoutYearModelInput[]
    upsert?: YearModelVersionUpsertWithWhereUniqueWithoutYearModelInput | YearModelVersionUpsertWithWhereUniqueWithoutYearModelInput[]
    createMany?: YearModelVersionCreateManyYearModelInputEnvelope
    set?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    disconnect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    delete?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    update?: YearModelVersionUpdateWithWhereUniqueWithoutYearModelInput | YearModelVersionUpdateWithWhereUniqueWithoutYearModelInput[]
    updateMany?: YearModelVersionUpdateManyWithWhereWithoutYearModelInput | YearModelVersionUpdateManyWithWhereWithoutYearModelInput[]
    deleteMany?: YearModelVersionScalarWhereInput | YearModelVersionScalarWhereInput[]
  }

  export type YearModelCreateNestedManyWithoutModelInput = {
    create?: XOR<YearModelCreateWithoutModelInput, YearModelUncheckedCreateWithoutModelInput> | YearModelCreateWithoutModelInput[] | YearModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutModelInput | YearModelCreateOrConnectWithoutModelInput[]
    createMany?: YearModelCreateManyModelInputEnvelope
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutModelInput = {
    create?: XOR<VehicleOfferCreateWithoutModelInput, VehicleOfferUncheckedCreateWithoutModelInput> | VehicleOfferCreateWithoutModelInput[] | VehicleOfferUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutModelInput | VehicleOfferCreateOrConnectWithoutModelInput[]
    createMany?: VehicleOfferCreateManyModelInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<YearModelCreateWithoutModelInput, YearModelUncheckedCreateWithoutModelInput> | YearModelCreateWithoutModelInput[] | YearModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutModelInput | YearModelCreateOrConnectWithoutModelInput[]
    createMany?: YearModelCreateManyModelInputEnvelope
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<VehicleOfferCreateWithoutModelInput, VehicleOfferUncheckedCreateWithoutModelInput> | VehicleOfferCreateWithoutModelInput[] | VehicleOfferUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutModelInput | VehicleOfferCreateOrConnectWithoutModelInput[]
    createMany?: VehicleOfferCreateManyModelInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelUpdateManyWithoutModelNestedInput = {
    create?: XOR<YearModelCreateWithoutModelInput, YearModelUncheckedCreateWithoutModelInput> | YearModelCreateWithoutModelInput[] | YearModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutModelInput | YearModelCreateOrConnectWithoutModelInput[]
    upsert?: YearModelUpsertWithWhereUniqueWithoutModelInput | YearModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: YearModelCreateManyModelInputEnvelope
    set?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    disconnect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    delete?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    update?: YearModelUpdateWithWhereUniqueWithoutModelInput | YearModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: YearModelUpdateManyWithWhereWithoutModelInput | YearModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: YearModelScalarWhereInput | YearModelScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutModelNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutModelInput, VehicleOfferUncheckedCreateWithoutModelInput> | VehicleOfferCreateWithoutModelInput[] | VehicleOfferUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutModelInput | VehicleOfferCreateOrConnectWithoutModelInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutModelInput | VehicleOfferUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: VehicleOfferCreateManyModelInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutModelInput | VehicleOfferUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutModelInput | VehicleOfferUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<YearModelCreateWithoutModelInput, YearModelUncheckedCreateWithoutModelInput> | YearModelCreateWithoutModelInput[] | YearModelUncheckedCreateWithoutModelInput[]
    connectOrCreate?: YearModelCreateOrConnectWithoutModelInput | YearModelCreateOrConnectWithoutModelInput[]
    upsert?: YearModelUpsertWithWhereUniqueWithoutModelInput | YearModelUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: YearModelCreateManyModelInputEnvelope
    set?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    disconnect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    delete?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    connect?: YearModelWhereUniqueInput | YearModelWhereUniqueInput[]
    update?: YearModelUpdateWithWhereUniqueWithoutModelInput | YearModelUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: YearModelUpdateManyWithWhereWithoutModelInput | YearModelUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: YearModelScalarWhereInput | YearModelScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutModelInput, VehicleOfferUncheckedCreateWithoutModelInput> | VehicleOfferCreateWithoutModelInput[] | VehicleOfferUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutModelInput | VehicleOfferCreateOrConnectWithoutModelInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutModelInput | VehicleOfferUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: VehicleOfferCreateManyModelInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutModelInput | VehicleOfferUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutModelInput | VehicleOfferUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelCreateNestedOneWithoutVersionsInput = {
    create?: XOR<YearModelCreateWithoutVersionsInput, YearModelUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: YearModelCreateOrConnectWithoutVersionsInput
    connect?: YearModelWhereUniqueInput
  }

  export type VersionCreateNestedOneWithoutYearModelVersionsInput = {
    create?: XOR<VersionCreateWithoutYearModelVersionsInput, VersionUncheckedCreateWithoutYearModelVersionsInput>
    connectOrCreate?: VersionCreateOrConnectWithoutYearModelVersionsInput
    connect?: VersionWhereUniqueInput
  }

  export type YearModelVersionBodyTypeCreateNestedManyWithoutYearModelVersionInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput> | YearModelVersionBodyTypeCreateWithoutYearModelVersionInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput | YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput[]
    createMany?: YearModelVersionBodyTypeCreateManyYearModelVersionInputEnvelope
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutYearModelVersionInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput> | YearModelVersionBodyTypeCreateWithoutYearModelVersionInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput | YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput[]
    createMany?: YearModelVersionBodyTypeCreateManyYearModelVersionInputEnvelope
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
  }

  export type YearModelUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<YearModelCreateWithoutVersionsInput, YearModelUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: YearModelCreateOrConnectWithoutVersionsInput
    upsert?: YearModelUpsertWithoutVersionsInput
    connect?: YearModelWhereUniqueInput
    update?: XOR<XOR<YearModelUpdateToOneWithWhereWithoutVersionsInput, YearModelUpdateWithoutVersionsInput>, YearModelUncheckedUpdateWithoutVersionsInput>
  }

  export type VersionUpdateOneRequiredWithoutYearModelVersionsNestedInput = {
    create?: XOR<VersionCreateWithoutYearModelVersionsInput, VersionUncheckedCreateWithoutYearModelVersionsInput>
    connectOrCreate?: VersionCreateOrConnectWithoutYearModelVersionsInput
    upsert?: VersionUpsertWithoutYearModelVersionsInput
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutYearModelVersionsInput, VersionUpdateWithoutYearModelVersionsInput>, VersionUncheckedUpdateWithoutYearModelVersionsInput>
  }

  export type YearModelVersionBodyTypeUpdateManyWithoutYearModelVersionNestedInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput> | YearModelVersionBodyTypeCreateWithoutYearModelVersionInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput | YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput[]
    upsert?: YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutYearModelVersionInput | YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutYearModelVersionInput[]
    createMany?: YearModelVersionBodyTypeCreateManyYearModelVersionInputEnvelope
    set?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    update?: YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutYearModelVersionInput | YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutYearModelVersionInput[]
    updateMany?: YearModelVersionBodyTypeUpdateManyWithWhereWithoutYearModelVersionInput | YearModelVersionBodyTypeUpdateManyWithWhereWithoutYearModelVersionInput[]
    deleteMany?: YearModelVersionBodyTypeScalarWhereInput | YearModelVersionBodyTypeScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeUncheckedUpdateManyWithoutYearModelVersionNestedInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput> | YearModelVersionBodyTypeCreateWithoutYearModelVersionInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput | YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput[]
    upsert?: YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutYearModelVersionInput | YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutYearModelVersionInput[]
    createMany?: YearModelVersionBodyTypeCreateManyYearModelVersionInputEnvelope
    set?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    update?: YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutYearModelVersionInput | YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutYearModelVersionInput[]
    updateMany?: YearModelVersionBodyTypeUpdateManyWithWhereWithoutYearModelVersionInput | YearModelVersionBodyTypeUpdateManyWithWhereWithoutYearModelVersionInput[]
    deleteMany?: YearModelVersionBodyTypeScalarWhereInput | YearModelVersionBodyTypeScalarWhereInput[]
  }

  export type YearModelVersionCreateNestedManyWithoutVersionInput = {
    create?: XOR<YearModelVersionCreateWithoutVersionInput, YearModelVersionUncheckedCreateWithoutVersionInput> | YearModelVersionCreateWithoutVersionInput[] | YearModelVersionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutVersionInput | YearModelVersionCreateOrConnectWithoutVersionInput[]
    createMany?: YearModelVersionCreateManyVersionInputEnvelope
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutVersionInput = {
    create?: XOR<VehicleOfferCreateWithoutVersionInput, VehicleOfferUncheckedCreateWithoutVersionInput> | VehicleOfferCreateWithoutVersionInput[] | VehicleOfferUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVersionInput | VehicleOfferCreateOrConnectWithoutVersionInput[]
    createMany?: VehicleOfferCreateManyVersionInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<YearModelVersionCreateWithoutVersionInput, YearModelVersionUncheckedCreateWithoutVersionInput> | YearModelVersionCreateWithoutVersionInput[] | YearModelVersionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutVersionInput | YearModelVersionCreateOrConnectWithoutVersionInput[]
    createMany?: YearModelVersionCreateManyVersionInputEnvelope
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<VehicleOfferCreateWithoutVersionInput, VehicleOfferUncheckedCreateWithoutVersionInput> | VehicleOfferCreateWithoutVersionInput[] | VehicleOfferUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVersionInput | VehicleOfferCreateOrConnectWithoutVersionInput[]
    createMany?: VehicleOfferCreateManyVersionInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionUpdateManyWithoutVersionNestedInput = {
    create?: XOR<YearModelVersionCreateWithoutVersionInput, YearModelVersionUncheckedCreateWithoutVersionInput> | YearModelVersionCreateWithoutVersionInput[] | YearModelVersionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutVersionInput | YearModelVersionCreateOrConnectWithoutVersionInput[]
    upsert?: YearModelVersionUpsertWithWhereUniqueWithoutVersionInput | YearModelVersionUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: YearModelVersionCreateManyVersionInputEnvelope
    set?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    disconnect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    delete?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    update?: YearModelVersionUpdateWithWhereUniqueWithoutVersionInput | YearModelVersionUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: YearModelVersionUpdateManyWithWhereWithoutVersionInput | YearModelVersionUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: YearModelVersionScalarWhereInput | YearModelVersionScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutVersionNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutVersionInput, VehicleOfferUncheckedCreateWithoutVersionInput> | VehicleOfferCreateWithoutVersionInput[] | VehicleOfferUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVersionInput | VehicleOfferCreateOrConnectWithoutVersionInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutVersionInput | VehicleOfferUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: VehicleOfferCreateManyVersionInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutVersionInput | VehicleOfferUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutVersionInput | VehicleOfferUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<YearModelVersionCreateWithoutVersionInput, YearModelVersionUncheckedCreateWithoutVersionInput> | YearModelVersionCreateWithoutVersionInput[] | YearModelVersionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutVersionInput | YearModelVersionCreateOrConnectWithoutVersionInput[]
    upsert?: YearModelVersionUpsertWithWhereUniqueWithoutVersionInput | YearModelVersionUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: YearModelVersionCreateManyVersionInputEnvelope
    set?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    disconnect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    delete?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    connect?: YearModelVersionWhereUniqueInput | YearModelVersionWhereUniqueInput[]
    update?: YearModelVersionUpdateWithWhereUniqueWithoutVersionInput | YearModelVersionUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: YearModelVersionUpdateManyWithWhereWithoutVersionInput | YearModelVersionUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: YearModelVersionScalarWhereInput | YearModelVersionScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutVersionInput, VehicleOfferUncheckedCreateWithoutVersionInput> | VehicleOfferCreateWithoutVersionInput[] | VehicleOfferUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutVersionInput | VehicleOfferCreateOrConnectWithoutVersionInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutVersionInput | VehicleOfferUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: VehicleOfferCreateManyVersionInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutVersionInput | VehicleOfferUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutVersionInput | VehicleOfferUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionCreateNestedOneWithoutBodyTypesInput = {
    create?: XOR<YearModelVersionCreateWithoutBodyTypesInput, YearModelVersionUncheckedCreateWithoutBodyTypesInput>
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutBodyTypesInput
    connect?: YearModelVersionWhereUniqueInput
  }

  export type BodyTypeCreateNestedOneWithoutYearModelVersionBodyTypesInput = {
    create?: XOR<BodyTypeCreateWithoutYearModelVersionBodyTypesInput, BodyTypeUncheckedCreateWithoutYearModelVersionBodyTypesInput>
    connectOrCreate?: BodyTypeCreateOrConnectWithoutYearModelVersionBodyTypesInput
    connect?: BodyTypeWhereUniqueInput
  }

  export type YearModelVersionBodyTypeFuelCreateNestedManyWithoutYearModelVersionBodyTypeInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInputEnvelope
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInputEnvelope
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
  }

  export type YearModelVersionUpdateOneRequiredWithoutBodyTypesNestedInput = {
    create?: XOR<YearModelVersionCreateWithoutBodyTypesInput, YearModelVersionUncheckedCreateWithoutBodyTypesInput>
    connectOrCreate?: YearModelVersionCreateOrConnectWithoutBodyTypesInput
    upsert?: YearModelVersionUpsertWithoutBodyTypesInput
    connect?: YearModelVersionWhereUniqueInput
    update?: XOR<XOR<YearModelVersionUpdateToOneWithWhereWithoutBodyTypesInput, YearModelVersionUpdateWithoutBodyTypesInput>, YearModelVersionUncheckedUpdateWithoutBodyTypesInput>
  }

  export type BodyTypeUpdateOneRequiredWithoutYearModelVersionBodyTypesNestedInput = {
    create?: XOR<BodyTypeCreateWithoutYearModelVersionBodyTypesInput, BodyTypeUncheckedCreateWithoutYearModelVersionBodyTypesInput>
    connectOrCreate?: BodyTypeCreateOrConnectWithoutYearModelVersionBodyTypesInput
    upsert?: BodyTypeUpsertWithoutYearModelVersionBodyTypesInput
    connect?: BodyTypeWhereUniqueInput
    update?: XOR<XOR<BodyTypeUpdateToOneWithWhereWithoutYearModelVersionBodyTypesInput, BodyTypeUpdateWithoutYearModelVersionBodyTypesInput>, BodyTypeUncheckedUpdateWithoutYearModelVersionBodyTypesInput>
  }

  export type YearModelVersionBodyTypeFuelUpdateManyWithoutYearModelVersionBodyTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput[]
    upsert?: YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInputEnvelope
    set?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeInput[]
    updateMany?: YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutYearModelVersionBodyTypeInput[]
    deleteMany?: YearModelVersionBodyTypeFuelScalarWhereInput | YearModelVersionBodyTypeFuelScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutYearModelVersionBodyTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput[]
    upsert?: YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInputEnvelope
    set?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeInput[]
    updateMany?: YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutYearModelVersionBodyTypeInput[]
    deleteMany?: YearModelVersionBodyTypeFuelScalarWhereInput | YearModelVersionBodyTypeFuelScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeCreateNestedManyWithoutBodyTypeInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput> | YearModelVersionBodyTypeCreateWithoutBodyTypeInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput | YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeCreateManyBodyTypeInputEnvelope
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutBodyTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutBodyTypeInput, VehicleOfferUncheckedCreateWithoutBodyTypeInput> | VehicleOfferCreateWithoutBodyTypeInput[] | VehicleOfferUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBodyTypeInput | VehicleOfferCreateOrConnectWithoutBodyTypeInput[]
    createMany?: VehicleOfferCreateManyBodyTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutBodyTypeInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput> | YearModelVersionBodyTypeCreateWithoutBodyTypeInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput | YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeCreateManyBodyTypeInputEnvelope
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutBodyTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutBodyTypeInput, VehicleOfferUncheckedCreateWithoutBodyTypeInput> | VehicleOfferCreateWithoutBodyTypeInput[] | VehicleOfferUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBodyTypeInput | VehicleOfferCreateOrConnectWithoutBodyTypeInput[]
    createMany?: VehicleOfferCreateManyBodyTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeUpdateManyWithoutBodyTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput> | YearModelVersionBodyTypeCreateWithoutBodyTypeInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput | YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput[]
    upsert?: YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutBodyTypeInput | YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeCreateManyBodyTypeInputEnvelope
    set?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    update?: YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutBodyTypeInput | YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutBodyTypeInput[]
    updateMany?: YearModelVersionBodyTypeUpdateManyWithWhereWithoutBodyTypeInput | YearModelVersionBodyTypeUpdateManyWithWhereWithoutBodyTypeInput[]
    deleteMany?: YearModelVersionBodyTypeScalarWhereInput | YearModelVersionBodyTypeScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutBodyTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutBodyTypeInput, VehicleOfferUncheckedCreateWithoutBodyTypeInput> | VehicleOfferCreateWithoutBodyTypeInput[] | VehicleOfferUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBodyTypeInput | VehicleOfferCreateOrConnectWithoutBodyTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutBodyTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutBodyTypeInput[]
    createMany?: VehicleOfferCreateManyBodyTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutBodyTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutBodyTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutBodyTypeInput | VehicleOfferUpdateManyWithWhereWithoutBodyTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeUncheckedUpdateManyWithoutBodyTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput> | YearModelVersionBodyTypeCreateWithoutBodyTypeInput[] | YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput | YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput[]
    upsert?: YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutBodyTypeInput | YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutBodyTypeInput[]
    createMany?: YearModelVersionBodyTypeCreateManyBodyTypeInputEnvelope
    set?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeWhereUniqueInput | YearModelVersionBodyTypeWhereUniqueInput[]
    update?: YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutBodyTypeInput | YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutBodyTypeInput[]
    updateMany?: YearModelVersionBodyTypeUpdateManyWithWhereWithoutBodyTypeInput | YearModelVersionBodyTypeUpdateManyWithWhereWithoutBodyTypeInput[]
    deleteMany?: YearModelVersionBodyTypeScalarWhereInput | YearModelVersionBodyTypeScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutBodyTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutBodyTypeInput, VehicleOfferUncheckedCreateWithoutBodyTypeInput> | VehicleOfferCreateWithoutBodyTypeInput[] | VehicleOfferUncheckedCreateWithoutBodyTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutBodyTypeInput | VehicleOfferCreateOrConnectWithoutBodyTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutBodyTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutBodyTypeInput[]
    createMany?: VehicleOfferCreateManyBodyTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutBodyTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutBodyTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutBodyTypeInput | VehicleOfferUpdateManyWithWhereWithoutBodyTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeCreateNestedOneWithoutFuelTypesInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutFuelTypesInput, YearModelVersionBodyTypeUncheckedCreateWithoutFuelTypesInput>
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutFuelTypesInput
    connect?: YearModelVersionBodyTypeWhereUniqueInput
  }

  export type FuelTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelsInput = {
    create?: XOR<FuelTypeCreateWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelsInput>
    connectOrCreate?: FuelTypeCreateOrConnectWithoutYearModelVersionBodyTypeFuelsInput
    connect?: FuelTypeWhereUniqueInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInputEnvelope
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInputEnvelope
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeUpdateOneRequiredWithoutFuelTypesNestedInput = {
    create?: XOR<YearModelVersionBodyTypeCreateWithoutFuelTypesInput, YearModelVersionBodyTypeUncheckedCreateWithoutFuelTypesInput>
    connectOrCreate?: YearModelVersionBodyTypeCreateOrConnectWithoutFuelTypesInput
    upsert?: YearModelVersionBodyTypeUpsertWithoutFuelTypesInput
    connect?: YearModelVersionBodyTypeWhereUniqueInput
    update?: XOR<XOR<YearModelVersionBodyTypeUpdateToOneWithWhereWithoutFuelTypesInput, YearModelVersionBodyTypeUpdateWithoutFuelTypesInput>, YearModelVersionBodyTypeUncheckedUpdateWithoutFuelTypesInput>
  }

  export type FuelTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelsNestedInput = {
    create?: XOR<FuelTypeCreateWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelsInput>
    connectOrCreate?: FuelTypeCreateOrConnectWithoutYearModelVersionBodyTypeFuelsInput
    upsert?: FuelTypeUpsertWithoutYearModelVersionBodyTypeFuelsInput
    connect?: FuelTypeWhereUniqueInput
    update?: XOR<XOR<FuelTypeUpdateToOneWithWhereWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUpdateWithoutYearModelVersionBodyTypeFuelsInput>, FuelTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelsInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput[]
    upsert?: YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInputEnvelope
    set?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput[]
    updateMany?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutYearModelVersionBodyTypeFuelInput[]
    deleteMany?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput[]
    upsert?: YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInputEnvelope
    set?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput[]
    updateMany?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutYearModelVersionBodyTypeFuelInput[]
    deleteMany?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeFuelCreateNestedManyWithoutFuelTypeInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyFuelTypeInputEnvelope
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutFuelTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutFuelTypeInput, VehicleOfferUncheckedCreateWithoutFuelTypeInput> | VehicleOfferCreateWithoutFuelTypeInput[] | VehicleOfferUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutFuelTypeInput | VehicleOfferCreateOrConnectWithoutFuelTypeInput[]
    createMany?: VehicleOfferCreateManyFuelTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutFuelTypeInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyFuelTypeInputEnvelope
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutFuelTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutFuelTypeInput, VehicleOfferUncheckedCreateWithoutFuelTypeInput> | VehicleOfferCreateWithoutFuelTypeInput[] | VehicleOfferUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutFuelTypeInput | VehicleOfferCreateOrConnectWithoutFuelTypeInput[]
    createMany?: VehicleOfferCreateManyFuelTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeFuelUpdateManyWithoutFuelTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput[]
    upsert?: YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutFuelTypeInput | YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutFuelTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyFuelTypeInputEnvelope
    set?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutFuelTypeInput | YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutFuelTypeInput[]
    updateMany?: YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutFuelTypeInput | YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutFuelTypeInput[]
    deleteMany?: YearModelVersionBodyTypeFuelScalarWhereInput | YearModelVersionBodyTypeFuelScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutFuelTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutFuelTypeInput, VehicleOfferUncheckedCreateWithoutFuelTypeInput> | VehicleOfferCreateWithoutFuelTypeInput[] | VehicleOfferUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutFuelTypeInput | VehicleOfferCreateOrConnectWithoutFuelTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutFuelTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutFuelTypeInput[]
    createMany?: VehicleOfferCreateManyFuelTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutFuelTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutFuelTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutFuelTypeInput | VehicleOfferUpdateManyWithWhereWithoutFuelTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutFuelTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput> | YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput[] | YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput | YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput[]
    upsert?: YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutFuelTypeInput | YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutFuelTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelCreateManyFuelTypeInputEnvelope
    set?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput | YearModelVersionBodyTypeFuelWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutFuelTypeInput | YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutFuelTypeInput[]
    updateMany?: YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutFuelTypeInput | YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutFuelTypeInput[]
    deleteMany?: YearModelVersionBodyTypeFuelScalarWhereInput | YearModelVersionBodyTypeFuelScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutFuelTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutFuelTypeInput, VehicleOfferUncheckedCreateWithoutFuelTypeInput> | VehicleOfferCreateWithoutFuelTypeInput[] | VehicleOfferUncheckedCreateWithoutFuelTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutFuelTypeInput | VehicleOfferCreateOrConnectWithoutFuelTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutFuelTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutFuelTypeInput[]
    createMany?: VehicleOfferCreateManyFuelTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutFuelTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutFuelTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutFuelTypeInput | VehicleOfferUpdateManyWithWhereWithoutFuelTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeFuelCreateNestedOneWithoutTransmissionTypesInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutTransmissionTypesInput>
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutTransmissionTypesInput
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput
  }

  export type TransmissionTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    create?: XOR<TransmissionTypeCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
    connectOrCreate?: TransmissionTypeCreateOrConnectWithoutYearModelVersionBodyTypeFuelTransmissionsInput
    connect?: TransmissionTypeWhereUniqueInput
  }

  export type YearModelVersionBodyTypeFuelUpdateOneRequiredWithoutTransmissionTypesNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelCreateWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutTransmissionTypesInput>
    connectOrCreate?: YearModelVersionBodyTypeFuelCreateOrConnectWithoutTransmissionTypesInput
    upsert?: YearModelVersionBodyTypeFuelUpsertWithoutTransmissionTypesInput
    connect?: YearModelVersionBodyTypeFuelWhereUniqueInput
    update?: XOR<XOR<YearModelVersionBodyTypeFuelUpdateToOneWithWhereWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUpdateWithoutTransmissionTypesInput>, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutTransmissionTypesInput>
  }

  export type TransmissionTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelTransmissionsNestedInput = {
    create?: XOR<TransmissionTypeCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
    connectOrCreate?: TransmissionTypeCreateOrConnectWithoutYearModelVersionBodyTypeFuelTransmissionsInput
    upsert?: TransmissionTypeUpsertWithoutYearModelVersionBodyTypeFuelTransmissionsInput
    connect?: TransmissionTypeWhereUniqueInput
    update?: XOR<XOR<TransmissionTypeUpdateToOneWithWhereWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>, TransmissionTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutTransmissionTypeInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInputEnvelope
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutTransmissionTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutTransmissionTypeInput, VehicleOfferUncheckedCreateWithoutTransmissionTypeInput> | VehicleOfferCreateWithoutTransmissionTypeInput[] | VehicleOfferUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutTransmissionTypeInput | VehicleOfferCreateOrConnectWithoutTransmissionTypeInput[]
    createMany?: VehicleOfferCreateManyTransmissionTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutTransmissionTypeInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInputEnvelope
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutTransmissionTypeInput = {
    create?: XOR<VehicleOfferCreateWithoutTransmissionTypeInput, VehicleOfferUncheckedCreateWithoutTransmissionTypeInput> | VehicleOfferCreateWithoutTransmissionTypeInput[] | VehicleOfferUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutTransmissionTypeInput | VehicleOfferCreateOrConnectWithoutTransmissionTypeInput[]
    createMany?: VehicleOfferCreateManyTransmissionTypeInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutTransmissionTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput[]
    upsert?: YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutTransmissionTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInputEnvelope
    set?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutTransmissionTypeInput[]
    updateMany?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutTransmissionTypeInput[]
    deleteMany?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
  }

  export type VehicleOfferUpdateManyWithoutTransmissionTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutTransmissionTypeInput, VehicleOfferUncheckedCreateWithoutTransmissionTypeInput> | VehicleOfferCreateWithoutTransmissionTypeInput[] | VehicleOfferUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutTransmissionTypeInput | VehicleOfferCreateOrConnectWithoutTransmissionTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutTransmissionTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutTransmissionTypeInput[]
    createMany?: VehicleOfferCreateManyTransmissionTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutTransmissionTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutTransmissionTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutTransmissionTypeInput | VehicleOfferUpdateManyWithWhereWithoutTransmissionTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutTransmissionTypeNestedInput = {
    create?: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput> | YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput[] | YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput[]
    upsert?: YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutTransmissionTypeInput[]
    createMany?: YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInputEnvelope
    set?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    disconnect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    delete?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    connect?: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput | YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput[]
    update?: YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutTransmissionTypeInput[]
    updateMany?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutTransmissionTypeInput[]
    deleteMany?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutTransmissionTypeNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutTransmissionTypeInput, VehicleOfferUncheckedCreateWithoutTransmissionTypeInput> | VehicleOfferCreateWithoutTransmissionTypeInput[] | VehicleOfferUncheckedCreateWithoutTransmissionTypeInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutTransmissionTypeInput | VehicleOfferCreateOrConnectWithoutTransmissionTypeInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutTransmissionTypeInput | VehicleOfferUpsertWithWhereUniqueWithoutTransmissionTypeInput[]
    createMany?: VehicleOfferCreateManyTransmissionTypeInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutTransmissionTypeInput | VehicleOfferUpdateWithWhereUniqueWithoutTransmissionTypeInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutTransmissionTypeInput | VehicleOfferUpdateManyWithWhereWithoutTransmissionTypeInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type VehicleOfferCreateNestedManyWithoutColorInput = {
    create?: XOR<VehicleOfferCreateWithoutColorInput, VehicleOfferUncheckedCreateWithoutColorInput> | VehicleOfferCreateWithoutColorInput[] | VehicleOfferUncheckedCreateWithoutColorInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutColorInput | VehicleOfferCreateOrConnectWithoutColorInput[]
    createMany?: VehicleOfferCreateManyColorInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type VehicleOfferUncheckedCreateNestedManyWithoutColorInput = {
    create?: XOR<VehicleOfferCreateWithoutColorInput, VehicleOfferUncheckedCreateWithoutColorInput> | VehicleOfferCreateWithoutColorInput[] | VehicleOfferUncheckedCreateWithoutColorInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutColorInput | VehicleOfferCreateOrConnectWithoutColorInput[]
    createMany?: VehicleOfferCreateManyColorInputEnvelope
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
  }

  export type VehicleOfferUpdateManyWithoutColorNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutColorInput, VehicleOfferUncheckedCreateWithoutColorInput> | VehicleOfferCreateWithoutColorInput[] | VehicleOfferUncheckedCreateWithoutColorInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutColorInput | VehicleOfferCreateOrConnectWithoutColorInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutColorInput | VehicleOfferUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: VehicleOfferCreateManyColorInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutColorInput | VehicleOfferUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutColorInput | VehicleOfferUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type VehicleOfferUncheckedUpdateManyWithoutColorNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutColorInput, VehicleOfferUncheckedCreateWithoutColorInput> | VehicleOfferCreateWithoutColorInput[] | VehicleOfferUncheckedCreateWithoutColorInput[]
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutColorInput | VehicleOfferCreateOrConnectWithoutColorInput[]
    upsert?: VehicleOfferUpsertWithWhereUniqueWithoutColorInput | VehicleOfferUpsertWithWhereUniqueWithoutColorInput[]
    createMany?: VehicleOfferCreateManyColorInputEnvelope
    set?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    disconnect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    delete?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    connect?: VehicleOfferWhereUniqueInput | VehicleOfferWhereUniqueInput[]
    update?: VehicleOfferUpdateWithWhereUniqueWithoutColorInput | VehicleOfferUpdateWithWhereUniqueWithoutColorInput[]
    updateMany?: VehicleOfferUpdateManyWithWhereWithoutColorInput | VehicleOfferUpdateManyWithWhereWithoutColorInput[]
    deleteMany?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
  }

  export type VehicleOfferCreateNestedOneWithoutImagesInput = {
    create?: XOR<VehicleOfferCreateWithoutImagesInput, VehicleOfferUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutImagesInput
    connect?: VehicleOfferWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type VehicleOfferUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VehicleOfferCreateWithoutImagesInput, VehicleOfferUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VehicleOfferCreateOrConnectWithoutImagesInput
    upsert?: VehicleOfferUpsertWithoutImagesInput
    connect?: VehicleOfferWhereUniqueInput
    update?: XOR<XOR<VehicleOfferUpdateToOneWithWhereWithoutImagesInput, VehicleOfferUpdateWithoutImagesInput>, VehicleOfferUncheckedUpdateWithoutImagesInput>
  }

  export type VehicleTypeCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<VehicleTypeCreateWithoutVehicleOffersInput, VehicleTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVehicleOffersInput
    connect?: VehicleTypeWhereUniqueInput
  }

  export type VehicleYearCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<VehicleYearCreateWithoutVehicleOffersInput, VehicleYearUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: VehicleYearCreateOrConnectWithoutVehicleOffersInput
    connect?: VehicleYearWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<BrandCreateWithoutVehicleOffersInput, BrandUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: BrandCreateOrConnectWithoutVehicleOffersInput
    connect?: BrandWhereUniqueInput
  }

  export type ModelCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<ModelCreateWithoutVehicleOffersInput, ModelUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: ModelCreateOrConnectWithoutVehicleOffersInput
    connect?: ModelWhereUniqueInput
  }

  export type VersionCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<VersionCreateWithoutVehicleOffersInput, VersionUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: VersionCreateOrConnectWithoutVehicleOffersInput
    connect?: VersionWhereUniqueInput
  }

  export type BodyTypeCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<BodyTypeCreateWithoutVehicleOffersInput, BodyTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: BodyTypeCreateOrConnectWithoutVehicleOffersInput
    connect?: BodyTypeWhereUniqueInput
  }

  export type FuelTypeCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<FuelTypeCreateWithoutVehicleOffersInput, FuelTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: FuelTypeCreateOrConnectWithoutVehicleOffersInput
    connect?: FuelTypeWhereUniqueInput
  }

  export type TransmissionTypeCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<TransmissionTypeCreateWithoutVehicleOffersInput, TransmissionTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: TransmissionTypeCreateOrConnectWithoutVehicleOffersInput
    connect?: TransmissionTypeWhereUniqueInput
  }

  export type ColorCreateNestedOneWithoutVehicleOffersInput = {
    create?: XOR<ColorCreateWithoutVehicleOffersInput, ColorUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: ColorCreateOrConnectWithoutVehicleOffersInput
    connect?: ColorWhereUniqueInput
  }

  export type VehicleImageCreateNestedManyWithoutVehicleOfferInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleOfferInput, VehicleImageUncheckedCreateWithoutVehicleOfferInput> | VehicleImageCreateWithoutVehicleOfferInput[] | VehicleImageUncheckedCreateWithoutVehicleOfferInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleOfferInput | VehicleImageCreateOrConnectWithoutVehicleOfferInput[]
    createMany?: VehicleImageCreateManyVehicleOfferInputEnvelope
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
  }

  export type VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleOfferInput, VehicleImageUncheckedCreateWithoutVehicleOfferInput> | VehicleImageCreateWithoutVehicleOfferInput[] | VehicleImageUncheckedCreateWithoutVehicleOfferInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleOfferInput | VehicleImageCreateOrConnectWithoutVehicleOfferInput[]
    createMany?: VehicleImageCreateManyVehicleOfferInputEnvelope
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type VehicleTypeUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<VehicleTypeCreateWithoutVehicleOffersInput, VehicleTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: VehicleTypeCreateOrConnectWithoutVehicleOffersInput
    upsert?: VehicleTypeUpsertWithoutVehicleOffersInput
    disconnect?: VehicleTypeWhereInput | boolean
    delete?: VehicleTypeWhereInput | boolean
    connect?: VehicleTypeWhereUniqueInput
    update?: XOR<XOR<VehicleTypeUpdateToOneWithWhereWithoutVehicleOffersInput, VehicleTypeUpdateWithoutVehicleOffersInput>, VehicleTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type VehicleYearUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<VehicleYearCreateWithoutVehicleOffersInput, VehicleYearUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: VehicleYearCreateOrConnectWithoutVehicleOffersInput
    upsert?: VehicleYearUpsertWithoutVehicleOffersInput
    disconnect?: VehicleYearWhereInput | boolean
    delete?: VehicleYearWhereInput | boolean
    connect?: VehicleYearWhereUniqueInput
    update?: XOR<XOR<VehicleYearUpdateToOneWithWhereWithoutVehicleOffersInput, VehicleYearUpdateWithoutVehicleOffersInput>, VehicleYearUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type BrandUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<BrandCreateWithoutVehicleOffersInput, BrandUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: BrandCreateOrConnectWithoutVehicleOffersInput
    upsert?: BrandUpsertWithoutVehicleOffersInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutVehicleOffersInput, BrandUpdateWithoutVehicleOffersInput>, BrandUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type ModelUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<ModelCreateWithoutVehicleOffersInput, ModelUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: ModelCreateOrConnectWithoutVehicleOffersInput
    upsert?: ModelUpsertWithoutVehicleOffersInput
    disconnect?: ModelWhereInput | boolean
    delete?: ModelWhereInput | boolean
    connect?: ModelWhereUniqueInput
    update?: XOR<XOR<ModelUpdateToOneWithWhereWithoutVehicleOffersInput, ModelUpdateWithoutVehicleOffersInput>, ModelUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type VersionUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<VersionCreateWithoutVehicleOffersInput, VersionUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: VersionCreateOrConnectWithoutVehicleOffersInput
    upsert?: VersionUpsertWithoutVehicleOffersInput
    disconnect?: VersionWhereInput | boolean
    delete?: VersionWhereInput | boolean
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutVehicleOffersInput, VersionUpdateWithoutVehicleOffersInput>, VersionUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type BodyTypeUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<BodyTypeCreateWithoutVehicleOffersInput, BodyTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: BodyTypeCreateOrConnectWithoutVehicleOffersInput
    upsert?: BodyTypeUpsertWithoutVehicleOffersInput
    disconnect?: BodyTypeWhereInput | boolean
    delete?: BodyTypeWhereInput | boolean
    connect?: BodyTypeWhereUniqueInput
    update?: XOR<XOR<BodyTypeUpdateToOneWithWhereWithoutVehicleOffersInput, BodyTypeUpdateWithoutVehicleOffersInput>, BodyTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type FuelTypeUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<FuelTypeCreateWithoutVehicleOffersInput, FuelTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: FuelTypeCreateOrConnectWithoutVehicleOffersInput
    upsert?: FuelTypeUpsertWithoutVehicleOffersInput
    disconnect?: FuelTypeWhereInput | boolean
    delete?: FuelTypeWhereInput | boolean
    connect?: FuelTypeWhereUniqueInput
    update?: XOR<XOR<FuelTypeUpdateToOneWithWhereWithoutVehicleOffersInput, FuelTypeUpdateWithoutVehicleOffersInput>, FuelTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<TransmissionTypeCreateWithoutVehicleOffersInput, TransmissionTypeUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: TransmissionTypeCreateOrConnectWithoutVehicleOffersInput
    upsert?: TransmissionTypeUpsertWithoutVehicleOffersInput
    disconnect?: TransmissionTypeWhereInput | boolean
    delete?: TransmissionTypeWhereInput | boolean
    connect?: TransmissionTypeWhereUniqueInput
    update?: XOR<XOR<TransmissionTypeUpdateToOneWithWhereWithoutVehicleOffersInput, TransmissionTypeUpdateWithoutVehicleOffersInput>, TransmissionTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type ColorUpdateOneWithoutVehicleOffersNestedInput = {
    create?: XOR<ColorCreateWithoutVehicleOffersInput, ColorUncheckedCreateWithoutVehicleOffersInput>
    connectOrCreate?: ColorCreateOrConnectWithoutVehicleOffersInput
    upsert?: ColorUpsertWithoutVehicleOffersInput
    disconnect?: ColorWhereInput | boolean
    delete?: ColorWhereInput | boolean
    connect?: ColorWhereUniqueInput
    update?: XOR<XOR<ColorUpdateToOneWithWhereWithoutVehicleOffersInput, ColorUpdateWithoutVehicleOffersInput>, ColorUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type VehicleImageUpdateManyWithoutVehicleOfferNestedInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleOfferInput, VehicleImageUncheckedCreateWithoutVehicleOfferInput> | VehicleImageCreateWithoutVehicleOfferInput[] | VehicleImageUncheckedCreateWithoutVehicleOfferInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleOfferInput | VehicleImageCreateOrConnectWithoutVehicleOfferInput[]
    upsert?: VehicleImageUpsertWithWhereUniqueWithoutVehicleOfferInput | VehicleImageUpsertWithWhereUniqueWithoutVehicleOfferInput[]
    createMany?: VehicleImageCreateManyVehicleOfferInputEnvelope
    set?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    disconnect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    delete?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    update?: VehicleImageUpdateWithWhereUniqueWithoutVehicleOfferInput | VehicleImageUpdateWithWhereUniqueWithoutVehicleOfferInput[]
    updateMany?: VehicleImageUpdateManyWithWhereWithoutVehicleOfferInput | VehicleImageUpdateManyWithWhereWithoutVehicleOfferInput[]
    deleteMany?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
  }

  export type VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput = {
    create?: XOR<VehicleImageCreateWithoutVehicleOfferInput, VehicleImageUncheckedCreateWithoutVehicleOfferInput> | VehicleImageCreateWithoutVehicleOfferInput[] | VehicleImageUncheckedCreateWithoutVehicleOfferInput[]
    connectOrCreate?: VehicleImageCreateOrConnectWithoutVehicleOfferInput | VehicleImageCreateOrConnectWithoutVehicleOfferInput[]
    upsert?: VehicleImageUpsertWithWhereUniqueWithoutVehicleOfferInput | VehicleImageUpsertWithWhereUniqueWithoutVehicleOfferInput[]
    createMany?: VehicleImageCreateManyVehicleOfferInputEnvelope
    set?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    disconnect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    delete?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    connect?: VehicleImageWhereUniqueInput | VehicleImageWhereUniqueInput[]
    update?: VehicleImageUpdateWithWhereUniqueWithoutVehicleOfferInput | VehicleImageUpdateWithWhereUniqueWithoutVehicleOfferInput[]
    updateMany?: VehicleImageUpdateManyWithWhereWithoutVehicleOfferInput | VehicleImageUpdateManyWithWhereWithoutVehicleOfferInput[]
    deleteMany?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VehicleYearCreateWithoutVehicleTypeInput = {
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brands?: YearBrandCreateNestedManyWithoutVehicleYearInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearUncheckedCreateWithoutVehicleTypeInput = {
    id?: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brands?: YearBrandUncheckedCreateNestedManyWithoutVehicleYearInput
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearCreateOrConnectWithoutVehicleTypeInput = {
    where: VehicleYearWhereUniqueInput
    create: XOR<VehicleYearCreateWithoutVehicleTypeInput, VehicleYearUncheckedCreateWithoutVehicleTypeInput>
  }

  export type VehicleYearCreateManyVehicleTypeInputEnvelope = {
    data: VehicleYearCreateManyVehicleTypeInput | VehicleYearCreateManyVehicleTypeInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutVehicleTypeInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutVehicleTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutVehicleTypeInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutVehicleTypeInput, VehicleOfferUncheckedCreateWithoutVehicleTypeInput>
  }

  export type VehicleOfferCreateManyVehicleTypeInputEnvelope = {
    data: VehicleOfferCreateManyVehicleTypeInput | VehicleOfferCreateManyVehicleTypeInput[]
    skipDuplicates?: boolean
  }

  export type VehicleYearUpsertWithWhereUniqueWithoutVehicleTypeInput = {
    where: VehicleYearWhereUniqueInput
    update: XOR<VehicleYearUpdateWithoutVehicleTypeInput, VehicleYearUncheckedUpdateWithoutVehicleTypeInput>
    create: XOR<VehicleYearCreateWithoutVehicleTypeInput, VehicleYearUncheckedCreateWithoutVehicleTypeInput>
  }

  export type VehicleYearUpdateWithWhereUniqueWithoutVehicleTypeInput = {
    where: VehicleYearWhereUniqueInput
    data: XOR<VehicleYearUpdateWithoutVehicleTypeInput, VehicleYearUncheckedUpdateWithoutVehicleTypeInput>
  }

  export type VehicleYearUpdateManyWithWhereWithoutVehicleTypeInput = {
    where: VehicleYearScalarWhereInput
    data: XOR<VehicleYearUpdateManyMutationInput, VehicleYearUncheckedUpdateManyWithoutVehicleTypeInput>
  }

  export type VehicleYearScalarWhereInput = {
    AND?: VehicleYearScalarWhereInput | VehicleYearScalarWhereInput[]
    OR?: VehicleYearScalarWhereInput[]
    NOT?: VehicleYearScalarWhereInput | VehicleYearScalarWhereInput[]
    id?: IntFilter<"VehicleYear"> | number
    year?: IntFilter<"VehicleYear"> | number
    createdAt?: DateTimeFilter<"VehicleYear"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleYear"> | Date | string
    vehicleTypeId?: IntFilter<"VehicleYear"> | number
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutVehicleTypeInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutVehicleTypeInput, VehicleOfferUncheckedUpdateWithoutVehicleTypeInput>
    create: XOR<VehicleOfferCreateWithoutVehicleTypeInput, VehicleOfferUncheckedCreateWithoutVehicleTypeInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutVehicleTypeInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutVehicleTypeInput, VehicleOfferUncheckedUpdateWithoutVehicleTypeInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutVehicleTypeInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutVehicleTypeInput>
  }

  export type VehicleOfferScalarWhereInput = {
    AND?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
    OR?: VehicleOfferScalarWhereInput[]
    NOT?: VehicleOfferScalarWhereInput | VehicleOfferScalarWhereInput[]
    id?: IntFilter<"VehicleOffer"> | number
    year?: IntNullableFilter<"VehicleOffer"> | number | null
    kilometer?: IntNullableFilter<"VehicleOffer"> | number | null
    accidentStatus?: StringNullableFilter<"VehicleOffer"> | string | null
    accidentAmount?: IntNullableFilter<"VehicleOffer"> | number | null
    status?: StringFilter<"VehicleOffer"> | string
    price?: FloatNullableFilter<"VehicleOffer"> | number | null
    displayValues?: StringNullableFilter<"VehicleOffer"> | string | null
    userId?: StringFilter<"VehicleOffer"> | string
    createdAt?: DateTimeFilter<"VehicleOffer"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleOffer"> | Date | string
    processedAt?: DateTimeNullableFilter<"VehicleOffer"> | Date | string | null
    vehicleTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    vehicleYearId?: IntNullableFilter<"VehicleOffer"> | number | null
    brandId?: IntNullableFilter<"VehicleOffer"> | number | null
    modelId?: IntNullableFilter<"VehicleOffer"> | number | null
    versionId?: IntNullableFilter<"VehicleOffer"> | number | null
    bodyTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    fuelTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    transmissionTypeId?: IntNullableFilter<"VehicleOffer"> | number | null
    colorId?: IntNullableFilter<"VehicleOffer"> | number | null
    notes?: StringNullableFilter<"VehicleOffer"> | string | null
    adminNotes?: StringNullableFilter<"VehicleOffer"> | string | null
    description?: StringNullableFilter<"VehicleOffer"> | string | null
    registrationDate?: DateTimeNullableFilter<"VehicleOffer"> | Date | string | null
    listingStatus?: StringFilter<"VehicleOffer"> | string
  }

  export type VehicleTypeCreateWithoutYearsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVehicleTypeInput
  }

  export type VehicleTypeUncheckedCreateWithoutYearsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVehicleTypeInput
  }

  export type VehicleTypeCreateOrConnectWithoutYearsInput = {
    where: VehicleTypeWhereUniqueInput
    create: XOR<VehicleTypeCreateWithoutYearsInput, VehicleTypeUncheckedCreateWithoutYearsInput>
  }

  export type YearBrandCreateWithoutVehicleYearInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutYearBrandsInput
    models?: YearModelCreateNestedManyWithoutYearBrandInput
  }

  export type YearBrandUncheckedCreateWithoutVehicleYearInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brandId: number
    models?: YearModelUncheckedCreateNestedManyWithoutYearBrandInput
  }

  export type YearBrandCreateOrConnectWithoutVehicleYearInput = {
    where: YearBrandWhereUniqueInput
    create: XOR<YearBrandCreateWithoutVehicleYearInput, YearBrandUncheckedCreateWithoutVehicleYearInput>
  }

  export type YearBrandCreateManyVehicleYearInputEnvelope = {
    data: YearBrandCreateManyVehicleYearInput | YearBrandCreateManyVehicleYearInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutVehicleYearInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutVehicleYearInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutVehicleYearInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutVehicleYearInput, VehicleOfferUncheckedCreateWithoutVehicleYearInput>
  }

  export type VehicleOfferCreateManyVehicleYearInputEnvelope = {
    data: VehicleOfferCreateManyVehicleYearInput | VehicleOfferCreateManyVehicleYearInput[]
    skipDuplicates?: boolean
  }

  export type VehicleTypeUpsertWithoutYearsInput = {
    update: XOR<VehicleTypeUpdateWithoutYearsInput, VehicleTypeUncheckedUpdateWithoutYearsInput>
    create: XOR<VehicleTypeCreateWithoutYearsInput, VehicleTypeUncheckedCreateWithoutYearsInput>
    where?: VehicleTypeWhereInput
  }

  export type VehicleTypeUpdateToOneWithWhereWithoutYearsInput = {
    where?: VehicleTypeWhereInput
    data: XOR<VehicleTypeUpdateWithoutYearsInput, VehicleTypeUncheckedUpdateWithoutYearsInput>
  }

  export type VehicleTypeUpdateWithoutYearsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutVehicleTypeNestedInput
  }

  export type VehicleTypeUncheckedUpdateWithoutYearsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVehicleTypeNestedInput
  }

  export type YearBrandUpsertWithWhereUniqueWithoutVehicleYearInput = {
    where: YearBrandWhereUniqueInput
    update: XOR<YearBrandUpdateWithoutVehicleYearInput, YearBrandUncheckedUpdateWithoutVehicleYearInput>
    create: XOR<YearBrandCreateWithoutVehicleYearInput, YearBrandUncheckedCreateWithoutVehicleYearInput>
  }

  export type YearBrandUpdateWithWhereUniqueWithoutVehicleYearInput = {
    where: YearBrandWhereUniqueInput
    data: XOR<YearBrandUpdateWithoutVehicleYearInput, YearBrandUncheckedUpdateWithoutVehicleYearInput>
  }

  export type YearBrandUpdateManyWithWhereWithoutVehicleYearInput = {
    where: YearBrandScalarWhereInput
    data: XOR<YearBrandUpdateManyMutationInput, YearBrandUncheckedUpdateManyWithoutVehicleYearInput>
  }

  export type YearBrandScalarWhereInput = {
    AND?: YearBrandScalarWhereInput | YearBrandScalarWhereInput[]
    OR?: YearBrandScalarWhereInput[]
    NOT?: YearBrandScalarWhereInput | YearBrandScalarWhereInput[]
    id?: IntFilter<"YearBrand"> | number
    createdAt?: DateTimeFilter<"YearBrand"> | Date | string
    updatedAt?: DateTimeFilter<"YearBrand"> | Date | string
    yearId?: IntFilter<"YearBrand"> | number
    brandId?: IntFilter<"YearBrand"> | number
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutVehicleYearInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutVehicleYearInput, VehicleOfferUncheckedUpdateWithoutVehicleYearInput>
    create: XOR<VehicleOfferCreateWithoutVehicleYearInput, VehicleOfferUncheckedCreateWithoutVehicleYearInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutVehicleYearInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutVehicleYearInput, VehicleOfferUncheckedUpdateWithoutVehicleYearInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutVehicleYearInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutVehicleYearInput>
  }

  export type VehicleYearCreateWithoutBrandsInput = {
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleType: VehicleTypeCreateNestedOneWithoutYearsInput
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearUncheckedCreateWithoutBrandsInput = {
    id?: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleTypeId: number
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearCreateOrConnectWithoutBrandsInput = {
    where: VehicleYearWhereUniqueInput
    create: XOR<VehicleYearCreateWithoutBrandsInput, VehicleYearUncheckedCreateWithoutBrandsInput>
  }

  export type BrandCreateWithoutYearBrandsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutYearBrandsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutYearBrandsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutYearBrandsInput, BrandUncheckedCreateWithoutYearBrandsInput>
  }

  export type YearModelCreateWithoutYearBrandInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    model: ModelCreateNestedOneWithoutYearModelsInput
    versions?: YearModelVersionCreateNestedManyWithoutYearModelInput
  }

  export type YearModelUncheckedCreateWithoutYearBrandInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modelId: number
    versions?: YearModelVersionUncheckedCreateNestedManyWithoutYearModelInput
  }

  export type YearModelCreateOrConnectWithoutYearBrandInput = {
    where: YearModelWhereUniqueInput
    create: XOR<YearModelCreateWithoutYearBrandInput, YearModelUncheckedCreateWithoutYearBrandInput>
  }

  export type YearModelCreateManyYearBrandInputEnvelope = {
    data: YearModelCreateManyYearBrandInput | YearModelCreateManyYearBrandInput[]
    skipDuplicates?: boolean
  }

  export type VehicleYearUpsertWithoutBrandsInput = {
    update: XOR<VehicleYearUpdateWithoutBrandsInput, VehicleYearUncheckedUpdateWithoutBrandsInput>
    create: XOR<VehicleYearCreateWithoutBrandsInput, VehicleYearUncheckedCreateWithoutBrandsInput>
    where?: VehicleYearWhereInput
  }

  export type VehicleYearUpdateToOneWithWhereWithoutBrandsInput = {
    where?: VehicleYearWhereInput
    data: XOR<VehicleYearUpdateWithoutBrandsInput, VehicleYearUncheckedUpdateWithoutBrandsInput>
  }

  export type VehicleYearUpdateWithoutBrandsInput = {
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleType?: VehicleTypeUpdateOneRequiredWithoutYearsNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutVehicleYearNestedInput
  }

  export type VehicleYearUncheckedUpdateWithoutBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleTypeId?: IntFieldUpdateOperationsInput | number
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVehicleYearNestedInput
  }

  export type BrandUpsertWithoutYearBrandsInput = {
    update: XOR<BrandUpdateWithoutYearBrandsInput, BrandUncheckedUpdateWithoutYearBrandsInput>
    create: XOR<BrandCreateWithoutYearBrandsInput, BrandUncheckedCreateWithoutYearBrandsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutYearBrandsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutYearBrandsInput, BrandUncheckedUpdateWithoutYearBrandsInput>
  }

  export type BrandUpdateWithoutYearBrandsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutYearBrandsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type YearModelUpsertWithWhereUniqueWithoutYearBrandInput = {
    where: YearModelWhereUniqueInput
    update: XOR<YearModelUpdateWithoutYearBrandInput, YearModelUncheckedUpdateWithoutYearBrandInput>
    create: XOR<YearModelCreateWithoutYearBrandInput, YearModelUncheckedCreateWithoutYearBrandInput>
  }

  export type YearModelUpdateWithWhereUniqueWithoutYearBrandInput = {
    where: YearModelWhereUniqueInput
    data: XOR<YearModelUpdateWithoutYearBrandInput, YearModelUncheckedUpdateWithoutYearBrandInput>
  }

  export type YearModelUpdateManyWithWhereWithoutYearBrandInput = {
    where: YearModelScalarWhereInput
    data: XOR<YearModelUpdateManyMutationInput, YearModelUncheckedUpdateManyWithoutYearBrandInput>
  }

  export type YearModelScalarWhereInput = {
    AND?: YearModelScalarWhereInput | YearModelScalarWhereInput[]
    OR?: YearModelScalarWhereInput[]
    NOT?: YearModelScalarWhereInput | YearModelScalarWhereInput[]
    id?: IntFilter<"YearModel"> | number
    createdAt?: DateTimeFilter<"YearModel"> | Date | string
    updatedAt?: DateTimeFilter<"YearModel"> | Date | string
    yearBrandId?: IntFilter<"YearModel"> | number
    modelId?: IntFilter<"YearModel"> | number
  }

  export type YearBrandCreateWithoutBrandInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleYear: VehicleYearCreateNestedOneWithoutBrandsInput
    models?: YearModelCreateNestedManyWithoutYearBrandInput
  }

  export type YearBrandUncheckedCreateWithoutBrandInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearId: number
    models?: YearModelUncheckedCreateNestedManyWithoutYearBrandInput
  }

  export type YearBrandCreateOrConnectWithoutBrandInput = {
    where: YearBrandWhereUniqueInput
    create: XOR<YearBrandCreateWithoutBrandInput, YearBrandUncheckedCreateWithoutBrandInput>
  }

  export type YearBrandCreateManyBrandInputEnvelope = {
    data: YearBrandCreateManyBrandInput | YearBrandCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutBrandInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutBrandInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutBrandInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutBrandInput, VehicleOfferUncheckedCreateWithoutBrandInput>
  }

  export type VehicleOfferCreateManyBrandInputEnvelope = {
    data: VehicleOfferCreateManyBrandInput | VehicleOfferCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type YearBrandUpsertWithWhereUniqueWithoutBrandInput = {
    where: YearBrandWhereUniqueInput
    update: XOR<YearBrandUpdateWithoutBrandInput, YearBrandUncheckedUpdateWithoutBrandInput>
    create: XOR<YearBrandCreateWithoutBrandInput, YearBrandUncheckedCreateWithoutBrandInput>
  }

  export type YearBrandUpdateWithWhereUniqueWithoutBrandInput = {
    where: YearBrandWhereUniqueInput
    data: XOR<YearBrandUpdateWithoutBrandInput, YearBrandUncheckedUpdateWithoutBrandInput>
  }

  export type YearBrandUpdateManyWithWhereWithoutBrandInput = {
    where: YearBrandScalarWhereInput
    data: XOR<YearBrandUpdateManyMutationInput, YearBrandUncheckedUpdateManyWithoutBrandInput>
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutBrandInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutBrandInput, VehicleOfferUncheckedUpdateWithoutBrandInput>
    create: XOR<VehicleOfferCreateWithoutBrandInput, VehicleOfferUncheckedCreateWithoutBrandInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutBrandInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutBrandInput, VehicleOfferUncheckedUpdateWithoutBrandInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutBrandInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutBrandInput>
  }

  export type YearBrandCreateWithoutModelsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleYear: VehicleYearCreateNestedOneWithoutBrandsInput
    brand: BrandCreateNestedOneWithoutYearBrandsInput
  }

  export type YearBrandUncheckedCreateWithoutModelsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearId: number
    brandId: number
  }

  export type YearBrandCreateOrConnectWithoutModelsInput = {
    where: YearBrandWhereUniqueInput
    create: XOR<YearBrandCreateWithoutModelsInput, YearBrandUncheckedCreateWithoutModelsInput>
  }

  export type ModelCreateWithoutYearModelsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutYearModelsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutYearModelsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutYearModelsInput, ModelUncheckedCreateWithoutYearModelsInput>
  }

  export type YearModelVersionCreateWithoutYearModelInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    version: VersionCreateNestedOneWithoutYearModelVersionsInput
    bodyTypes?: YearModelVersionBodyTypeCreateNestedManyWithoutYearModelVersionInput
  }

  export type YearModelVersionUncheckedCreateWithoutYearModelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    versionId: number
    bodyTypes?: YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutYearModelVersionInput
  }

  export type YearModelVersionCreateOrConnectWithoutYearModelInput = {
    where: YearModelVersionWhereUniqueInput
    create: XOR<YearModelVersionCreateWithoutYearModelInput, YearModelVersionUncheckedCreateWithoutYearModelInput>
  }

  export type YearModelVersionCreateManyYearModelInputEnvelope = {
    data: YearModelVersionCreateManyYearModelInput | YearModelVersionCreateManyYearModelInput[]
    skipDuplicates?: boolean
  }

  export type YearBrandUpsertWithoutModelsInput = {
    update: XOR<YearBrandUpdateWithoutModelsInput, YearBrandUncheckedUpdateWithoutModelsInput>
    create: XOR<YearBrandCreateWithoutModelsInput, YearBrandUncheckedCreateWithoutModelsInput>
    where?: YearBrandWhereInput
  }

  export type YearBrandUpdateToOneWithWhereWithoutModelsInput = {
    where?: YearBrandWhereInput
    data: XOR<YearBrandUpdateWithoutModelsInput, YearBrandUncheckedUpdateWithoutModelsInput>
  }

  export type YearBrandUpdateWithoutModelsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleYear?: VehicleYearUpdateOneRequiredWithoutBrandsNestedInput
    brand?: BrandUpdateOneRequiredWithoutYearBrandsNestedInput
  }

  export type YearBrandUncheckedUpdateWithoutModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
  }

  export type ModelUpsertWithoutYearModelsInput = {
    update: XOR<ModelUpdateWithoutYearModelsInput, ModelUncheckedUpdateWithoutYearModelsInput>
    create: XOR<ModelCreateWithoutYearModelsInput, ModelUncheckedCreateWithoutYearModelsInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutYearModelsInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutYearModelsInput, ModelUncheckedUpdateWithoutYearModelsInput>
  }

  export type ModelUpdateWithoutYearModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutYearModelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutModelNestedInput
  }

  export type YearModelVersionUpsertWithWhereUniqueWithoutYearModelInput = {
    where: YearModelVersionWhereUniqueInput
    update: XOR<YearModelVersionUpdateWithoutYearModelInput, YearModelVersionUncheckedUpdateWithoutYearModelInput>
    create: XOR<YearModelVersionCreateWithoutYearModelInput, YearModelVersionUncheckedCreateWithoutYearModelInput>
  }

  export type YearModelVersionUpdateWithWhereUniqueWithoutYearModelInput = {
    where: YearModelVersionWhereUniqueInput
    data: XOR<YearModelVersionUpdateWithoutYearModelInput, YearModelVersionUncheckedUpdateWithoutYearModelInput>
  }

  export type YearModelVersionUpdateManyWithWhereWithoutYearModelInput = {
    where: YearModelVersionScalarWhereInput
    data: XOR<YearModelVersionUpdateManyMutationInput, YearModelVersionUncheckedUpdateManyWithoutYearModelInput>
  }

  export type YearModelVersionScalarWhereInput = {
    AND?: YearModelVersionScalarWhereInput | YearModelVersionScalarWhereInput[]
    OR?: YearModelVersionScalarWhereInput[]
    NOT?: YearModelVersionScalarWhereInput | YearModelVersionScalarWhereInput[]
    id?: IntFilter<"YearModelVersion"> | number
    createdAt?: DateTimeFilter<"YearModelVersion"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersion"> | Date | string
    yearModelId?: IntFilter<"YearModelVersion"> | number
    versionId?: IntFilter<"YearModelVersion"> | number
  }

  export type YearModelCreateWithoutModelInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrand: YearBrandCreateNestedOneWithoutModelsInput
    versions?: YearModelVersionCreateNestedManyWithoutYearModelInput
  }

  export type YearModelUncheckedCreateWithoutModelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrandId: number
    versions?: YearModelVersionUncheckedCreateNestedManyWithoutYearModelInput
  }

  export type YearModelCreateOrConnectWithoutModelInput = {
    where: YearModelWhereUniqueInput
    create: XOR<YearModelCreateWithoutModelInput, YearModelUncheckedCreateWithoutModelInput>
  }

  export type YearModelCreateManyModelInputEnvelope = {
    data: YearModelCreateManyModelInput | YearModelCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutModelInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutModelInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutModelInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutModelInput, VehicleOfferUncheckedCreateWithoutModelInput>
  }

  export type VehicleOfferCreateManyModelInputEnvelope = {
    data: VehicleOfferCreateManyModelInput | VehicleOfferCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type YearModelUpsertWithWhereUniqueWithoutModelInput = {
    where: YearModelWhereUniqueInput
    update: XOR<YearModelUpdateWithoutModelInput, YearModelUncheckedUpdateWithoutModelInput>
    create: XOR<YearModelCreateWithoutModelInput, YearModelUncheckedCreateWithoutModelInput>
  }

  export type YearModelUpdateWithWhereUniqueWithoutModelInput = {
    where: YearModelWhereUniqueInput
    data: XOR<YearModelUpdateWithoutModelInput, YearModelUncheckedUpdateWithoutModelInput>
  }

  export type YearModelUpdateManyWithWhereWithoutModelInput = {
    where: YearModelScalarWhereInput
    data: XOR<YearModelUpdateManyMutationInput, YearModelUncheckedUpdateManyWithoutModelInput>
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutModelInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutModelInput, VehicleOfferUncheckedUpdateWithoutModelInput>
    create: XOR<VehicleOfferCreateWithoutModelInput, VehicleOfferUncheckedCreateWithoutModelInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutModelInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutModelInput, VehicleOfferUncheckedUpdateWithoutModelInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutModelInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutModelInput>
  }

  export type YearModelCreateWithoutVersionsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrand: YearBrandCreateNestedOneWithoutModelsInput
    model: ModelCreateNestedOneWithoutYearModelsInput
  }

  export type YearModelUncheckedCreateWithoutVersionsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrandId: number
    modelId: number
  }

  export type YearModelCreateOrConnectWithoutVersionsInput = {
    where: YearModelWhereUniqueInput
    create: XOR<YearModelCreateWithoutVersionsInput, YearModelUncheckedCreateWithoutVersionsInput>
  }

  export type VersionCreateWithoutYearModelVersionsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutYearModelVersionsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutYearModelVersionsInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutYearModelVersionsInput, VersionUncheckedCreateWithoutYearModelVersionsInput>
  }

  export type YearModelVersionBodyTypeCreateWithoutYearModelVersionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyType: BodyTypeCreateNestedOneWithoutYearModelVersionBodyTypesInput
    fuelTypes?: YearModelVersionBodyTypeFuelCreateNestedManyWithoutYearModelVersionBodyTypeInput
  }

  export type YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyTypeId: number
    fuelTypes?: YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeInput
  }

  export type YearModelVersionBodyTypeCreateOrConnectWithoutYearModelVersionInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeCreateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput>
  }

  export type YearModelVersionBodyTypeCreateManyYearModelVersionInputEnvelope = {
    data: YearModelVersionBodyTypeCreateManyYearModelVersionInput | YearModelVersionBodyTypeCreateManyYearModelVersionInput[]
    skipDuplicates?: boolean
  }

  export type YearModelUpsertWithoutVersionsInput = {
    update: XOR<YearModelUpdateWithoutVersionsInput, YearModelUncheckedUpdateWithoutVersionsInput>
    create: XOR<YearModelCreateWithoutVersionsInput, YearModelUncheckedCreateWithoutVersionsInput>
    where?: YearModelWhereInput
  }

  export type YearModelUpdateToOneWithWhereWithoutVersionsInput = {
    where?: YearModelWhereInput
    data: XOR<YearModelUpdateWithoutVersionsInput, YearModelUncheckedUpdateWithoutVersionsInput>
  }

  export type YearModelUpdateWithoutVersionsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrand?: YearBrandUpdateOneRequiredWithoutModelsNestedInput
    model?: ModelUpdateOneRequiredWithoutYearModelsNestedInput
  }

  export type YearModelUncheckedUpdateWithoutVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrandId?: IntFieldUpdateOperationsInput | number
    modelId?: IntFieldUpdateOperationsInput | number
  }

  export type VersionUpsertWithoutYearModelVersionsInput = {
    update: XOR<VersionUpdateWithoutYearModelVersionsInput, VersionUncheckedUpdateWithoutYearModelVersionsInput>
    create: XOR<VersionCreateWithoutYearModelVersionsInput, VersionUncheckedCreateWithoutYearModelVersionsInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutYearModelVersionsInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutYearModelVersionsInput, VersionUncheckedUpdateWithoutYearModelVersionsInput>
  }

  export type VersionUpdateWithoutYearModelVersionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutYearModelVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutYearModelVersionInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    update: XOR<YearModelVersionBodyTypeUpdateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedUpdateWithoutYearModelVersionInput>
    create: XOR<YearModelVersionBodyTypeCreateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedCreateWithoutYearModelVersionInput>
  }

  export type YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutYearModelVersionInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    data: XOR<YearModelVersionBodyTypeUpdateWithoutYearModelVersionInput, YearModelVersionBodyTypeUncheckedUpdateWithoutYearModelVersionInput>
  }

  export type YearModelVersionBodyTypeUpdateManyWithWhereWithoutYearModelVersionInput = {
    where: YearModelVersionBodyTypeScalarWhereInput
    data: XOR<YearModelVersionBodyTypeUpdateManyMutationInput, YearModelVersionBodyTypeUncheckedUpdateManyWithoutYearModelVersionInput>
  }

  export type YearModelVersionBodyTypeScalarWhereInput = {
    AND?: YearModelVersionBodyTypeScalarWhereInput | YearModelVersionBodyTypeScalarWhereInput[]
    OR?: YearModelVersionBodyTypeScalarWhereInput[]
    NOT?: YearModelVersionBodyTypeScalarWhereInput | YearModelVersionBodyTypeScalarWhereInput[]
    id?: IntFilter<"YearModelVersionBodyType"> | number
    createdAt?: DateTimeFilter<"YearModelVersionBodyType"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyType"> | Date | string
    yearModelVersionId?: IntFilter<"YearModelVersionBodyType"> | number
    bodyTypeId?: IntFilter<"YearModelVersionBodyType"> | number
  }

  export type YearModelVersionCreateWithoutVersionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModel: YearModelCreateNestedOneWithoutVersionsInput
    bodyTypes?: YearModelVersionBodyTypeCreateNestedManyWithoutYearModelVersionInput
  }

  export type YearModelVersionUncheckedCreateWithoutVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelId: number
    bodyTypes?: YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutYearModelVersionInput
  }

  export type YearModelVersionCreateOrConnectWithoutVersionInput = {
    where: YearModelVersionWhereUniqueInput
    create: XOR<YearModelVersionCreateWithoutVersionInput, YearModelVersionUncheckedCreateWithoutVersionInput>
  }

  export type YearModelVersionCreateManyVersionInputEnvelope = {
    data: YearModelVersionCreateManyVersionInput | YearModelVersionCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutVersionInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutVersionInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutVersionInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutVersionInput, VehicleOfferUncheckedCreateWithoutVersionInput>
  }

  export type VehicleOfferCreateManyVersionInputEnvelope = {
    data: VehicleOfferCreateManyVersionInput | VehicleOfferCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type YearModelVersionUpsertWithWhereUniqueWithoutVersionInput = {
    where: YearModelVersionWhereUniqueInput
    update: XOR<YearModelVersionUpdateWithoutVersionInput, YearModelVersionUncheckedUpdateWithoutVersionInput>
    create: XOR<YearModelVersionCreateWithoutVersionInput, YearModelVersionUncheckedCreateWithoutVersionInput>
  }

  export type YearModelVersionUpdateWithWhereUniqueWithoutVersionInput = {
    where: YearModelVersionWhereUniqueInput
    data: XOR<YearModelVersionUpdateWithoutVersionInput, YearModelVersionUncheckedUpdateWithoutVersionInput>
  }

  export type YearModelVersionUpdateManyWithWhereWithoutVersionInput = {
    where: YearModelVersionScalarWhereInput
    data: XOR<YearModelVersionUpdateManyMutationInput, YearModelVersionUncheckedUpdateManyWithoutVersionInput>
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutVersionInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutVersionInput, VehicleOfferUncheckedUpdateWithoutVersionInput>
    create: XOR<VehicleOfferCreateWithoutVersionInput, VehicleOfferUncheckedCreateWithoutVersionInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutVersionInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutVersionInput, VehicleOfferUncheckedUpdateWithoutVersionInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutVersionInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutVersionInput>
  }

  export type YearModelVersionCreateWithoutBodyTypesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModel: YearModelCreateNestedOneWithoutVersionsInput
    version: VersionCreateNestedOneWithoutYearModelVersionsInput
  }

  export type YearModelVersionUncheckedCreateWithoutBodyTypesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelId: number
    versionId: number
  }

  export type YearModelVersionCreateOrConnectWithoutBodyTypesInput = {
    where: YearModelVersionWhereUniqueInput
    create: XOR<YearModelVersionCreateWithoutBodyTypesInput, YearModelVersionUncheckedCreateWithoutBodyTypesInput>
  }

  export type BodyTypeCreateWithoutYearModelVersionBodyTypesInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutBodyTypeInput
  }

  export type BodyTypeUncheckedCreateWithoutYearModelVersionBodyTypesInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutBodyTypeInput
  }

  export type BodyTypeCreateOrConnectWithoutYearModelVersionBodyTypesInput = {
    where: BodyTypeWhereUniqueInput
    create: XOR<BodyTypeCreateWithoutYearModelVersionBodyTypesInput, BodyTypeUncheckedCreateWithoutYearModelVersionBodyTypesInput>
  }

  export type YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    fuelType: FuelTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelsInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fuelTypeId: number
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput
  }

  export type YearModelVersionBodyTypeFuelCreateOrConnectWithoutYearModelVersionBodyTypeInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput>
  }

  export type YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInputEnvelope = {
    data: YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInput | YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInput[]
    skipDuplicates?: boolean
  }

  export type YearModelVersionUpsertWithoutBodyTypesInput = {
    update: XOR<YearModelVersionUpdateWithoutBodyTypesInput, YearModelVersionUncheckedUpdateWithoutBodyTypesInput>
    create: XOR<YearModelVersionCreateWithoutBodyTypesInput, YearModelVersionUncheckedCreateWithoutBodyTypesInput>
    where?: YearModelVersionWhereInput
  }

  export type YearModelVersionUpdateToOneWithWhereWithoutBodyTypesInput = {
    where?: YearModelVersionWhereInput
    data: XOR<YearModelVersionUpdateWithoutBodyTypesInput, YearModelVersionUncheckedUpdateWithoutBodyTypesInput>
  }

  export type YearModelVersionUpdateWithoutBodyTypesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModel?: YearModelUpdateOneRequiredWithoutVersionsNestedInput
    version?: VersionUpdateOneRequiredWithoutYearModelVersionsNestedInput
  }

  export type YearModelVersionUncheckedUpdateWithoutBodyTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
  }

  export type BodyTypeUpsertWithoutYearModelVersionBodyTypesInput = {
    update: XOR<BodyTypeUpdateWithoutYearModelVersionBodyTypesInput, BodyTypeUncheckedUpdateWithoutYearModelVersionBodyTypesInput>
    create: XOR<BodyTypeCreateWithoutYearModelVersionBodyTypesInput, BodyTypeUncheckedCreateWithoutYearModelVersionBodyTypesInput>
    where?: BodyTypeWhereInput
  }

  export type BodyTypeUpdateToOneWithWhereWithoutYearModelVersionBodyTypesInput = {
    where?: BodyTypeWhereInput
    data: XOR<BodyTypeUpdateWithoutYearModelVersionBodyTypesInput, BodyTypeUncheckedUpdateWithoutYearModelVersionBodyTypesInput>
  }

  export type BodyTypeUpdateWithoutYearModelVersionBodyTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutBodyTypeNestedInput
  }

  export type BodyTypeUncheckedUpdateWithoutYearModelVersionBodyTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    update: XOR<YearModelVersionBodyTypeFuelUpdateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutYearModelVersionBodyTypeInput>
    create: XOR<YearModelVersionBodyTypeFuelCreateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutYearModelVersionBodyTypeInput>
  }

  export type YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    data: XOR<YearModelVersionBodyTypeFuelUpdateWithoutYearModelVersionBodyTypeInput, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutYearModelVersionBodyTypeInput>
  }

  export type YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutYearModelVersionBodyTypeInput = {
    where: YearModelVersionBodyTypeFuelScalarWhereInput
    data: XOR<YearModelVersionBodyTypeFuelUpdateManyMutationInput, YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutYearModelVersionBodyTypeInput>
  }

  export type YearModelVersionBodyTypeFuelScalarWhereInput = {
    AND?: YearModelVersionBodyTypeFuelScalarWhereInput | YearModelVersionBodyTypeFuelScalarWhereInput[]
    OR?: YearModelVersionBodyTypeFuelScalarWhereInput[]
    NOT?: YearModelVersionBodyTypeFuelScalarWhereInput | YearModelVersionBodyTypeFuelScalarWhereInput[]
    id?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    createdAt?: DateTimeFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyTypeFuel"> | Date | string
    yearModelVersionBodyTypeId?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
    fuelTypeId?: IntFilter<"YearModelVersionBodyTypeFuel"> | number
  }

  export type YearModelVersionBodyTypeCreateWithoutBodyTypeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersion: YearModelVersionCreateNestedOneWithoutBodyTypesInput
    fuelTypes?: YearModelVersionBodyTypeFuelCreateNestedManyWithoutYearModelVersionBodyTypeInput
  }

  export type YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionId: number
    fuelTypes?: YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeInput
  }

  export type YearModelVersionBodyTypeCreateOrConnectWithoutBodyTypeInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeCreateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput>
  }

  export type YearModelVersionBodyTypeCreateManyBodyTypeInputEnvelope = {
    data: YearModelVersionBodyTypeCreateManyBodyTypeInput | YearModelVersionBodyTypeCreateManyBodyTypeInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutBodyTypeInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutBodyTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutBodyTypeInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutBodyTypeInput, VehicleOfferUncheckedCreateWithoutBodyTypeInput>
  }

  export type VehicleOfferCreateManyBodyTypeInputEnvelope = {
    data: VehicleOfferCreateManyBodyTypeInput | VehicleOfferCreateManyBodyTypeInput[]
    skipDuplicates?: boolean
  }

  export type YearModelVersionBodyTypeUpsertWithWhereUniqueWithoutBodyTypeInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    update: XOR<YearModelVersionBodyTypeUpdateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedUpdateWithoutBodyTypeInput>
    create: XOR<YearModelVersionBodyTypeCreateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedCreateWithoutBodyTypeInput>
  }

  export type YearModelVersionBodyTypeUpdateWithWhereUniqueWithoutBodyTypeInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    data: XOR<YearModelVersionBodyTypeUpdateWithoutBodyTypeInput, YearModelVersionBodyTypeUncheckedUpdateWithoutBodyTypeInput>
  }

  export type YearModelVersionBodyTypeUpdateManyWithWhereWithoutBodyTypeInput = {
    where: YearModelVersionBodyTypeScalarWhereInput
    data: XOR<YearModelVersionBodyTypeUpdateManyMutationInput, YearModelVersionBodyTypeUncheckedUpdateManyWithoutBodyTypeInput>
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutBodyTypeInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutBodyTypeInput, VehicleOfferUncheckedUpdateWithoutBodyTypeInput>
    create: XOR<VehicleOfferCreateWithoutBodyTypeInput, VehicleOfferUncheckedCreateWithoutBodyTypeInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutBodyTypeInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutBodyTypeInput, VehicleOfferUncheckedUpdateWithoutBodyTypeInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutBodyTypeInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutBodyTypeInput>
  }

  export type YearModelVersionBodyTypeCreateWithoutFuelTypesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersion: YearModelVersionCreateNestedOneWithoutBodyTypesInput
    bodyType: BodyTypeCreateNestedOneWithoutYearModelVersionBodyTypesInput
  }

  export type YearModelVersionBodyTypeUncheckedCreateWithoutFuelTypesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionId: number
    bodyTypeId: number
  }

  export type YearModelVersionBodyTypeCreateOrConnectWithoutFuelTypesInput = {
    where: YearModelVersionBodyTypeWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeCreateWithoutFuelTypesInput, YearModelVersionBodyTypeUncheckedCreateWithoutFuelTypesInput>
  }

  export type FuelTypeCreateWithoutYearModelVersionBodyTypeFuelsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutFuelTypeInput
  }

  export type FuelTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutFuelTypeInput
  }

  export type FuelTypeCreateOrConnectWithoutYearModelVersionBodyTypeFuelsInput = {
    where: FuelTypeWhereUniqueInput
    create: XOR<FuelTypeCreateWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelsInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    transmissionType: TransmissionTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelTransmissionsInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transmissionTypeId: number
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutYearModelVersionBodyTypeFuelInput = {
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInputEnvelope = {
    data: YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInput | YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInput[]
    skipDuplicates?: boolean
  }

  export type YearModelVersionBodyTypeUpsertWithoutFuelTypesInput = {
    update: XOR<YearModelVersionBodyTypeUpdateWithoutFuelTypesInput, YearModelVersionBodyTypeUncheckedUpdateWithoutFuelTypesInput>
    create: XOR<YearModelVersionBodyTypeCreateWithoutFuelTypesInput, YearModelVersionBodyTypeUncheckedCreateWithoutFuelTypesInput>
    where?: YearModelVersionBodyTypeWhereInput
  }

  export type YearModelVersionBodyTypeUpdateToOneWithWhereWithoutFuelTypesInput = {
    where?: YearModelVersionBodyTypeWhereInput
    data: XOR<YearModelVersionBodyTypeUpdateWithoutFuelTypesInput, YearModelVersionBodyTypeUncheckedUpdateWithoutFuelTypesInput>
  }

  export type YearModelVersionBodyTypeUpdateWithoutFuelTypesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersion?: YearModelVersionUpdateOneRequiredWithoutBodyTypesNestedInput
    bodyType?: BodyTypeUpdateOneRequiredWithoutYearModelVersionBodyTypesNestedInput
  }

  export type YearModelVersionBodyTypeUncheckedUpdateWithoutFuelTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionId?: IntFieldUpdateOperationsInput | number
    bodyTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type FuelTypeUpsertWithoutYearModelVersionBodyTypeFuelsInput = {
    update: XOR<FuelTypeUpdateWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelsInput>
    create: XOR<FuelTypeCreateWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelsInput>
    where?: FuelTypeWhereInput
  }

  export type FuelTypeUpdateToOneWithWhereWithoutYearModelVersionBodyTypeFuelsInput = {
    where?: FuelTypeWhereInput
    data: XOR<FuelTypeUpdateWithoutYearModelVersionBodyTypeFuelsInput, FuelTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelsInput>
  }

  export type FuelTypeUpdateWithoutYearModelVersionBodyTypeFuelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutFuelTypeNestedInput
  }

  export type FuelTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutFuelTypeNestedInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput = {
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    update: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateWithoutYearModelVersionBodyTypeFuelInput>
    create: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutYearModelVersionBodyTypeFuelInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutYearModelVersionBodyTypeFuelInput = {
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateWithoutYearModelVersionBodyTypeFuelInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateWithoutYearModelVersionBodyTypeFuelInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutYearModelVersionBodyTypeFuelInput = {
    where: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateManyMutationInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutYearModelVersionBodyTypeFuelInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionScalarWhereInput = {
    AND?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
    OR?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
    NOT?: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput | YearModelVersionBodyTypeFuelTransmissionScalarWhereInput[]
    id?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    createdAt?: DateTimeFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    updatedAt?: DateTimeFilter<"YearModelVersionBodyTypeFuelTransmission"> | Date | string
    yearModelVersionBodyTypeFuelId?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
    transmissionTypeId?: IntFilter<"YearModelVersionBodyTypeFuelTransmission"> | number
  }

  export type YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyType: YearModelVersionBodyTypeCreateNestedOneWithoutFuelTypesInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeId: number
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutYearModelVersionBodyTypeFuelInput
  }

  export type YearModelVersionBodyTypeFuelCreateOrConnectWithoutFuelTypeInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput>
  }

  export type YearModelVersionBodyTypeFuelCreateManyFuelTypeInputEnvelope = {
    data: YearModelVersionBodyTypeFuelCreateManyFuelTypeInput | YearModelVersionBodyTypeFuelCreateManyFuelTypeInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutFuelTypeInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutFuelTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutFuelTypeInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutFuelTypeInput, VehicleOfferUncheckedCreateWithoutFuelTypeInput>
  }

  export type VehicleOfferCreateManyFuelTypeInputEnvelope = {
    data: VehicleOfferCreateManyFuelTypeInput | VehicleOfferCreateManyFuelTypeInput[]
    skipDuplicates?: boolean
  }

  export type YearModelVersionBodyTypeFuelUpsertWithWhereUniqueWithoutFuelTypeInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    update: XOR<YearModelVersionBodyTypeFuelUpdateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutFuelTypeInput>
    create: XOR<YearModelVersionBodyTypeFuelCreateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutFuelTypeInput>
  }

  export type YearModelVersionBodyTypeFuelUpdateWithWhereUniqueWithoutFuelTypeInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    data: XOR<YearModelVersionBodyTypeFuelUpdateWithoutFuelTypeInput, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutFuelTypeInput>
  }

  export type YearModelVersionBodyTypeFuelUpdateManyWithWhereWithoutFuelTypeInput = {
    where: YearModelVersionBodyTypeFuelScalarWhereInput
    data: XOR<YearModelVersionBodyTypeFuelUpdateManyMutationInput, YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutFuelTypeInput>
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutFuelTypeInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutFuelTypeInput, VehicleOfferUncheckedUpdateWithoutFuelTypeInput>
    create: XOR<VehicleOfferCreateWithoutFuelTypeInput, VehicleOfferUncheckedCreateWithoutFuelTypeInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutFuelTypeInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutFuelTypeInput, VehicleOfferUncheckedUpdateWithoutFuelTypeInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutFuelTypeInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutFuelTypeInput>
  }

  export type YearModelVersionBodyTypeFuelCreateWithoutTransmissionTypesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyType: YearModelVersionBodyTypeCreateNestedOneWithoutFuelTypesInput
    fuelType: FuelTypeCreateNestedOneWithoutYearModelVersionBodyTypeFuelsInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedCreateWithoutTransmissionTypesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeId: number
    fuelTypeId: number
  }

  export type YearModelVersionBodyTypeFuelCreateOrConnectWithoutTransmissionTypesInput = {
    where: YearModelVersionBodyTypeFuelWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeFuelCreateWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutTransmissionTypesInput>
  }

  export type TransmissionTypeCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferCreateNestedManyWithoutTransmissionTypeInput
  }

  export type TransmissionTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleOffers?: VehicleOfferUncheckedCreateNestedManyWithoutTransmissionTypeInput
  }

  export type TransmissionTypeCreateOrConnectWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    where: TransmissionTypeWhereUniqueInput
    create: XOR<TransmissionTypeCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
  }

  export type YearModelVersionBodyTypeFuelUpsertWithoutTransmissionTypesInput = {
    update: XOR<YearModelVersionBodyTypeFuelUpdateWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutTransmissionTypesInput>
    create: XOR<YearModelVersionBodyTypeFuelCreateWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUncheckedCreateWithoutTransmissionTypesInput>
    where?: YearModelVersionBodyTypeFuelWhereInput
  }

  export type YearModelVersionBodyTypeFuelUpdateToOneWithWhereWithoutTransmissionTypesInput = {
    where?: YearModelVersionBodyTypeFuelWhereInput
    data: XOR<YearModelVersionBodyTypeFuelUpdateWithoutTransmissionTypesInput, YearModelVersionBodyTypeFuelUncheckedUpdateWithoutTransmissionTypesInput>
  }

  export type YearModelVersionBodyTypeFuelUpdateWithoutTransmissionTypesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyType?: YearModelVersionBodyTypeUpdateOneRequiredWithoutFuelTypesNestedInput
    fuelType?: FuelTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelsNestedInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateWithoutTransmissionTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeId?: IntFieldUpdateOperationsInput | number
    fuelTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type TransmissionTypeUpsertWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    update: XOR<TransmissionTypeUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
    create: XOR<TransmissionTypeCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUncheckedCreateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
    where?: TransmissionTypeWhereInput
  }

  export type TransmissionTypeUpdateToOneWithWhereWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    where?: TransmissionTypeWhereInput
    data: XOR<TransmissionTypeUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput, TransmissionTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput>
  }

  export type TransmissionTypeUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUpdateManyWithoutTransmissionTypeNestedInput
  }

  export type TransmissionTypeUncheckedUpdateWithoutYearModelVersionBodyTypeFuelTransmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutTransmissionTypeNestedInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuel: YearModelVersionBodyTypeFuelCreateNestedOneWithoutTransmissionTypesInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelId: number
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateOrConnectWithoutTransmissionTypeInput = {
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    create: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInputEnvelope = {
    data: YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInput | YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferCreateWithoutTransmissionTypeInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutTransmissionTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutTransmissionTypeInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutTransmissionTypeInput, VehicleOfferUncheckedCreateWithoutTransmissionTypeInput>
  }

  export type VehicleOfferCreateManyTransmissionTypeInputEnvelope = {
    data: VehicleOfferCreateManyTransmissionTypeInput | VehicleOfferCreateManyTransmissionTypeInput[]
    skipDuplicates?: boolean
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpsertWithWhereUniqueWithoutTransmissionTypeInput = {
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    update: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateWithoutTransmissionTypeInput>
    create: XOR<YearModelVersionBodyTypeFuelTransmissionCreateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedCreateWithoutTransmissionTypeInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateWithWhereUniqueWithoutTransmissionTypeInput = {
    where: YearModelVersionBodyTypeFuelTransmissionWhereUniqueInput
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateWithoutTransmissionTypeInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateWithoutTransmissionTypeInput>
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateManyWithWhereWithoutTransmissionTypeInput = {
    where: YearModelVersionBodyTypeFuelTransmissionScalarWhereInput
    data: XOR<YearModelVersionBodyTypeFuelTransmissionUpdateManyMutationInput, YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutTransmissionTypeInput>
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutTransmissionTypeInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutTransmissionTypeInput, VehicleOfferUncheckedUpdateWithoutTransmissionTypeInput>
    create: XOR<VehicleOfferCreateWithoutTransmissionTypeInput, VehicleOfferUncheckedCreateWithoutTransmissionTypeInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutTransmissionTypeInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutTransmissionTypeInput, VehicleOfferUncheckedUpdateWithoutTransmissionTypeInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutTransmissionTypeInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutTransmissionTypeInput>
  }

  export type VehicleOfferCreateWithoutColorInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    images?: VehicleImageCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferUncheckedCreateWithoutColorInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    images?: VehicleImageUncheckedCreateNestedManyWithoutVehicleOfferInput
  }

  export type VehicleOfferCreateOrConnectWithoutColorInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutColorInput, VehicleOfferUncheckedCreateWithoutColorInput>
  }

  export type VehicleOfferCreateManyColorInputEnvelope = {
    data: VehicleOfferCreateManyColorInput | VehicleOfferCreateManyColorInput[]
    skipDuplicates?: boolean
  }

  export type VehicleOfferUpsertWithWhereUniqueWithoutColorInput = {
    where: VehicleOfferWhereUniqueInput
    update: XOR<VehicleOfferUpdateWithoutColorInput, VehicleOfferUncheckedUpdateWithoutColorInput>
    create: XOR<VehicleOfferCreateWithoutColorInput, VehicleOfferUncheckedCreateWithoutColorInput>
  }

  export type VehicleOfferUpdateWithWhereUniqueWithoutColorInput = {
    where: VehicleOfferWhereUniqueInput
    data: XOR<VehicleOfferUpdateWithoutColorInput, VehicleOfferUncheckedUpdateWithoutColorInput>
  }

  export type VehicleOfferUpdateManyWithWhereWithoutColorInput = {
    where: VehicleOfferScalarWhereInput
    data: XOR<VehicleOfferUpdateManyMutationInput, VehicleOfferUncheckedUpdateManyWithoutColorInput>
  }

  export type VehicleOfferCreateWithoutImagesInput = {
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
    vehicleType?: VehicleTypeCreateNestedOneWithoutVehicleOffersInput
    vehicleYear?: VehicleYearCreateNestedOneWithoutVehicleOffersInput
    brand?: BrandCreateNestedOneWithoutVehicleOffersInput
    model?: ModelCreateNestedOneWithoutVehicleOffersInput
    version?: VersionCreateNestedOneWithoutVehicleOffersInput
    bodyType?: BodyTypeCreateNestedOneWithoutVehicleOffersInput
    fuelType?: FuelTypeCreateNestedOneWithoutVehicleOffersInput
    transmissionType?: TransmissionTypeCreateNestedOneWithoutVehicleOffersInput
    color?: ColorCreateNestedOneWithoutVehicleOffersInput
  }

  export type VehicleOfferUncheckedCreateWithoutImagesInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type VehicleOfferCreateOrConnectWithoutImagesInput = {
    where: VehicleOfferWhereUniqueInput
    create: XOR<VehicleOfferCreateWithoutImagesInput, VehicleOfferUncheckedCreateWithoutImagesInput>
  }

  export type VehicleOfferUpsertWithoutImagesInput = {
    update: XOR<VehicleOfferUpdateWithoutImagesInput, VehicleOfferUncheckedUpdateWithoutImagesInput>
    create: XOR<VehicleOfferCreateWithoutImagesInput, VehicleOfferUncheckedCreateWithoutImagesInput>
    where?: VehicleOfferWhereInput
  }

  export type VehicleOfferUpdateToOneWithWhereWithoutImagesInput = {
    where?: VehicleOfferWhereInput
    data: XOR<VehicleOfferUpdateWithoutImagesInput, VehicleOfferUncheckedUpdateWithoutImagesInput>
  }

  export type VehicleOfferUpdateWithoutImagesInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleTypeCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    years?: VehicleYearCreateNestedManyWithoutVehicleTypeInput
  }

  export type VehicleTypeUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    years?: VehicleYearUncheckedCreateNestedManyWithoutVehicleTypeInput
  }

  export type VehicleTypeCreateOrConnectWithoutVehicleOffersInput = {
    where: VehicleTypeWhereUniqueInput
    create: XOR<VehicleTypeCreateWithoutVehicleOffersInput, VehicleTypeUncheckedCreateWithoutVehicleOffersInput>
  }

  export type VehicleYearCreateWithoutVehicleOffersInput = {
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleType: VehicleTypeCreateNestedOneWithoutYearsInput
    brands?: YearBrandCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicleTypeId: number
    brands?: YearBrandUncheckedCreateNestedManyWithoutVehicleYearInput
  }

  export type VehicleYearCreateOrConnectWithoutVehicleOffersInput = {
    where: VehicleYearWhereUniqueInput
    create: XOR<VehicleYearCreateWithoutVehicleOffersInput, VehicleYearUncheckedCreateWithoutVehicleOffersInput>
  }

  export type BrandCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrands?: YearBrandCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrands?: YearBrandUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutVehicleOffersInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutVehicleOffersInput, BrandUncheckedCreateWithoutVehicleOffersInput>
  }

  export type ModelCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModels?: YearModelCreateNestedManyWithoutModelInput
  }

  export type ModelUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModels?: YearModelUncheckedCreateNestedManyWithoutModelInput
  }

  export type ModelCreateOrConnectWithoutVehicleOffersInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutVehicleOffersInput, ModelUncheckedCreateWithoutVehicleOffersInput>
  }

  export type VersionCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersions?: YearModelVersionCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersions?: YearModelVersionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutVehicleOffersInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutVehicleOffersInput, VersionUncheckedCreateWithoutVehicleOffersInput>
  }

  export type BodyTypeCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeCreateNestedManyWithoutBodyTypeInput
  }

  export type BodyTypeUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeUncheckedCreateNestedManyWithoutBodyTypeInput
  }

  export type BodyTypeCreateOrConnectWithoutVehicleOffersInput = {
    where: BodyTypeWhereUniqueInput
    create: XOR<BodyTypeCreateWithoutVehicleOffersInput, BodyTypeUncheckedCreateWithoutVehicleOffersInput>
  }

  export type FuelTypeCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelCreateNestedManyWithoutFuelTypeInput
  }

  export type FuelTypeUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelUncheckedCreateNestedManyWithoutFuelTypeInput
  }

  export type FuelTypeCreateOrConnectWithoutVehicleOffersInput = {
    where: FuelTypeWhereUniqueInput
    create: XOR<FuelTypeCreateWithoutVehicleOffersInput, FuelTypeUncheckedCreateWithoutVehicleOffersInput>
  }

  export type TransmissionTypeCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionCreateNestedManyWithoutTransmissionTypeInput
  }

  export type TransmissionTypeUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionUncheckedCreateNestedManyWithoutTransmissionTypeInput
  }

  export type TransmissionTypeCreateOrConnectWithoutVehicleOffersInput = {
    where: TransmissionTypeWhereUniqueInput
    create: XOR<TransmissionTypeCreateWithoutVehicleOffersInput, TransmissionTypeUncheckedCreateWithoutVehicleOffersInput>
  }

  export type ColorCreateWithoutVehicleOffersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorUncheckedCreateWithoutVehicleOffersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ColorCreateOrConnectWithoutVehicleOffersInput = {
    where: ColorWhereUniqueInput
    create: XOR<ColorCreateWithoutVehicleOffersInput, ColorUncheckedCreateWithoutVehicleOffersInput>
  }

  export type VehicleImageCreateWithoutVehicleOfferInput = {
    url: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleImageUncheckedCreateWithoutVehicleOfferInput = {
    id?: number
    url: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleImageCreateOrConnectWithoutVehicleOfferInput = {
    where: VehicleImageWhereUniqueInput
    create: XOR<VehicleImageCreateWithoutVehicleOfferInput, VehicleImageUncheckedCreateWithoutVehicleOfferInput>
  }

  export type VehicleImageCreateManyVehicleOfferInputEnvelope = {
    data: VehicleImageCreateManyVehicleOfferInput | VehicleImageCreateManyVehicleOfferInput[]
    skipDuplicates?: boolean
  }

  export type VehicleTypeUpsertWithoutVehicleOffersInput = {
    update: XOR<VehicleTypeUpdateWithoutVehicleOffersInput, VehicleTypeUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<VehicleTypeCreateWithoutVehicleOffersInput, VehicleTypeUncheckedCreateWithoutVehicleOffersInput>
    where?: VehicleTypeWhereInput
  }

  export type VehicleTypeUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: VehicleTypeWhereInput
    data: XOR<VehicleTypeUpdateWithoutVehicleOffersInput, VehicleTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type VehicleTypeUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: VehicleYearUpdateManyWithoutVehicleTypeNestedInput
  }

  export type VehicleTypeUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: VehicleYearUncheckedUpdateManyWithoutVehicleTypeNestedInput
  }

  export type VehicleYearUpsertWithoutVehicleOffersInput = {
    update: XOR<VehicleYearUpdateWithoutVehicleOffersInput, VehicleYearUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<VehicleYearCreateWithoutVehicleOffersInput, VehicleYearUncheckedCreateWithoutVehicleOffersInput>
    where?: VehicleYearWhereInput
  }

  export type VehicleYearUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: VehicleYearWhereInput
    data: XOR<VehicleYearUpdateWithoutVehicleOffersInput, VehicleYearUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type VehicleYearUpdateWithoutVehicleOffersInput = {
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleType?: VehicleTypeUpdateOneRequiredWithoutYearsNestedInput
    brands?: YearBrandUpdateManyWithoutVehicleYearNestedInput
  }

  export type VehicleYearUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleTypeId?: IntFieldUpdateOperationsInput | number
    brands?: YearBrandUncheckedUpdateManyWithoutVehicleYearNestedInput
  }

  export type BrandUpsertWithoutVehicleOffersInput = {
    update: XOR<BrandUpdateWithoutVehicleOffersInput, BrandUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<BrandCreateWithoutVehicleOffersInput, BrandUncheckedCreateWithoutVehicleOffersInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutVehicleOffersInput, BrandUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type BrandUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrands?: YearBrandUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrands?: YearBrandUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ModelUpsertWithoutVehicleOffersInput = {
    update: XOR<ModelUpdateWithoutVehicleOffersInput, ModelUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<ModelCreateWithoutVehicleOffersInput, ModelUncheckedCreateWithoutVehicleOffersInput>
    where?: ModelWhereInput
  }

  export type ModelUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: ModelWhereInput
    data: XOR<ModelUpdateWithoutVehicleOffersInput, ModelUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type ModelUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModels?: YearModelUpdateManyWithoutModelNestedInput
  }

  export type ModelUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModels?: YearModelUncheckedUpdateManyWithoutModelNestedInput
  }

  export type VersionUpsertWithoutVehicleOffersInput = {
    update: XOR<VersionUpdateWithoutVehicleOffersInput, VersionUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<VersionCreateWithoutVehicleOffersInput, VersionUncheckedCreateWithoutVehicleOffersInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutVehicleOffersInput, VersionUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type VersionUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersions?: YearModelVersionUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersions?: YearModelVersionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type BodyTypeUpsertWithoutVehicleOffersInput = {
    update: XOR<BodyTypeUpdateWithoutVehicleOffersInput, BodyTypeUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<BodyTypeCreateWithoutVehicleOffersInput, BodyTypeUncheckedCreateWithoutVehicleOffersInput>
    where?: BodyTypeWhereInput
  }

  export type BodyTypeUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: BodyTypeWhereInput
    data: XOR<BodyTypeUpdateWithoutVehicleOffersInput, BodyTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type BodyTypeUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeUpdateManyWithoutBodyTypeNestedInput
  }

  export type BodyTypeUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypes?: YearModelVersionBodyTypeUncheckedUpdateManyWithoutBodyTypeNestedInput
  }

  export type FuelTypeUpsertWithoutVehicleOffersInput = {
    update: XOR<FuelTypeUpdateWithoutVehicleOffersInput, FuelTypeUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<FuelTypeCreateWithoutVehicleOffersInput, FuelTypeUncheckedCreateWithoutVehicleOffersInput>
    where?: FuelTypeWhereInput
  }

  export type FuelTypeUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: FuelTypeWhereInput
    data: XOR<FuelTypeUpdateWithoutVehicleOffersInput, FuelTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type FuelTypeUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelUpdateManyWithoutFuelTypeNestedInput
  }

  export type FuelTypeUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuels?: YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutFuelTypeNestedInput
  }

  export type TransmissionTypeUpsertWithoutVehicleOffersInput = {
    update: XOR<TransmissionTypeUpdateWithoutVehicleOffersInput, TransmissionTypeUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<TransmissionTypeCreateWithoutVehicleOffersInput, TransmissionTypeUncheckedCreateWithoutVehicleOffersInput>
    where?: TransmissionTypeWhereInput
  }

  export type TransmissionTypeUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: TransmissionTypeWhereInput
    data: XOR<TransmissionTypeUpdateWithoutVehicleOffersInput, TransmissionTypeUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type TransmissionTypeUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutTransmissionTypeNestedInput
  }

  export type TransmissionTypeUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelTransmissions?: YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutTransmissionTypeNestedInput
  }

  export type ColorUpsertWithoutVehicleOffersInput = {
    update: XOR<ColorUpdateWithoutVehicleOffersInput, ColorUncheckedUpdateWithoutVehicleOffersInput>
    create: XOR<ColorCreateWithoutVehicleOffersInput, ColorUncheckedCreateWithoutVehicleOffersInput>
    where?: ColorWhereInput
  }

  export type ColorUpdateToOneWithWhereWithoutVehicleOffersInput = {
    where?: ColorWhereInput
    data: XOR<ColorUpdateWithoutVehicleOffersInput, ColorUncheckedUpdateWithoutVehicleOffersInput>
  }

  export type ColorUpdateWithoutVehicleOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ColorUncheckedUpdateWithoutVehicleOffersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageUpsertWithWhereUniqueWithoutVehicleOfferInput = {
    where: VehicleImageWhereUniqueInput
    update: XOR<VehicleImageUpdateWithoutVehicleOfferInput, VehicleImageUncheckedUpdateWithoutVehicleOfferInput>
    create: XOR<VehicleImageCreateWithoutVehicleOfferInput, VehicleImageUncheckedCreateWithoutVehicleOfferInput>
  }

  export type VehicleImageUpdateWithWhereUniqueWithoutVehicleOfferInput = {
    where: VehicleImageWhereUniqueInput
    data: XOR<VehicleImageUpdateWithoutVehicleOfferInput, VehicleImageUncheckedUpdateWithoutVehicleOfferInput>
  }

  export type VehicleImageUpdateManyWithWhereWithoutVehicleOfferInput = {
    where: VehicleImageScalarWhereInput
    data: XOR<VehicleImageUpdateManyMutationInput, VehicleImageUncheckedUpdateManyWithoutVehicleOfferInput>
  }

  export type VehicleImageScalarWhereInput = {
    AND?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
    OR?: VehicleImageScalarWhereInput[]
    NOT?: VehicleImageScalarWhereInput | VehicleImageScalarWhereInput[]
    id?: IntFilter<"VehicleImage"> | number
    url?: StringFilter<"VehicleImage"> | string
    isPrimary?: BoolFilter<"VehicleImage"> | boolean
    createdAt?: DateTimeFilter<"VehicleImage"> | Date | string
    updatedAt?: DateTimeFilter<"VehicleImage"> | Date | string
    vehicleOfferId?: IntFilter<"VehicleImage"> | number
  }

  export type VehicleYearCreateManyVehicleTypeInput = {
    id?: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleOfferCreateManyVehicleTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type VehicleYearUpdateWithoutVehicleTypeInput = {
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: YearBrandUpdateManyWithoutVehicleYearNestedInput
    vehicleOffers?: VehicleOfferUpdateManyWithoutVehicleYearNestedInput
  }

  export type VehicleYearUncheckedUpdateWithoutVehicleTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brands?: YearBrandUncheckedUpdateManyWithoutVehicleYearNestedInput
    vehicleOffers?: VehicleOfferUncheckedUpdateManyWithoutVehicleYearNestedInput
  }

  export type VehicleYearUncheckedUpdateManyWithoutVehicleTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleOfferUpdateWithoutVehicleTypeInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutVehicleTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutVehicleTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearBrandCreateManyVehicleYearInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brandId: number
  }

  export type VehicleOfferCreateManyVehicleYearInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearBrandUpdateWithoutVehicleYearInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutYearBrandsNestedInput
    models?: YearModelUpdateManyWithoutYearBrandNestedInput
  }

  export type YearBrandUncheckedUpdateWithoutVehicleYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandId?: IntFieldUpdateOperationsInput | number
    models?: YearModelUncheckedUpdateManyWithoutYearBrandNestedInput
  }

  export type YearBrandUncheckedUpdateManyWithoutVehicleYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brandId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutVehicleYearInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutVehicleYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutVehicleYearInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearModelCreateManyYearBrandInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    modelId: number
  }

  export type YearModelUpdateWithoutYearBrandInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: ModelUpdateOneRequiredWithoutYearModelsNestedInput
    versions?: YearModelVersionUpdateManyWithoutYearModelNestedInput
  }

  export type YearModelUncheckedUpdateWithoutYearBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelId?: IntFieldUpdateOperationsInput | number
    versions?: YearModelVersionUncheckedUpdateManyWithoutYearModelNestedInput
  }

  export type YearModelUncheckedUpdateManyWithoutYearBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modelId?: IntFieldUpdateOperationsInput | number
  }

  export type YearBrandCreateManyBrandInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearId: number
  }

  export type VehicleOfferCreateManyBrandInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearBrandUpdateWithoutBrandInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleYear?: VehicleYearUpdateOneRequiredWithoutBrandsNestedInput
    models?: YearModelUpdateManyWithoutYearBrandNestedInput
  }

  export type YearBrandUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearId?: IntFieldUpdateOperationsInput | number
    models?: YearModelUncheckedUpdateManyWithoutYearBrandNestedInput
  }

  export type YearBrandUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutBrandInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearModelVersionCreateManyYearModelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    versionId: number
  }

  export type YearModelVersionUpdateWithoutYearModelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: VersionUpdateOneRequiredWithoutYearModelVersionsNestedInput
    bodyTypes?: YearModelVersionBodyTypeUpdateManyWithoutYearModelVersionNestedInput
  }

  export type YearModelVersionUncheckedUpdateWithoutYearModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionId?: IntFieldUpdateOperationsInput | number
    bodyTypes?: YearModelVersionBodyTypeUncheckedUpdateManyWithoutYearModelVersionNestedInput
  }

  export type YearModelVersionUncheckedUpdateManyWithoutYearModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelCreateManyModelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearBrandId: number
  }

  export type VehicleOfferCreateManyModelInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearModelUpdateWithoutModelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrand?: YearBrandUpdateOneRequiredWithoutModelsNestedInput
    versions?: YearModelVersionUpdateManyWithoutYearModelNestedInput
  }

  export type YearModelUncheckedUpdateWithoutModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrandId?: IntFieldUpdateOperationsInput | number
    versions?: YearModelVersionUncheckedUpdateManyWithoutYearModelNestedInput
  }

  export type YearModelUncheckedUpdateManyWithoutModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearBrandId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutModelInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutModelInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearModelVersionBodyTypeCreateManyYearModelVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bodyTypeId: number
  }

  export type YearModelVersionBodyTypeUpdateWithoutYearModelVersionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyType?: BodyTypeUpdateOneRequiredWithoutYearModelVersionBodyTypesNestedInput
    fuelTypes?: YearModelVersionBodyTypeFuelUpdateManyWithoutYearModelVersionBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeUncheckedUpdateWithoutYearModelVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyTypeId?: IntFieldUpdateOperationsInput | number
    fuelTypes?: YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutYearModelVersionBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeUncheckedUpdateManyWithoutYearModelVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bodyTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelVersionCreateManyVersionInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelId: number
  }

  export type VehicleOfferCreateManyVersionInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearModelVersionUpdateWithoutVersionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModel?: YearModelUpdateOneRequiredWithoutVersionsNestedInput
    bodyTypes?: YearModelVersionBodyTypeUpdateManyWithoutYearModelVersionNestedInput
  }

  export type YearModelVersionUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelId?: IntFieldUpdateOperationsInput | number
    bodyTypes?: YearModelVersionBodyTypeUncheckedUpdateManyWithoutYearModelVersionNestedInput
  }

  export type YearModelVersionUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutVersionInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearModelVersionBodyTypeFuelCreateManyYearModelVersionBodyTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fuelTypeId: number
  }

  export type YearModelVersionBodyTypeFuelUpdateWithoutYearModelVersionBodyTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fuelType?: FuelTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelsNestedInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateWithoutYearModelVersionBodyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fuelTypeId?: IntFieldUpdateOperationsInput | number
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutYearModelVersionBodyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fuelTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelVersionBodyTypeCreateManyBodyTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionId: number
  }

  export type VehicleOfferCreateManyBodyTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearModelVersionBodyTypeUpdateWithoutBodyTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersion?: YearModelVersionUpdateOneRequiredWithoutBodyTypesNestedInput
    fuelTypes?: YearModelVersionBodyTypeFuelUpdateManyWithoutYearModelVersionBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeUncheckedUpdateWithoutBodyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionId?: IntFieldUpdateOperationsInput | number
    fuelTypes?: YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutYearModelVersionBodyTypeNestedInput
  }

  export type YearModelVersionBodyTypeUncheckedUpdateManyWithoutBodyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutBodyTypeInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutBodyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutBodyTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateManyYearModelVersionBodyTypeFuelInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transmissionTypeId: number
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateWithoutYearModelVersionBodyTypeFuelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmissionType?: TransmissionTypeUpdateOneRequiredWithoutYearModelVersionBodyTypeFuelTransmissionsNestedInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateWithoutYearModelVersionBodyTypeFuelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmissionTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutYearModelVersionBodyTypeFuelInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transmissionTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelVersionBodyTypeFuelCreateManyFuelTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeId: number
  }

  export type VehicleOfferCreateManyFuelTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    transmissionTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearModelVersionBodyTypeFuelUpdateWithoutFuelTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyType?: YearModelVersionBodyTypeUpdateOneRequiredWithoutFuelTypesNestedInput
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateWithoutFuelTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeId?: IntFieldUpdateOperationsInput | number
    transmissionTypes?: YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutYearModelVersionBodyTypeFuelNestedInput
  }

  export type YearModelVersionBodyTypeFuelUncheckedUpdateManyWithoutFuelTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutFuelTypeInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutFuelTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutFuelTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type YearModelVersionBodyTypeFuelTransmissionCreateManyTransmissionTypeInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    yearModelVersionBodyTypeFuelId: number
  }

  export type VehicleOfferCreateManyTransmissionTypeInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    colorId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type YearModelVersionBodyTypeFuelTransmissionUpdateWithoutTransmissionTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuel?: YearModelVersionBodyTypeFuelUpdateOneRequiredWithoutTransmissionTypesNestedInput
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateWithoutTransmissionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelId?: IntFieldUpdateOperationsInput | number
  }

  export type YearModelVersionBodyTypeFuelTransmissionUncheckedUpdateManyWithoutTransmissionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    yearModelVersionBodyTypeFuelId?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleOfferUpdateWithoutTransmissionTypeInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    color?: ColorUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutTransmissionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutTransmissionTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    colorId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleOfferCreateManyColorInput = {
    id?: number
    year?: number | null
    kilometer?: number | null
    accidentStatus?: string | null
    accidentAmount?: number | null
    status: string
    price?: number | null
    displayValues?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    processedAt?: Date | string | null
    vehicleTypeId?: number | null
    vehicleYearId?: number | null
    brandId?: number | null
    modelId?: number | null
    versionId?: number | null
    bodyTypeId?: number | null
    fuelTypeId?: number | null
    transmissionTypeId?: number | null
    notes?: string | null
    adminNotes?: string | null
    description?: string | null
    registrationDate?: Date | string | null
    listingStatus?: string
  }

  export type VehicleOfferUpdateWithoutColorInput = {
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    vehicleType?: VehicleTypeUpdateOneWithoutVehicleOffersNestedInput
    vehicleYear?: VehicleYearUpdateOneWithoutVehicleOffersNestedInput
    brand?: BrandUpdateOneWithoutVehicleOffersNestedInput
    model?: ModelUpdateOneWithoutVehicleOffersNestedInput
    version?: VersionUpdateOneWithoutVehicleOffersNestedInput
    bodyType?: BodyTypeUpdateOneWithoutVehicleOffersNestedInput
    fuelType?: FuelTypeUpdateOneWithoutVehicleOffersNestedInput
    transmissionType?: TransmissionTypeUpdateOneWithoutVehicleOffersNestedInput
    images?: VehicleImageUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateWithoutColorInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
    images?: VehicleImageUncheckedUpdateManyWithoutVehicleOfferNestedInput
  }

  export type VehicleOfferUncheckedUpdateManyWithoutColorInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: NullableIntFieldUpdateOperationsInput | number | null
    kilometer?: NullableIntFieldUpdateOperationsInput | number | null
    accidentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    accidentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    displayValues?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vehicleTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    vehicleYearId?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: NullableIntFieldUpdateOperationsInput | number | null
    modelId?: NullableIntFieldUpdateOperationsInput | number | null
    versionId?: NullableIntFieldUpdateOperationsInput | number | null
    bodyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    fuelTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    transmissionTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    registrationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listingStatus?: StringFieldUpdateOperationsInput | string
  }

  export type VehicleImageCreateManyVehicleOfferInput = {
    id?: number
    url: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleImageUpdateWithoutVehicleOfferInput = {
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageUncheckedUpdateWithoutVehicleOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleImageUncheckedUpdateManyWithoutVehicleOfferInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}